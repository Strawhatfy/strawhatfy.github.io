<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="书影" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="背景在一般的分布式应用中，要安全有效地同步多服务器多进程之间的共享资源访问，就要涉及到分布式锁。目前项目是基于 Tornado 实现的分布式部署，同时也使用了 Redis 作为缓存。参考了一些资料并结合项目自身的要求后，决定直接使用Redis实现全局的分布式锁。 使用 Redis 实现分布式锁使用 Redis 实现分布式锁最简单方式是创建一对 key-value 值，key 被创建为有一定的生存期">
<meta name="keywords" content="python,tornado,tonadoredis,redis,分布式锁">
<meta property="og:type" content="article">
<meta property="og:title" content="使用 Redis 实现分布式锁">
<meta property="og:url" content="http://yoursite.com/2015/07/09/Distributed locks with Redis/index.html">
<meta property="og:site_name" content="书影">
<meta property="og:description" content="背景在一般的分布式应用中，要安全有效地同步多服务器多进程之间的共享资源访问，就要涉及到分布式锁。目前项目是基于 Tornado 实现的分布式部署，同时也使用了 Redis 作为缓存。参考了一些资料并结合项目自身的要求后，决定直接使用Redis实现全局的分布式锁。 使用 Redis 实现分布式锁使用 Redis 实现分布式锁最简单方式是创建一对 key-value 值，key 被创建为有一定的生存期">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-10-22T15:53:03.321Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用 Redis 实现分布式锁">
<meta name="twitter:description" content="背景在一般的分布式应用中，要安全有效地同步多服务器多进程之间的共享资源访问，就要涉及到分布式锁。目前项目是基于 Tornado 实现的分布式部署，同时也使用了 Redis 作为缓存。参考了一些资料并结合项目自身的要求后，决定直接使用Redis实现全局的分布式锁。 使用 Redis 实现分布式锁使用 Redis 实现分布式锁最简单方式是创建一对 key-value 值，key 被创建为有一定的生存期">
  <link rel="canonical" href="http://yoursite.com/2015/07/09/Distributed locks with Redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>使用 Redis 实现分布式锁 | 书影</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">书影</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/09/Distributed locks with Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">使用 Redis 实现分布式锁

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-07-09 20:00:00" itemprop="dateCreated datePublished" datetime="2015-07-09T20:00:00+08:00">2015-07-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在一般的分布式应用中，要安全有效地同步多服务器多进程之间的共享资源访问，就要涉及到分布式锁。目前项目是基于 Tornado 实现的分布式部署，同时也使用了 Redis 作为缓存。参考了一些资料并结合项目自身的要求后，决定直接使用Redis实现全局的分布式锁。</p>
<h4 id="使用-Redis-实现分布式锁"><a href="#使用-Redis-实现分布式锁" class="headerlink" title="使用 Redis 实现分布式锁"></a>使用 Redis 实现分布式锁</h4><p>使用 Redis 实现分布式锁最简单方式是创建一对 key-value 值，key 被创建为有一定的生存期，因此它最终会被释放。而当客户端想要释放时，则直接删除 key 。基于不同的 Redis 命令，有两种实现方式：</p>
<ol>
<li>Redis 官方早期给的一个实现，使用 SETNX，将 value 设置为超时时间，由代码实现锁超时的检测[有缺陷，有限制，并发不高时可用]；</li>
<li>有同学自己的实现：使用 INCR + EXPIRE，利用 Redis 的超时机制控制锁的生存期[不建议使用]；</li>
<li>Redis 官方给的一个改进实现：使用 SET resource-name anystring NX EX max-lock-time（Redis 2.6.12 后支持） 实现， 利用 Redis 的超时机制控制锁的生存期[Redis 2.6.12 以后建议使用]。</li>
</ol>
<h5 id="使用-SETNX-实现"><a href="#使用-SETNX-实现" class="headerlink" title="使用 SETNX 实现"></a>使用 SETNX 实现</h5><p>Redis 官方最早在 SETNX 命令页给了一个基于该命令的<a href="http://redis.io/commands/setnx" target="_blank" rel="noopener">分布式锁实现</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Acquire lock: SETNX lock.foo &lt;current Unix time + lock timeout + 1&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Release lock: DEL lock.foo</span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果 SETNX 返回 1，则表明客户端获取锁成功， lock.foo 被设置为有效 Unix time。客户端操作完成后调用 DEL 命令释放锁。</p>
</li>
<li><p>如果 SETNX 返回 0，则表明锁已经被其他客户端持有。这时我们可以先返回或进行重试等对方完成或等待锁超时。</p>
</li>
</ol>
<p><strong>处理死锁问题：</strong><br>上述算法中，如果持有锁的客户端发生故障、意外崩溃、或者其他因素因素导致没有释放锁，该怎么解决？。我们可以通过锁的键对应的时间戳来判断这种情况是否发生了，如果当前的时间已经大于lock.foo的值，说明该锁已失效，可以被重新使用。<br>发生这种情况时，可不能简单的通过DEL来删除锁，然后再SETNX一次，当多个客户端检测到锁超时后都会尝试去释放它，这里就可能出现一个竞态条件：</p>
<ol>
<li>C1 和 C2 读取 lock.foo 检查时间戳，先后发现超时了。</li>
<li>C1 发送DEL lock.foo。</li>
<li>C1 发送SETNX lock.foo 并且成功了。</li>
<li>C2 发送DEL lock.foo</li>
<li>C2 发送SETNX lock.foo 并且成功了。</li>
<li><strong>ERROR</strong>: 由于竞态的问题，C1 和 C2 都获取了锁，这下子问题大了。</li>
</ol>
<a id="more"></a>
<p>幸运的是，使用下面的算法可以避免这个问题。我们看看客户端 C4 是怎么做的：</p>
<ol>
<li>C4 发送 SETNX lock.foo 想要获取锁。</li>
<li>但是由于发生故障的客户端 C3 仍然持有锁，所以返回 0 给 C4。</li>
<li>C4 发送 GET lock.foo 来检查锁是否过期， 如果没超时，则等待或重试。</li>
<li><p>反之，如果已经超时， C4 则尝试执行下面的命令来获取锁:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Acquire lock when time expired: GETSET lock.foo &lt;current Unix timestamp + lock timeout + 1&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 GETSET ，C4 拿到的时间戳如果仍然是超时的，那就表明 C4 如愿以偿拿到锁了。</p>
</li>
<li>如果在 C4 之前，有个叫 C5 的客户端比 C4 快一步执行了上面的操作，那么 C4 拿到的时间戳是个未超时的值，这时，C4 没有如期获得锁，需要再次等待或重试。留意一下，尽管 C4 没拿到锁，但它改写了 C5 设置的锁的超时值，但是这点微小的误差（一般情况下锁的持有的时间非常短，所以在该竞态下出现的误差是可以容忍的）是可以容忍的。（<em>Note that even if C4 set the key a bit a few seconds in the future this is not a problem</em>）。</li>
</ol>
<p>为了这个锁的算法更健壮一些，持有锁的客户端在解锁之前应该再检查一次自己的锁是没有超时，再去做 DEL 操作，因为客户端失败的原因很复杂，不仅仅是崩溃也可能是因为某个耗时的操作而挂起，操作完的时候锁因为超时已经锁已经被别人获得，这时就不必解锁了。</p>
<p>仔细的分析这个方案，我们就会发现这里有一个漏洞：Release lock 使用的 DEL 命令不支持 CAS 删除（check-and-set，delete if current value equals old value），在<strong>高并发</strong>情况下就会有一些问题：<strong>确认持有的锁没有超时后执行 DEL 释放锁，由于竞态的存在 Redis 服务器执行命令时锁可能已过期（ “真的” 刚好过期或者被其他客户端竞争锁时设置了一个较小的过期时间而导致过期）且被其他客户端持有。这种情况下将会（非法）释放其他客户端持有的锁。</strong></p>
<p><strong>解决方案：</strong> 先确定锁没有超时，再通过 EVAL 命令（在 Redis 2.6 及以上版本提供） 在执行 Lua 脚本：先执行 GET 指令获取锁的时间戳，确认和自己的时间戳一致后再执行 DEL 释放锁。</p>
<p><strong>设计缺陷：</strong></p>
<ol>
<li>上述解决方案并不完美，只解决了过期锁的释放问题，但是由于这个方案本身的缺陷，客户端获取锁时发生竞争（C4 改写 C5 时间戳的例子），那么 lock.foo 的 “时间戳” 将与本地的不一致，这个时候不会执行 DEL 命令，而是等待锁失效，这在高并发的环境下是低效的。</li>
<li>考虑多服务器环境下，需要服务器进行时间同步校准。</li>
</ol>
<p>在我们的项目中使用了 tornadoredis 库，这个库实现的<a href="https://github.com/leporo/tornado-redis/blob/master/tornadoredis/client.py#L1356" target="_blank" rel="noopener">分布式锁</a>便采用了上述算法。但是在释放锁时有些限制，不过并发量不高的情况下不会有太大的问题，详细的分析参考下述代码注释。实现代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A shared, distributed Lock that uses a Redis server to hold its state.</span></span><br><span class="line"><span class="string">    This Lock can be shared across processes and/or machines. It works</span></span><br><span class="line"><span class="string">    asynchronously and plays nice with the Tornado IOLoop.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    LOCK_FOREVER = float(<span class="number">2</span> ** <span class="number">31</span> + <span class="number">1</span>)  <span class="comment"># 1 past max unix time</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, redis_client, lock_name, lock_ttl=None, polling_interval=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Create a new Lock object using the Redis key ``lock_name`` for</span></span><br><span class="line"><span class="string">        state, that behaves like a threading.Lock.</span></span><br><span class="line"><span class="string">        This method is synchronous, and returns immediately. It doesn't acquire the</span></span><br><span class="line"><span class="string">        Lock or in fact trigger any sort of communications with the Redis server.</span></span><br><span class="line"><span class="string">        This must be done using the Lock object itself.</span></span><br><span class="line"><span class="string">        If specified, ``lock_ttl`` indicates the maximum life time for the lock.</span></span><br><span class="line"><span class="string">        If none is specified, it will remain locked until release() is called.</span></span><br><span class="line"><span class="string">        ``polling_interval`` indicates the time between acquire attempts (polling)</span></span><br><span class="line"><span class="string">        when the lock is in blocking mode and another client is currently</span></span><br><span class="line"><span class="string">        holding the lock.</span></span><br><span class="line"><span class="string">        Note: If using ``lock_ttl``, you should make sure all the hosts</span></span><br><span class="line"><span class="string">        that are running clients have their time synchronized with a network</span></span><br><span class="line"><span class="string">        time service like ntp.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.lock_name = lock_name</span><br><span class="line">        self.acquired_until = <span class="literal">None</span></span><br><span class="line">        self.lock_ttl = lock_ttl</span><br><span class="line">        self.polling_interval = polling_interval</span><br><span class="line">        <span class="keyword">if</span> self.lock_ttl <span class="keyword">and</span> self.polling_interval &gt; self.lock_ttl:</span><br><span class="line">            <span class="keyword">raise</span> LockError(<span class="string">"'polling_interval' must be less than 'lock_ttl'"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.engine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self, blocking=True, callback=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Acquire the lock.</span></span><br><span class="line"><span class="string">        Returns True once the lock is acquired.</span></span><br><span class="line"><span class="string">        If ``blocking`` is False, always return immediately. If the lock</span></span><br><span class="line"><span class="string">        was acquired, return True, otherwise return False.</span></span><br><span class="line"><span class="string">        Otherwise, block until the lock is acquired (or an error occurs).</span></span><br><span class="line"><span class="string">        If ``callback`` is supplied, it is called with the result.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Loop until we have a conclusive result</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Get the current time</span></span><br><span class="line">            unixtime = int(mod_time.time())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># If the lock has a limited lifetime, create a timeout value</span></span><br><span class="line">            <span class="keyword">if</span> self.lock_ttl:</span><br><span class="line">                timeout_at = unixtime + self.lock_ttl</span><br><span class="line">            <span class="comment"># Otherwise, set the timeout value at forever (dangerous)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                timeout_at = Lock.LOCK_FOREVER</span><br><span class="line">            timeout_at = float(timeout_at)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Try and get the lock, setting the timeout value in the appropriate key,</span></span><br><span class="line">            <span class="comment"># but only if a previous value does not exist in Redis</span></span><br><span class="line">            result = <span class="keyword">yield</span> gen.Task(self.redis_client.setnx, self.lock_name, timeout_at)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># If we managed to get the lock</span></span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># We successfully acquired the lock!</span></span><br><span class="line">                self.acquired_until = timeout_at</span><br><span class="line">                <span class="keyword">if</span> callback:</span><br><span class="line">                    callback(<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># We didn't get the lock, another value is already there</span></span><br><span class="line">            <span class="comment"># Check to see if the current lock timeout value has already expired</span></span><br><span class="line">            result = <span class="keyword">yield</span> gen.Task(self.redis_client.get, self.lock_name)</span><br><span class="line">            existing = float(result <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Has it expired?</span></span><br><span class="line">            <span class="keyword">if</span> existing &lt; unixtime:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># The previous lock is expired. We attempt to overwrite it, getting the current value</span></span><br><span class="line">                <span class="comment"># in the server, just in case someone tried to get the lock at the same time</span></span><br><span class="line">                result = <span class="keyword">yield</span> gen.Task(self.redis_client.getset,</span><br><span class="line">                                        self.lock_name,</span><br><span class="line">                                        timeout_at)</span><br><span class="line">                existing = float(result <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># If the value we read is older than our own current timestamp, we managed to get the</span></span><br><span class="line">                <span class="comment"># lock with no issues - the timeout has indeed expired</span></span><br><span class="line">                <span class="keyword">if</span> existing &lt; unixtime:</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># We successfully acquired the lock!</span></span><br><span class="line">                    self.acquired_until = timeout_at</span><br><span class="line">                    <span class="keyword">if</span> callback:</span><br><span class="line">                        callback(<span class="literal">True</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># However, if we got here, then the value read from the Redis server is newer than</span></span><br><span class="line">                <span class="comment"># our own current timestamp - meaning someone already got the lock before us.</span></span><br><span class="line">                <span class="comment"># We failed getting the lock.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># If we are not signalled to block</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> blocking:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># We failed acquiring the lock...</span></span><br><span class="line">                <span class="keyword">if</span> callback:</span><br><span class="line">                    callback(<span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Otherwise, we "sleep" for an amount of time equal to the polling interval, after which</span></span><br><span class="line">            <span class="comment"># we will try getting the lock again.</span></span><br><span class="line">            <span class="keyword">yield</span> gen.Task(self.redis_client._io_loop.add_timeout,</span><br><span class="line">                           self.redis_client._io_loop.time() + self.polling_interval)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.engine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self, callback=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Releases the already acquired lock.</span></span><br><span class="line"><span class="string">        If ``callback`` is supplied, it is called with True when finished.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.acquired_until <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Cannot release an unlocked lock"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get the current lock value</span></span><br><span class="line">        result = <span class="keyword">yield</span> gen.Task(self.redis_client.get, self.lock_name)</span><br><span class="line">        existing = float(result <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从上下文代码中可以看出，在这个实现中，有一个限制：获取锁的时候设置的 lock_ttl 必须能够保证释放锁时，锁未过期。</span></span><br><span class="line">        <span class="comment"># 否则，当前锁过期后，将会非法释放其他客户端持有的锁。如果无法估计持有锁后代码的执行时间，则可以增加当前锁的过期检测，</span></span><br><span class="line">        <span class="comment"># 当 self.acquired_until &lt;= int(mod_time.time()) 时不执行 DEL 命令。不过，这个限制在一般的应用中倒是可以满足，</span></span><br><span class="line">        <span class="comment"># 所以这个实现不会有太大的问题。</span></span><br><span class="line">        <span class="comment"># 由于 GET、DEL 之间的时间差，以及 DEL 命令发出到 执行 之间的时间差，高并发情况下，锁过期释放的问题依然存在，这个是</span></span><br><span class="line">        <span class="comment"># 算法缺陷。并发不大的情况下，问题不大。</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># 注：这个条件判断 existing &gt;= self.acquired_until 是有这样一个潜在的前提，使用锁的客户端代码正常运行的情况下，</span></span><br><span class="line">        <span class="comment"># 考虑到并发代码使用相同的 lock_ttl 获取锁，竞争失败的客户端将会把锁的过期时间设置的更长一些，这里的判断是有意义的。</span></span><br><span class="line">        <span class="comment"># If the lock time is in the future, delete the lock</span></span><br><span class="line">        <span class="keyword">if</span> existing &gt;= self.acquired_until:</span><br><span class="line">            <span class="keyword">yield</span> gen.Task(self.redis_client.delete, self.lock_name)</span><br><span class="line">        self.acquired_until = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># That is it.</span></span><br><span class="line">        <span class="keyword">if</span> callback:</span><br><span class="line">            callback(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<h5 id="使用-INCR-EXPIRE-实现"><a href="#使用-INCR-EXPIRE-实现" class="headerlink" title="使用 INCR + EXPIRE 实现"></a>使用 INCR + EXPIRE 实现</h5><p>该方案的实现来源这篇 blog <a href="http://blog.csdn.net/wangjia184/article/details/20642331" target="_blank" rel="noopener">《Redis实现分布式全局锁》</a></p>
<ol>
<li>客户端A通过 INCR locker.foo 获取名为 locker.foo 的锁，若获取的值为1，则表示获取成功，转入下一步，否则获取失败；</li>
<li>执行 EXPIRE locker.foo seconds 设置锁的过期时间，设置成功转入下一步；</li>
<li>执行共享资源访问；</li>
<li>执行 DEL locker.foo 释放锁。</li>
</ol>
<p>伪代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(INCR(&apos;locker.foo&apos;) == 1)</span><br><span class="line">&#123;</span><br><span class="line">     // 设置锁的超时时间为1分钟，这个可以设置为一个较大的值来避免锁提前过期释放。</span><br><span class="line">     EXPIRE(60)</span><br><span class="line"></span><br><span class="line">     // 执行共享资源访问</span><br><span class="line">	 DO_SOMETHING()</span><br><span class="line"></span><br><span class="line">     // 释放锁</span><br><span class="line">     DEL(&apos;locker.foo&apos;)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该实现有一个严重的“死锁”问题：如果 INCR 命令获取锁成功后，EXPIRE 失败，会导致锁无法正常释放。可用的解决方案是：借助 EVAL 命令，将 INCR 、 EXPIRE 操作封装在一个 Lua 脚本中执行，先执行 INCR 命令，成功获取锁后再执行 EXPIRE。以下是示例 Lua 代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Set a lock</span></span><br><span class="line"><span class="comment">-- KEYS[1]   - key</span></span><br><span class="line"><span class="comment">-- KEYS[2]   - ttl in ms</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key     = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> ttl     = KEYS[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> lockSet = redis.call(<span class="string">'incr'</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lockSet == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">  redis.call(<span class="string">'pexpire'</span>, key, ttl)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lockSet</span><br></pre></td></tr></table></figure>
<p><strong><em>注：</em></strong> 由于 EVAL 命令仅在 Redis 2.6 版本后提供，对于之前的版本只能通过 MULTI/EXEC 将 INCR 、 EXPIRE 封装在一个事务中来处理。但是由于 MULTI/EXEC 的限制，没有办法和使用 Lua 脚本一样根据 INCR 执行结果来执行 EXPIRE ，所以如果获取锁失败，会导致 TTL 不断被延长，在高并发的环境里如果拿到锁的进程意外挂掉而没有正常释放锁，锁便只能等到过期才能被其他客户端持有，而这个过期时间的长短取决于获取锁时的竞争激烈情况。<strong>该解决方案有严重缺陷，不适合高并发环境</strong>。</p>
<p><strong><em>++实际上，由于不能通过一个原语完成获取锁和设置锁过期时间的操作，即使通过上述 Lua 脚本来获取锁，仍然是有问题的。由于 Redis 事务的特点，只保证 INCR 、 EXPIRE 两条命令在 Redis 上是连续执行的，但当 EXPIRE 命令失败后并不会回滚 INCR 命令，所以 “死锁” 问题依然没有解决（取决于 Redis 的稳定性）。同时，也存在锁过期后非法释放其他客户端持有的锁的问题，且由于依赖 redis 的自动过期机制，便无法检测到此问题。++</em></strong></p>
<h5 id="使用-SET-resource-name-anystring-NX-EX-max-lock-time-实现"><a href="#使用-SET-resource-name-anystring-NX-EX-max-lock-time-实现" class="headerlink" title="使用 SET resource-name anystring NX EX max-lock-time 实现"></a>使用 SET resource-name anystring NX EX max-lock-time 实现</h5><p>该方案在 Redis 官方 <a href="http://redis.io/commands/set" target="_blank" rel="noopener">SET 命令页</a>有详细介绍。<br>在介绍该分布式锁设计之前，我们先来看一下在从 Redis 2.6.12 开始 SET 提供的新特性，命令 <strong>SET key value [EX seconds] [PX milliseconds] [NX|XX]</strong>，其中：</p>
<ol>
<li>EX seconds – 以秒为单位设置 key 的过期时间；</li>
<li>PX milliseconds – 以毫秒为单位设置 key 的过期时间；</li>
<li>NX –  将key 的值设为value ，当且仅当key 不存在，等效于  SETNX。</li>
<li>XX –  将key 的值设为value ，当且仅当key 存在，等效于  SETEX。</li>
</ol>
<p><strong>注：</strong>由于 SET 已经能够取代  SETNX, SETEX, PSETEX 命令，所以在未来的版本中，官方将逐渐放弃这3个命令，并最终移除。</p>
<p>使用 SET 的新特性，改进旧版的分布式锁设计，主要有两个优化：</p>
<ol>
<li><p>客户端通过 SET 命令可以同时完成获取锁和设置锁的过期时间：SET lock.foo token NX EX max-lock-time（原子操作，没有INCR 、 EXPIRE两个操作的事务问题），锁将在超时后自动过期，不担心之前设计的 “死锁” 问题，也没有多服务器时间同步校准的问题。</p>
</li>
<li><p>使用 Lua 脚本实现 CAS 删除，使锁更健壮。获取锁时为锁设置一个 token （一个无法猜测的随机字符串），释放锁时先比较 token 的值以保证只释放持有的有效锁。释放锁的 Lua 代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1]</span><br><span class="line">then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="单点问题"><a href="#单点问题" class="headerlink" title="单点问题"></a>单点问题</h4><p>上述实现都有一个单点问题： Redis 节点挂了肿么办？这是个很麻烦的问题，并且由于 Redis 主从复制是异步的，我们便不可能简单地实现互斥锁在节点间的安全迁移。当然一般的项目不会有这么高的要求，就目前我们的项目而言，本身Redis已经是单点。。。</p>
<p>对于这个单点问题，Redis 上有一篇文章提供了一个算法来解决，但是实现比较复杂：</p>
<p><a href="http://redis.io/topics/distlock" target="_blank" rel="noopener">《Distributed locks with Redis（原文）》</a> / <a href="http://www.oschina.net/translate/redis-distlock" target="_blank" rel="noopener">《使用 Redis 实现分布式锁（译文）》</a></p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/python/" rel="tag"># python</a>
            
              <a href="/tags/tornado/" rel="tag"># tornado</a>
            
              <a href="/tags/tonadoredis/" rel="tag"># tonadoredis</a>
            
              <a href="/tags/redis/" rel="tag"># redis</a>
            
              <a href="/tags/分布式锁/" rel="tag"># 分布式锁</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2015/07/06/Method Dispatch/" rel="next" title="方法分派">
                  <i class="fa fa-chevron-left"></i> 方法分派
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2015/07/14/PEP 475 - Retry system calls failing with EINTR/" rel="prev" title="PEP475-Retry system calls failing with EINTR">
                  PEP475-Retry system calls failing with EINTR <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#背景"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-Redis-实现分布式锁"><span class="nav-number">2.</span> <span class="nav-text">使用 Redis 实现分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用-SETNX-实现"><span class="nav-number">2.1.</span> <span class="nav-text">使用 SETNX 实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用-INCR-EXPIRE-实现"><span class="nav-number">2.2.</span> <span class="nav-text">使用 INCR + EXPIRE 实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用-SET-resource-name-anystring-NX-EX-max-lock-time-实现"><span class="nav-number">2.3.</span> <span class="nav-text">使用 SET resource-name anystring NX EX max-lock-time 实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单点问题"><span class="nav-number">3.</span> <span class="nav-text">单点问题</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">格拉德.尼古拉斯.D.扯淡</p>
  <div class="site-description" itemprop="description">疏影横斜水清浅，暗香浮动月黄昏。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">147</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">格拉德.尼古拉斯.D.扯淡</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
