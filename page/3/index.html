<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="书影" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
<meta property="og:type" content="website">
<meta property="og:title" content="书影">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="书影">
<meta property="og:description" content="疏影横斜水清浅，暗香浮动月黄昏。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="书影">
<meta name="twitter:description" content="疏影横斜水清浅，暗香浮动月黄昏。">
  <link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>书影</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">书影</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/30/TCP-IP-Protocol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/07/30/TCP-IP-Protocol/" class="post-title-link" itemprop="url">TCP/IP 知识点整理</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-07-30 12:04:01" itemprop="dateCreated datePublished" datetime="2015-07-30T12:04:01+08:00">2015-07-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-network/" itemprop="url" rel="index"><span itemprop="name">computer network</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>在阅读 tornado.iostream 模块时涉及到一些网络异常的处理，在深入了解异常的定义和处理后，觉得有必要对 TCP/IP 协议做一个简单的复习整理，尤其针对直接涉及 socket 编程的 TCP 协议部分。</p>
<p>以下总结的内容依次从 TCP/IP 的分层结构、数据封装与分用、以太网帧结构、IP 数据包结构、TCP 数据段（或报文段）结构来进行，并专门对 TCP 的三次握手和四次挥手做一个较为详细的介绍。</p>
<h4 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP/IP 协议"></a>TCP/IP 协议</h4><h5 id="TCP-IP-的分层结构"><a href="#TCP-IP-的分层结构" class="headerlink" title="TCP/IP 的分层结构"></a>TCP/IP 的分层结构</h5><p>OSI (Open System Interconnect, 开放系统互连参考模型)为开放式互连信息系统提供了一种理论上的网络模型，而 TCP/IP 则是实际实现运行的网络模型。TCP/IP 采用四层结构，它与 OSI 七层结构的对应关系如下图所示：</p>
<img src="/2015/07/30/TCP-IP-Protocol/tcp_ip_layers.png">
<p><strong>注：上述协议分层不是完美的，ICMP/IGMP 作为 IP 的附属协议，其数据是封装在 IP 数据包中的，所以在逻辑上它们是在 IP 的上层，这个在后面数据分用的示意图中会体现；ARP/RARP 也遇到同样的问题，它们与 IP 数据报一样都有各自的以太网帧结构，但又是为 IP 地址转换服务的，所以在逻辑上它们是在 IP 的下层。在《TCP-IP详解》中就将 ARP/RARP 划分到网络接口层。在这个图中，将这几个协议都放在与 IP 同一层只是为了选择一种分类方式，不是绝对的。</strong><br>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/07/30/TCP-IP-Protocol/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/27/tornado.stack_context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/07/27/tornado.stack_context/" class="post-title-link" itemprop="url">tornado.stack_context 模块解析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-07-27 15:50:00" itemprop="dateCreated datePublished" datetime="2015-07-27T15:50:00+08:00">2015-07-27</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tornado/" itemprop="url" rel="index"><span itemprop="name">tornado</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p><strong>注：正文中引用的 Tornado 代码除特别说明外，都默认引用自 Tornado 4.0.1。</strong></p>
<p>通过前面 IOLoop、 tornado.gen 模块的分析，我们基本了解了 Tornado 这个异步框架的核心实现，IOLoop 模块负责驱动异步执行， tornado.gen 模块提供 coroutine 的实现，负责支持使用同步方式编写异步代码。到此为止，一切看起来都还不错。接下来我们来看一看 Tornado 中如何处理异步调用上下文状态的。</p>
<p>一起来思考一个在（所有）异步框架中都会遇到的问题，一个 “异步调用” 可以简单理解为：传递一个 “回调函数” 后便立即返回的调用，框架会在异步动作完成后执行 “回调函数”。很显然，这样就导致了一个问题，由于 “回调函数” 实际执行的环境已经脱离了 “异步调用” 时的环境，这便要求 “回调函数” 不能依赖 ”调用时“ 环境。如果真有这个限制的话，那么这个框架使用起来就不是那么顺手了，试想下面一些场景：</p>
<ol>
<li><p>（在一个线程中）处理多个异步操作时，可能需要一些共享的资源，通常我们可以把这些资源保存到 “线程局部变量” 或者 “全局变量” 中以达到共享的目的。但当不是所有的异步操作都需要这些资源时，将资源暴露到不需要的操作中，很可能引发不可预知的问题。</p>
</li>
<li><p>“回调函数” 执行时的环境已经不是 “调用时” 环境，如果 “回调函数” 抛出一些异常，那么很显然不能被 “调用时” 的上下文捕捉到。这与同步代码比较起来显得不够直观，我们希望减少这种差异。</p>
</li>
</ol>
<p>针对这个问题，Tornado 提供了 tornado.stack_context 模块来解决。按照我个人的理解，简单来说就是通过该模块， Tornado 提供了一个叫 StackContext 的机制， StackContext 是一个栈式上下文结构，它能够像 threadlocal 一样为当前操作保存一个栈式上下文快照，当异步执行结束回调时便可以借助这个机制恢复调用时的环境。</p>
<p>通过源代码中注释，我们来看看 Facebook 的工程师们给出的介绍（<strong>注：我知道我的翻译就是一坨，看不懂这坨的可以直接看源代码的英文原文注释。</strong>）:</p>
<p><code>StackContext</code> 允许应用程序在切换到其他上下文执行时也能保持一个像 threadlocal 一样的状态。一些令人振奋的的例子是使用 <code>StackContext</code> 可以避免显式地使用异步调用的封装器，以及为当前调用增加一些额外的上下文用于输出日志。</p>
<p>这个有些不好理解，异常处理器可以视为这么一种想法（idea）的延伸，它就像一种本地栈的状态，栈在暂停和在新的上下文中恢复时需要被保持(<strong>注：把异常处理器也抽象处理成一种特化的上下文，能够被转移。</strong>)。 <code>StackContext</code> ++<em>把恢复调用栈的工作转到一种控制一个上下文转移的机制上</em>++。</p>
<p>范例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">die_on_error</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        logging.error(<span class="string">"exception in asynchronous operation"</span>,exc_info=<span class="literal">True</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> StackContext(die_on_error):</span><br><span class="line">    <span class="comment"># Any exception thrown here *or in callback and its desendents*</span></span><br><span class="line">    <span class="comment"># will cause the process to exit instead of spinning endlessly</span></span><br><span class="line">    <span class="comment"># in the ioloop.</span></span><br><span class="line">    http_client.fetch(url, callback)</span><br><span class="line">ioloop.start()</span><br></pre></td></tr></table></figure>
<p>大多数应用程序都不需要和 <code>StackContext</code> 直接打交道。什么时候需要用到，这里有些经验法则可供参考：</p>
<ul>
<li><p>如果你在写一个不依赖于 <code>tornado.ioloop</code> 或者 <code>tornado.iostream</code> 这类函数库（这类库提供 stack_context 的默认支持）的异步库（比如一个线程池），那么在任何异步操作之前你需要使用 <code>stack_context.wrap()</code> 函数来取得操作开始时的栈式上下文快照。</p>
</li>
<li><p>如果正在写一个需要使用到一些共享资源（比如连接池）的异步库，那么你需要在 <code>with stack_context.NullContext():</code>  块中创建那些共享资源。这样可以防止 StackContexts 从一个请求泄漏到另一个请求。</p>
</li>
<li><p>如果你想写一些在可以保持到异步回调时异常处理器，那么创建一个 <code>StackContext</code> 或者 <code>ExceptionStackContext</code> ，并把异步调用放在它们的 with 块中。</p>
</li>
</ul>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/07/27/tornado.stack_context/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/22/Tornado.gen/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/07/22/Tornado.gen/" class="post-title-link" itemprop="url">tornado.gen 模块解析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-07-22 12:04:01" itemprop="dateCreated datePublished" datetime="2015-07-22T12:04:01+08:00">2015-07-22</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tornado/" itemprop="url" rel="index"><span itemprop="name">tornado</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p><strong>注：正文中引用的 Tornado 代码除特别说明外，都默认引用自 Tornado 4.0.1。</strong></p>
<p>tornado.gen 模块是一个基于 python generator 实现的异步编程接口。通过该模块提供的 coroutine （<strong>注：这里 coroutine 指的是 ”协程” 概念而不是后面具体实现的 decorator：@gen.decorator</strong>），大大简化了在 Tornado 中编写异步代码的工作 —— 支持 “同步方式编写异步代码” ，避免编写烦人的回调函数。参考官方文档的例子，通常我们编写的异步代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @asynchronous</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        http_client = AsyncHTTPClient()</span><br><span class="line">        http_client.fetch(<span class="string">"http://example.com"</span>,</span><br><span class="line">                          callback=self.on_fetch)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_fetch</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        do_something_with_response(response)</span><br><span class="line">        self.render(<span class="string">"template.html"</span>)</span><br></pre></td></tr></table></figure>
<p>而使用 tornado.gen 模块提供的 decorator ，在 Tornado 3.1 以前我们可以这样写异步代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenAsyncHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @asynchronous</span></span><br><span class="line"><span class="meta">    @gen.engine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        http_client = AsyncHTTPClient()</span><br><span class="line">        response = <span class="keyword">yield</span> http_client.fetch(<span class="string">"http://example.com"</span>)</span><br><span class="line">        do_something_with_response(response)</span><br><span class="line">        self.render(<span class="string">"template.html"</span>)</span><br></pre></td></tr></table></figure>
<p>Tornado 3.1 及以上版本，可以直接使用 @gen.coroutine 来代替 @asynchronous：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenAsyncHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        http_client = AsyncHTTPClient()</span><br><span class="line">        response = <span class="keyword">yield</span> http_client.fetch(<span class="string">"http://example.com"</span>)</span><br><span class="line">        do_something_with_response(response)</span><br><span class="line">        self.render(<span class="string">"template.html"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注：@asynchronous 在 tornado.web 中定义，对于使用了 @gen.coroutine 装饰的方法不需要再使用  @asynchronous 进行装饰，但同时使用前述 2 个 decorator 进行方法装饰也是合法的，在同时使用的情况下需要注意的是 @asynchronous 必须是第 1 个 decorator 。</strong></p>
<p>很显然，采用同步方式编写的异步代码相比起分散在各处的异步回调函数代码，更利于代码的阅读和逻辑的组织。</p>
<p>该模块的实现非常巧妙也不容易理解，作为阅读 Tonardo 源码的笔记，我将在后面内容中结合源码和自己的理解对其实现进行分析。<br>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/07/22/Tornado.gen/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/15/signal — Set handlers for asynchronous events/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/07/15/signal — Set handlers for asynchronous events/" class="post-title-link" itemprop="url">signal — Set handlers for asynchronous events</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-07-15 21:04:01" itemprop="dateCreated datePublished" datetime="2015-07-15T21:04:01+08:00">2015-07-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<a href="https://docs.python.org/2/library/signal.html" target="_blank" rel="noopener">signal — Set handlers for asynchronous events</a></p>
<p>Python的 signal 模块为使用信号处理器提供了一些途径。关于信号和处理器的工作过程有一些规则需要注意：</p>
<ul>
<li><p>除非明确地重置处理器，否则一旦为一个特定的信号设置了处理器，该处理器就将一直有效（Python模仿了BSD的风格接口而不管底层是如何实现的）。唯一例外的是SIGCHLD信号处理器，其由底层实现决定。</p>
</li>
<li><p>无法从critical sections临时阻塞信号（因为在类UNIX系统中都不支持）。</p>
</li>
<li><p>尽管Python信号处理器能在接收到相应信号时立即被异步调用，但实际上是在Python解释器的原子指令之间被调用（注： 意思就是Python信号处理器的调用必须在一条“原子指令”执行完之后才能被调用）。这就意味着若信号到达时Python解释器正在执行一个长时间的纯C计算（比如正则表达式处理一大段文本），那么信号处理器的调用将会被推迟不确定时间。</p>
</li>
<li><p>当一个信号在I/O操作期间到来，信号处理器调用完成后可能导致I/O操作抛出异常。这个依赖于顶层Unix系统的系统调用中断语义。</p>
</li>
<li><p>因为 C 信号处理器总是会返回，所以就没有处理类似  SIGFPE 和 SIGSEGV 导致的同步错误（注： 在POSIX兼容的平台上，SIGFPE（floating-point exception，浮点异常）是当一个进程执行了一个错误的算术操作时发送给它的信号，SIGSEGV（egmentation violation， 段违例）是当一个进程执行了一个无效的内存引用，或发生段错误时发送给它的信号。）。</p>
</li>
<li><p>Python默认设置了一些信号处理器：SIGPIPE信号会被忽略（所以在管道或者套接字上 “写” 错误时将抛出一个普通的Python异常）；SIGINT信号会被包装成一个 KeyboardInterrupt 异常。这些信号处理器都可以被overriden。</p>
</li>
<li><p>多线程信号编程时需要注意一些问题。在同时使用多线程和信号时需要记住的基本规则：signal() 只能在主线程中执行；任何线程都可以执行 alarm(), getsignal(), pause(), setitimer()或者 getitimer()；只有主线程可以设置新的信号处理器，也只有主线程可以接受到信号（尽管底层线程实现支持将信号发送给任何一个独立线程，但是Python的信号模块强制实现只能主线程能接受信号）。这就意味着在Python中信号不能用于线程间通信，使用锁来代替。</p>
</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h2 id="signal-SIG-DFL"><a href="#signal-SIG-DFL" class="headerlink" title="signal.SIG_DFL"></a>signal.SIG_DFL</h2><ul>
<li>这是两个标准信号处理选项之一，该处理选项将简单地执行默认的信号处理函数。例如，在大多数系统中收到 SIGQUIT 信号后转存文件（dump core ）并退出，而忽略掉 SIGCHLD 信号。</li>
</ul>
<h2 id="signal-SIG-IGN"><a href="#signal-SIG-IGN" class="headerlink" title="signal.SIG_IGN"></a>signal.SIG_IGN</h2><ul>
<li>这是另一个默认信号处理器，该处理选项将会忽略指定的信号。例如，signal(SIGCHLD, SIG_IGN)</li>
</ul>
<h2 id="SIG"><a href="#SIG" class="headerlink" title="SIG"></a>SIG</h2><ul>
<li>All the signal numbers are defined symbolically. For example, the hangup signal is defined as signal.SIGHUP; the variable names are identical to the names used in C programs, as found in . The Unix man page for ‘signal()‘ lists the existing signals (on some systems this is signal(2), on others the list is in signal(7)). Note that not all systems define the same set of signal names; only those names defined by the system are defined by this module. （注：每一个信号名称是有一个代表正整数的宏来表示，但是不应该试图去推测宏代表的具体数字，而是直接使用信号名称。这是因为这个数字会随着系统的不同或同一系统的不同版本而不同，但是名称还算是标准化和统一的）
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/07/15/signal — Set handlers for asynchronous events/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/14/PEP 475 - Retry system calls failing with EINTR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/07/14/PEP 475 - Retry system calls failing with EINTR/" class="post-title-link" itemprop="url">PEP475-Retry system calls failing with EINTR</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-07-14 10:55:01" itemprop="dateCreated datePublished" datetime="2015-07-14T10:55:01+08:00">2015-07-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PEP: 475<br>Title: Retry system calls failing with EINTR<br>Version: $Revision$<br>Last-Modified: $Date$<br>Author: Charles-François Natali <a href="mailto:&#x63;&#102;&#46;&#110;&#97;&#x74;&#97;&#x6c;&#105;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;" target="_blank" rel="noopener">&#x63;&#102;&#46;&#110;&#97;&#x74;&#97;&#x6c;&#105;&#x40;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;</a>, Victor Stinner <a href="mailto:&#118;&#x69;&#99;&#116;&#x6f;&#114;&#x2e;&#115;&#116;&#105;&#110;&#x6e;&#101;&#x72;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#118;&#x69;&#99;&#116;&#x6f;&#114;&#x2e;&#115;&#116;&#105;&#110;&#x6e;&#101;&#x72;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;</a><br>BDFL-Delegate: Antoine Pitrou <a href="mailto:&#115;&#x6f;&#108;&#105;&#x70;&#115;&#105;&#x73;&#64;&#112;&#x69;&#x74;&#x72;&#x6f;&#x75;&#46;&#x6e;&#x65;&#116;" target="_blank" rel="noopener">&#115;&#x6f;&#108;&#105;&#x70;&#115;&#105;&#x73;&#64;&#112;&#x69;&#x74;&#x72;&#x6f;&#x75;&#46;&#x6e;&#x65;&#116;</a><br>Status: Final<br>Type: Standards Track<br>Content-Type: text/x-rst<br>Created: 29-July-2014<br>Python-Version: 3.5<br>Resolution: <a href="https://mail.python.org/pipermail/python-dev/2015-February/138018.html" target="_blank" rel="noopener">https://mail.python.org/pipermail/python-dev/2015-February/138018.html</a></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>标准库中提供的系统调用函数在捕获到 <code>EINTR</code> 错误时能够自动重试，以减轻程序编码的负担。</p>
<p>所谓系统调用，我们指的是标准C函数库提供的操作 I/O 或者其他系统资源的函数。</p>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h2><p>在 POSIX 系统中，信号是很常见的，系统调用编码的时候必须准备捕获它们。一些常见的例子：</p>
<ul>
<li><p>最常见的是 <code>SIGINT</code> 信号，当按下 CTRL+C 时发送该信号。 Python 在默认情况下捕获该信号后会抛出一个 <code>KeyboardInterrupt</code> 异常。</p>
</li>
<li><p>当使用到子进程时，子进程退出时会发送 <code>SIGCHLD</code> 信号。</p>
</li>
<li><p>改变终端窗口大小时会向在该终端中运行的应用程序发送 <code>SIGWINCH</code> 信号。</p>
</li>
<li><p>通过 CTRL+z 或者 <code>SIGWINCH</code> 命令将应用程序放到后台执行时发送 <code>SIGCONT</code> 信号。</p>
</li>
</ul>
<p>编写一个安全的 C 信号处理器是困难的：因为并不是所有的函数都是 “异步信号安全的” （例如，<code>printf()</code> 和 <code>malloc()</code> 函数就不是异步信号安全的），同时要处理好信号中断后的重入也是很麻烦的。然后幸运的是，当进程在执行系统调用的过程中被信号中断而失败的时会返回 <code>EINTR</code> 错误以便于程序处理，这样就不必强制要求函数是信号安全的。</p>
<p>这是一种依赖于系统的行为：在某些系统中，设置了 <code>SA_RESTART</code> 标识后，一些系统调用在捕获到 <code>EINTR</code> 错误后会自动重试。尽管如此，当在 Python 中调用 <code>signal.signal()</code> 函数设置信号处理器后会清除 <code>SA_RESTART</code> 标识：这样一来，在 Python 中所有的系统调用都可能会被信号中断而导致失败。</p>
<p>因为接收到一个信号并不是发生异常，所以健壮的 POSIX 编程要求必须能够处理 <code>EINTR</code> 错误（在大多情况下，也就意味着将一个希望操作成功的系统调用函数包装在一个循环中）。如果没有 python 提供的原生支持，应用程序编码就会更繁琐（由于python提供了支持，所以我们不需要专门去处理 <code>EINTR</code> 错误，这样可以使 python 代码更简洁。）。</p>
<h2 id="Python-3-4-中的情况"><a href="#Python-3-4-中的情况" class="headerlink" title="Python 3.4 中的情况"></a>Python 3.4 中的情况</h2><p>在 Python 3.4 中，捕获 <code>InterruptedError</code> 异常（专门用于包装 <code>EINTR</code> 错误的异常类型）的代码被复制到各处系统调用处。但实际上也只有一小部分模块捕获了该异常，要修复这个问题让所有的 Python 模块都处理该异常需要花费好几年的时间。下面是一段捕获 <code>InterruptedError</code> 异常并自动重试  <code>file.read()</code> 的代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = file.read(size)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> InterruptedError:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>Python 标准库中已经实现内部捕获 <code>InterruptedError</code> 异常的模块列表：</p>
<ul>
<li><code>asyncio</code></li>
<li><code>asyncore</code></li>
<li><code>io</code>, <code>_pyio</code></li>
<li><code>multiprocessing</code></li>
<li><code>selectors</code></li>
<li><code>socket</code></li>
<li><code>socketserver</code></li>
<li><code>subprocess</code></li>
</ul>
<p>其他编程语言比如 Perl, Java 和 Go 中系统调用时捕获 <code>EINTR</code> 错误并自动重试已经在语言底层实现了，所以不会影响到库和应用程序。</p>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/07/14/PEP 475 - Retry system calls failing with EINTR/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/09/Distributed locks with Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/07/09/Distributed locks with Redis/" class="post-title-link" itemprop="url">使用 Redis 实现分布式锁</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-07-09 20:00:00" itemprop="dateCreated datePublished" datetime="2015-07-09T20:00:00+08:00">2015-07-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在一般的分布式应用中，要安全有效地同步多服务器多进程之间的共享资源访问，就要涉及到分布式锁。目前项目是基于 Tornado 实现的分布式部署，同时也使用了 Redis 作为缓存。参考了一些资料并结合项目自身的要求后，决定直接使用Redis实现全局的分布式锁。</p>
<h4 id="使用-Redis-实现分布式锁"><a href="#使用-Redis-实现分布式锁" class="headerlink" title="使用 Redis 实现分布式锁"></a>使用 Redis 实现分布式锁</h4><p>使用 Redis 实现分布式锁最简单方式是创建一对 key-value 值，key 被创建为有一定的生存期，因此它最终会被释放。而当客户端想要释放时，则直接删除 key 。基于不同的 Redis 命令，有两种实现方式：</p>
<ol>
<li>Redis 官方早期给的一个实现，使用 SETNX，将 value 设置为超时时间，由代码实现锁超时的检测[有缺陷，有限制，并发不高时可用]；</li>
<li>有同学自己的实现：使用 INCR + EXPIRE，利用 Redis 的超时机制控制锁的生存期[不建议使用]；</li>
<li>Redis 官方给的一个改进实现：使用 SET resource-name anystring NX EX max-lock-time（Redis 2.6.12 后支持） 实现， 利用 Redis 的超时机制控制锁的生存期[Redis 2.6.12 以后建议使用]。</li>
</ol>
<h5 id="使用-SETNX-实现"><a href="#使用-SETNX-实现" class="headerlink" title="使用 SETNX 实现"></a>使用 SETNX 实现</h5><p>Redis 官方最早在 SETNX 命令页给了一个基于该命令的<a href="http://redis.io/commands/setnx" target="_blank" rel="noopener">分布式锁实现</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Acquire lock: SETNX lock.foo &lt;current Unix time + lock timeout + 1&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Release lock: DEL lock.foo</span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果 SETNX 返回 1，则表明客户端获取锁成功， lock.foo 被设置为有效 Unix time。客户端操作完成后调用 DEL 命令释放锁。</p>
</li>
<li><p>如果 SETNX 返回 0，则表明锁已经被其他客户端持有。这时我们可以先返回或进行重试等对方完成或等待锁超时。</p>
</li>
</ol>
<p><strong>处理死锁问题：</strong><br>上述算法中，如果持有锁的客户端发生故障、意外崩溃、或者其他因素因素导致没有释放锁，该怎么解决？。我们可以通过锁的键对应的时间戳来判断这种情况是否发生了，如果当前的时间已经大于lock.foo的值，说明该锁已失效，可以被重新使用。<br>发生这种情况时，可不能简单的通过DEL来删除锁，然后再SETNX一次，当多个客户端检测到锁超时后都会尝试去释放它，这里就可能出现一个竞态条件：</p>
<ol>
<li>C1 和 C2 读取 lock.foo 检查时间戳，先后发现超时了。</li>
<li>C1 发送DEL lock.foo。</li>
<li>C1 发送SETNX lock.foo 并且成功了。</li>
<li>C2 发送DEL lock.foo</li>
<li>C2 发送SETNX lock.foo 并且成功了。</li>
<li><strong>ERROR</strong>: 由于竞态的问题，C1 和 C2 都获取了锁，这下子问题大了。</li>
</ol>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/07/09/Distributed locks with Redis/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/06/Method Dispatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/07/06/Method Dispatch/" class="post-title-link" itemprop="url">方法分派</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-07-06 17:25:43" itemprop="dateCreated datePublished" datetime="2015-07-06T17:25:43+08:00">2015-07-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-基础/" itemprop="url" rel="index"><span itemprop="name">C#基础</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以下内容完全来源于 RednaxelaFX 两篇文章的总结：</p>
<ol>
<li><a href="http://rednaxelafx.iteye.com/blog/260206" target="_blank" rel="noopener">方法分派（method dispatch）的几个例子</a></li>
<li><a href="http://rednaxelafx.iteye.com/blog/265951" target="_blank" rel="noopener">C# 4的方法动态分派逻辑变了……</a></li>
</ol>
<p>面向对象语言中经常会对函数调用的第一个参数做特殊处理，包括语法和语义都很特别。</p>
<ol>
<li>语法的特别之处在于实际上的第一个参数不用写在参数列表里，而是写在某种特殊符号之前（b.foo(0)的“.”），也就是所谓的隐含参数。</li>
<li>语义的特别之处在于这第一个参数的称为方法调用的接收者（reciever）,它的实际类型会参与到方法分派的判断中，而其余的参数要么只参与静态类型判断（单一分派+方法重载），要么也以实际类型参与到方法分派的判断（多分派）。</li>
</ol>
<p><strong>在单一分派静态类型的面向对象语言中，重载仍然是编译时概念：编译器只会根据静态变量的类型来判断选择哪个版本的重载，而不像运行时多态那样根据值的实际类型来判断。</strong></p>
<p>在C#4.0之前方法都是单一分派的，C#4.0增加了“动态类型”，因为dynamic类型运行时才能确定类型，所以会参与方法分派。也就是说，如果一个<strong>虚方法调用的参数的类型是都是dynamic（如果有静态类型参数，那么静态类型参数将不参与方法分派，而是在编译期参与方法推断：<em>This means that for all arguments not statically typed dynamic, the compile time types will be used, regardless of their runtime types.</em>），那么整个方法调用都无法在编译时判定到底应该选用哪个具体版本</strong>。CLR会根据方法接收者（this）和每个参数的实际类型来进行方法分派，这个语义与多分派的语义是相同的。如下代码所示：</p>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/07/06/Method Dispatch/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/30/Generics and Reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/06/30/Generics and Reflection/" class="post-title-link" itemprop="url">C#.NET的泛型与反射</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-06-30 23:25:43" itemprop="dateCreated datePublished" datetime="2015-06-30T23:25:43+08:00">2015-06-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-基础/" itemprop="url" rel="index"><span itemprop="name">C#基础</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>在之前与同事的讨论中发现对C#泛型反射时的一些术语理解有些错误或者不够深刻，借此文对相应的知识进行一下整理。本文分为两个部分，第一部分主要简单的介绍一下 “运行时中泛型”，第二部分对泛型反射的一些术语进行解释并参照代码和输出结果进行分析和巩固。</p>
<h4 id="CLR中的泛型"><a href="#CLR中的泛型" class="headerlink" title="CLR中的泛型"></a>CLR中的泛型</h4><p>在.NET中将泛型类型或者泛型方法编译为MSIL时是包含有类型参数的元数据。也就是说在MSIL层面，只负责泛型的声明和使用，而泛型实例化是由CLR在运行时负责完成的。</p>
<p>泛型声明：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Foo&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> M1&lt;TU&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 泛型的使用</span></span><br><span class="line">        <span class="keyword">var</span> listOne = <span class="keyword">new</span> List&lt;Int32&gt;();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="keyword">typeof</span>(TU));</span><br><span class="line">        Console.WriteLine(<span class="keyword">typeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述泛型类将被编译成名叫 Foo`1 &lt; T &gt; 的泛型类型 ,其 M1&lt; TU &gt; 泛型方法对应的IL代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.method <span class="keyword">public</span> hidebysig instance <span class="keyword">void</span>  M1&lt;TU&gt;() cil managed</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 代码大小       40 (0x28)</span></span><br><span class="line">  .maxstack  <span class="number">1</span></span><br><span class="line">  .<span class="function">locals <span class="title">init</span> (<span class="params">[<span class="number">0</span>] class [mscorlib]System.Collections.Generic.List`<span class="number">1</span>&lt;int32&gt; listOne</span>)</span></span><br><span class="line"><span class="function">  IL_0000:  nop</span></span><br><span class="line"><span class="function">  IL_0001:  newobj     instance <span class="keyword">void</span> class [mscorlib]System.Collections.Generic.List`1&lt;int32&gt;::.<span class="title">ctor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  IL_0006:  stloc.0</span></span><br><span class="line"><span class="function">  IL_0007:  ldtoken    !!TU</span></span><br><span class="line"><span class="function">  IL_000c:  call       class [mscorlib]System.Type [mscorlib]System.Type::<span class="title">GetTypeFromHandle</span>(<span class="params">valuetype [mscorlib]System.RuntimeTypeHandle</span>)</span></span><br><span class="line"><span class="function">  IL_0011:  call       <span class="keyword">void</span> [mscorlib]System.Console::<span class="title">WriteLine</span>(<span class="params"><span class="keyword">object</span></span>)</span></span><br><span class="line"><span class="function">  IL_0016:  nop</span></span><br><span class="line"><span class="function">  IL_0017:  ldtoken    !T</span></span><br><span class="line"><span class="function">  IL_001c:  call       class [mscorlib]System.Type [mscorlib]System.Type::<span class="title">GetTypeFromHandle</span>(<span class="params">valuetype [mscorlib]System.RuntimeTypeHandle</span>)</span></span><br><span class="line"><span class="function">  IL_0021:  call       <span class="keyword">void</span> [mscorlib]System.Console::<span class="title">WriteLine</span>(<span class="params"><span class="keyword">object</span></span>)</span></span><br><span class="line"><span class="function">  IL_0026:  nop</span></span><br><span class="line"><span class="function">  IL_0027:  ret</span></span><br><span class="line"><span class="function">&#125; <span class="comment">// end of method Foo`1::M1</span></span></span><br></pre></td></tr></table></figure>
<p>CLR会根据运行时提供的类型参数是值类型还是引用类型而不同，对于值类型CLR将会为每个类型创建(第一次遇到时)专用的泛型类型，对于引用类型则略有不同。所有的引用类型都会重用同一个泛型版本，大体上可以想象为所有的引用类型使用一个 Object 的泛型实例化版本。之所以这样设计，是因为引用的大小是相同的(32位系统上是32位,64位系统上是64位)，而值类型则不然。这样设计的好处是对于引用类型可以共享同一份native code, 避免“类型爆炸”。（实例化的泛型类型虽然享有独立的元数据，但是共享同一个EEClass，即其TypeHandle指向的MethodTable中的EEClass地址相同。）</p>
<h4 id="泛型与反射"><a href="#泛型与反射" class="headerlink" title="泛型与反射"></a>泛型与反射</h4><p>#####一些术语</p>
<ol>
<li><p>开放泛型类型/方法（open generic type/method）：所有泛型参数都未绑定值的泛型类型/方法定义，例如，Dictionary&lt; TKey, TVal &gt;。</p>
</li>
<li><p>开放构造类型/方法(open constructed type/method)：部分泛型参数绑定了具体类型的值的泛型类型/方法， 例如，Dictionary&lt; String, TVal&gt;。</p>
</li>
<li><p>封闭构造类型/方法(close constructed type/method)：按照 ContainsGenericParameters=true 来定义，分为两种：1）封闭泛型类型/方法（close generic type/method），所有泛型参数都绑定了具体类型的值的泛型类型/方法，例如，Dictionary&lt; String, Int32&gt;；2）普通的类型/方法。</p>
</li>
</ol>
<p><strong><em>注意：在泛型类型上可以调用MakeGenericType生成构造类型，在泛型方法定义上调用MakeGenericMethod生成构造方法。ContainsGenericParameters 属性提供一种标准方法来区分封闭构造类型/方法（可以实例化/调用）和开放构造类型/方法（不能实例化/调用）。</em></strong></p>
<pre><code>ContainsGenericParameters 属性递归搜索类型参数
1、对于开放类型 A&lt; T&gt; 上的所有方法调用 ContainsGenericParameters 都将返回true；
2、对于下面代码中的 listOfSomeUnknownTypeOfList 类型，由于 g1是 开放泛型类型所以listOfSomeUnknownTypeOfList.ContainsGenericParameters 返回 true。

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gl = <span class="keyword">typeof</span>(List&lt;&gt;);</span><br><span class="line"><span class="keyword">var</span> listOfSomeUnknownTypeOfList = gl.MakeGenericType(gl);</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>泛型类型：包括开放泛型类型、开放构造类型、封闭泛型类型</p>
</li>
<li><p>泛型方法：包括开放泛型方法、开放构造方法（注：不包括开放泛型类型、开放构造类型中的非泛型开放构造方法，见后面 “开放泛型类型（及开放构造类型）上的方法反射” 部分内容）、封闭泛型方法</p>
</li>
</ol>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/06/30/Generics and Reflection/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/24/closures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/04/24/closures/" class="post-title-link" itemprop="url">闭包(closures)</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-04-24 19:14:21" itemprop="dateCreated datePublished" datetime="2015-04-24T19:14:21+08:00">2015-04-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程基础/" itemprop="url" rel="index"><span itemprop="name">编程基础</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>一直以来，闭包这种编程结构都是一些语言的重要组成部分。在某些场景中使用闭包能够优雅地解决一些棘手的问题。同时闭包的使用有益于模块化编程，它能以简单的方式开发较小的模块，从而提高开发速度和程序的可复用性。</p>
<p>闭包是一门十分有用的技术，但是由于在C#中函数不是一等公民（First-class citizen）的原因，以前在使用C#的时候我没有深入地去关注其中对闭包的支持。而最近一段时间由于工作需要，主要使用 javascript/python 进行开发，在这两种编程语言中函数都是被视为一等对象，实践中大量使用闭包简化编程。例如在javascript中使用闭包模拟对象实例，在python中利用闭包的特性定义功能强大的装饰器等等。</p>
<p>对于这样一门技术，仅仅会使用不是目的，知其然而知其所以然才是。这篇笔记即是出于这样一种目的而整理的。相比较而言我只对C#、javascript、python比较熟悉，而三者中javascript对闭包的支持相对纯粹和完备，所以笔记中我主要用javascript语言表述。但是涉及具体语言的部分，也使用C#和python语言表述，比如对 “闭包陷阱” 的解决，python受限制的闭包实现。</p>
<p>注：笔记相关的代码，主要的目的是描述问题，所以我并没有一一运行过，不能确保都是正确的。但这不影响相关内容。</p>
<h4 id="闭包，匿名函数，函数对象，自由变量，好乱的样子"><a href="#闭包，匿名函数，函数对象，自由变量，好乱的样子" class="headerlink" title="闭包，匿名函数，函数对象，自由变量，好乱的样子"></a>闭包，匿名函数，函数对象，自由变量，好乱的样子</h4><p>在（一般的）编程语言中，局部变量的作用域仅限于包含它们的函数，脱离了创建它的函数环境后便无法被访问到。但在一些支持嵌套定义函数的语言中，如果内部的函数引用了外部的函数的变量，则可能延长变量的生命周期。例如下面的javascript代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = x * <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = foo(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> f2 = foo(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">print(f1(<span class="number">2</span>)); <span class="comment">// 4</span></span><br><span class="line">print(f2(<span class="number">2</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>外部 foo 函数执行后返回了foo内部定义的匿名函数，以及不在该内部函数中定义的外部变量i。即使离开了创建i的函数环境，我们依然能够通过f1，f2访问到i。这就是一个典型的闭包（Closure）。</p>
<p>其实闭包并不是一个新概念，而是早在上个世纪60年代高级语言发展初期就已经产生。那么究竟闭包是什么呢？按照维基百科闭包的解释，一般我们有两种定义：</p>
<ol>
<li><p>在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，指的是引用了自由变量的函数（<em>自由变量指定的除去函数局部变量之外的其他变量，比如前面例子中的变量i</em>）。</p>
</li>
<li><p>另一种说法认为闭包是由函数和相关的引用环境组合而成的实体。</p>
</li>
</ol>
<p>从定义上可以看出，这两种对闭包的定义具有完全不同的关注点。对于第一种定义，强调的是闭包是函数，是一类特殊的函数。第二种定义认为闭包是函数和引用环境组成的实体，本质上不再是函数，而是函数对象，能够作为对象使用的函数。术语 <strong>first class function</strong> 是对这个概念的精确描述。函数本质上只是一些可执行的代码，一旦被定义好以后就不会发生变化，没有状态，具有引用的透明性。闭包作为函数对象，可以由同一个函数与不同的引用环境组成不同的实例，有状态，没有引用的透明性，所以闭包不再是单纯的函数。</p>
<p>从理解的角度的来说，第二种定义更为精确和利于理解。</p>
<p><strong><em>注：匿名函数与闭包是不同概念，在一般支持闭包的语言中都支持匿名函数，匿名函数可以让我们更容易实现闭包。</em></strong></p>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/04/24/closures/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/22/IOLOOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/04/22/IOLOOP/" class="post-title-link" itemprop="url">tornado：IOLoop模块解析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-04-22 21:04:01" itemprop="dateCreated datePublished" datetime="2015-04-22T21:04:01+08:00">2015-04-22</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tornado/" itemprop="url" rel="index"><span itemprop="name">tornado</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p><a href="https://github.com/tornadoweb/tornado/blob/v4.0.2/tornado/ioloop.py#L17" target="_blank" rel="noopener"><em> </em> <em> <code>ioloop.py</code> </em> <em> </em></a> 是整个tornado的核心模块，负责实现服务器的异步非阻塞机制。其中<a href="https://github.com/tornadoweb/tornado/blob/v4.0.2/tornado/ioloop.py#L70" target="_blank" rel="noopener"><strong> <code>IOLoop</code> </strong></a>类是一个基于level-triggered的I/O事件循环，它使用I/O多路复用模型（select模型）监视每个文件描述符的I/O事件是否就绪，当文件描述符I/O事件就绪后调用对应的处理器（handler）进行处理。本篇笔记是对tornado v4.0.1的 IOLoop模块的源码解析。</p>
<h3 id="IOLoop"><a href="#IOLoop" class="headerlink" title="IOLoop"></a>IOLoop</h3><p>IOLoop在Linux下使用<code>epoll</code>, 在BSD/Mac OS X下使用<code>kqueue</code>，否则使用<code>selelct</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configurable_default</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(select, <span class="string">"epoll"</span>):</span><br><span class="line">        <span class="keyword">from</span> tornado.platform.epoll <span class="keyword">import</span> EPollIOLoop</span><br><span class="line">        <span class="keyword">return</span> EPollIOLoop</span><br><span class="line">    <span class="keyword">if</span> hasattr(select, <span class="string">"kqueue"</span>):</span><br><span class="line">        <span class="comment"># Python 2.6+ on BSD or Mac</span></span><br><span class="line">        <span class="keyword">from</span> tornado.platform.kqueue <span class="keyword">import</span> KQueueIOLoop</span><br><span class="line">        <span class="keyword">return</span> KQueueIOLoop</span><br><span class="line">    <span class="keyword">from</span> tornado.platform.select <span class="keyword">import</span> SelectIOLoop</span><br><span class="line">    <span class="keyword">return</span> SelectIOLoop</span><br></pre></td></tr></table></figure>
<p>通过调用<a href="https://github.com/tornadoweb/tornado/blob/v4.0.2/tornado/ioloop.py#L674" target="_blank" rel="noopener"><code>add_handler</code></a>方法将一个文件描述符(v4.0中增加了对file-like object的支持)加入到I/O事件循环中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_handler</span><span class="params">(self, fd, handler, events)</span>:</span></span><br><span class="line">    <span class="string">"""Registers the given handler to receive the given events for ``fd``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The ``fd`` argument may either be an integer file descriptor or</span></span><br><span class="line"><span class="string">    a file-like object with a ``fileno()`` method (and optionally a</span></span><br><span class="line"><span class="string">    ``close()`` method, which may be called when the `IOLoop` is shut</span></span><br><span class="line"><span class="string">    down).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The ``events`` argument is a bitwise or of the constants</span></span><br><span class="line"><span class="string">    ``IOLoop.READ``, ``IOLoop.WRITE``, and ``IOLoop.ERROR``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    When an event occurs, ``handler(fd, events)`` will be run.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionchanged:: 4.0</span></span><br><span class="line"><span class="string">       Added the ability to pass file-like objects in addition to</span></span><br><span class="line"><span class="string">       raw file descriptors.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    fd, obj = self.split_fd(fd)</span><br><span class="line">    self._handlers[fd] = (obj, stack_context.wrap(handler))</span><br><span class="line">    self._impl.register(fd, events | self.ERROR)</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/04/22/IOLOOP/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">格拉德.尼古拉斯.D.扯淡</p>
  <div class="site-description" itemprop="description">疏影横斜水清浅，暗香浮动月黄昏。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">147</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">格拉德.尼古拉斯.D.扯淡</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
