<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="书影" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
<meta property="og:type" content="website">
<meta property="og:title" content="书影">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="书影">
<meta property="og:description" content="疏影横斜水清浅，暗香浮动月黄昏。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="书影">
<meta name="twitter:description" content="疏影横斜水清浅，暗香浮动月黄昏。">
  <link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>书影</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">书影</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/10/ProcessPoolExecutor_In_Tornado/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/12/10/ProcessPoolExecutor_In_Tornado/" class="post-title-link" itemprop="url">ProcessPoolExecutor In Tornado</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-12-10 14:58:01" itemprop="dateCreated datePublished" datetime="2015-12-10T14:58:01+08:00">2015-12-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tornado/" itemprop="url" rel="index"><span itemprop="name">tornado</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>编程时遇到的阻塞任务一般有两类：</p>
<ol>
<li>等待 I/O 就绪（I/O 密集型）；</li>
<li>耗时的计算工作（CPU 密集型）。</li>
</ol>
<p>遇到这类任务，通常首选考虑是否可以优化操作（主要是针对第 2 种情况），将阻塞限制在可以接受的范围内，若不行则考虑使用多线程或多进程，将阻塞操作交由其他线程（例如 .NET APM，.NET 异步编程模型使用线程池来异步执行任务）或进程（fork/exec、任务队列，或者异步委托第三方服务 API）去异步处理，然后在操作结束后取回结果。对于第 1 种情况，使用操作系统支持的非阻塞 I/O 来提供异步支持是最理想的方式， 这也是 Tornado 的核心工作原理。</p>
<p>由于 Tornado 工作模型的原因，通过异步库（指由系统级非阻塞 I/O 来提供支持的库）来处理 I/O 密集型操作才是 Tornado 的正确工作方式，否则一个任务出现阻塞（或者执行时间过长）就会导致其他请求不能被及时处理。遇上没有异步库支持的 I/O 操作（比如磁盘 I/O 操作，Linux 不能很好地提供异步支持）以及 CPU 密集型操作，在 Tornado 中一般我们可以简单地用下面两种方式进行处理：</p>
<ol>
<li>将阻塞操作委托给 futures 模块的 ThreadPoolExecutor/ProcessPoolExecutor 去执行；</li>
<li>使用 tornado + celery（RabbitMQ 或 Redis 做 Broker，<a href="https://pypi.python.org/pypi/totoro" target="_blank" rel="noopener">totoro</a>我个人弄的一个 tornado+celery 适配库，支持 RabbitMQ 和 Redis），将阻塞操作委托给 celery 执行。</li>
</ol>
<p>NOTE：python2 需要单独安装 futures 模块（pip install futures），python3 自带不需要单独安装。</p>
<p>这篇笔记主要是记录在使用 ProcessPoolExecutor 去执行时遇到的一些问题和最终解决方法。</p>
<h3 id="ThreadPoolExecutor-ProcessPoolExecutor"><a href="#ThreadPoolExecutor-ProcessPoolExecutor" class="headerlink" title="ThreadPoolExecutor/ProcessPoolExecutor"></a>ThreadPoolExecutor/ProcessPoolExecutor</h3><h4 id="如何选择-ThreadPoolExecutor-和-ProcessPoolExecutor"><a href="#如何选择-ThreadPoolExecutor-和-ProcessPoolExecutor" class="headerlink" title="如何选择 ThreadPoolExecutor 和 ProcessPoolExecutor"></a>如何选择 ThreadPoolExecutor 和 ProcessPoolExecutor</h4><p>由于 Python GIL 的原因，利用多线程（“单进程，多线程”） 去处理 CPU 密集型任务并不能有效地利用多核，提高性能。在处理 I/O 密集型任务时，由于遇到 I/O 阻塞时线程会主动释放 GIL，多线程才能明显提高性能。</p>
<p>基于上述原因，在 Tornado 中区分一个任务是 CPU 密集型还是 I/O 密集型很重要，前者选择 ProcessPoolExecutor，后者选择 ThreadPoolExecutor 理论上是正确的。</p>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/12/10/ProcessPoolExecutor_In_Tornado/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/02/tornado.http1connection.HTTP1Connection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/11/02/tornado.http1connection.HTTP1Connection/" class="post-title-link" itemprop="url">tornado.http1connection.HTTP1Connection 消息解析实现</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-11-02 11:45:01" itemprop="dateCreated datePublished" datetime="2015-11-02T11:45:01+08:00">2015-11-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tornado/" itemprop="url" rel="index"><span itemprop="name">tornado</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><code>HTTP1Connection</code> 是 HTTP/1.x 连接的抽象，可作为 client 发起请求和解析响应，也可作为 server 接收请求和回应响应。这里主要分析 <code>HTTP1Connection</code> 中怎样实现对请求和响应数据的解析的。关于请求的发起和回应响应，涉及到如何写的实现，将在后续文章中分析。</p>
<p>在具体分析代码实现之前，先介绍一下 HTTP/1.x 相关的内容以方便后面对代码的理解。</p>
<h3 id="HTTP-1-x-简介"><a href="#HTTP-1-x-简介" class="headerlink" title="HTTP/1.x 简介"></a>HTTP/1.x 简介</h3><p>HTTP 协议是一个应用层协议，协议本身并没有规定使用它或它支持的层。事实上，HTTP 可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。在TCP/IP 协议族上使用 TCP 作为其传输层。</p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>HTTP 协议有多个版本 HTTP/1.x 和 HTTP/2.0。目前使用最广泛的是 HTTP/1.x，包括 HTTP/1.0 和 HTTP/1.1 两个版本，后者是对前者的升级改进，最大的不同有两点：</p>
<ol>
<li>默认支持持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</li>
<li>支持 Host 请求头字段，使得 Web 服务器可以在同一个 IP 和 Port 上使用不同的 HostName 来创建多个虚拟 Web 站点。</li>
</ol>
<h4 id="请求（Request）"><a href="#请求（Request）" class="headerlink" title="请求（Request）"></a>请求（Request）</h4><h5 id="请求消息（Request-Message）"><a href="#请求消息（Request-Message）" class="headerlink" title="请求消息（Request Message）"></a>请求消息（Request Message）</h5><p>请求由客户端向服务器端发出，请求消息由下面 4 部分组成（<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1" target="_blank" rel="noopener">RFC 2616 Request</a>）：</p>
<ol>
<li>Request-Line，请求行，格式为：Method SP Request-URI SP HTTP-Version CRLF， eg. “GET /foo HTTP/1.1”。</li>
<li>Request Header Fields，请求头，*(( general-header | request-header | entity-header ) CRLF)，在 HTTP/1.1 中除了 Host 外其他请求头都是可选的。</li>
<li>空行，CRLF。</li>
<li>消息体，[ message-body ]</li>
</ol>
<p>每个头字段由一个字段名称（name） + 冒号（:） + 字段值(value), 三部分组成，name 是大小写无关的，value 前可以添加任何数量的空格符，头字段可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>
<h5 id="请求方法（Method）"><a href="#请求方法（Method）" class="headerlink" title="请求方法（Method）"></a>请求方法（Method）</h5><p>HTTP/1.x 中定义了 8 中请求方法来以不同的方式操作指定的资源：OPTIONS/GET/HEAD/POST/PUT/DELETE/TRACE/CONNECT/PATCH，方法名称是区分大小写的，具体的定义请参考 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1" target="_blank" rel="noopener">RFC 2616 Request Method</a>。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码 405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码 501（Not Implemented）。</p>
<p><strong> HTTP 服务器至少应该实现 GET 和 HEAD 方法，其他方法都是可选的。 </strong> GET 和 HEAD 方法，除了进行获取资源信息外，不具有其他意义，理论上是”安全的“（实际上其结果取决于服务器的实现）。<br>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/11/02/tornado.http1connection.HTTP1Connection/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/21/tornado.httpserver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/10/21/tornado.httpserver/" class="post-title-link" itemprop="url">tornado.httpserver 模块解析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-10-21 17:25:01" itemprop="dateCreated datePublished" datetime="2015-10-21T17:25:01+08:00">2015-10-21</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tornado/" itemprop="url" rel="index"><span itemprop="name">tornado</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><code>HTTPServer</code> 是 HTTP 协议的 <code>TCPServer</code> 子类实现，<code>HTTPServer</code> 覆写了 <code>handle_stream</code> 方法用于处理 HTTP 协议。与 <code>TCPServer</code> 一样，可以有三种使用模式，源码注释中写的很详细，在 <code>TCPServer</code> 源码解析的部分也已经详细讨论过，这里就不再赘述。</p>
<p>来看看一个简单的 <code>HTTPServer</code> 使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(request)</span>:</span></span><br><span class="line">   message = <span class="string">"You requested %s\n"</span> % request.uri</span><br><span class="line">   request.connection.write_headers(</span><br><span class="line">       httputil.ResponseStartLine(<span class="string">'HTTP/1.1'</span>, <span class="number">200</span>, <span class="string">'OK'</span>),</span><br><span class="line">       &#123;<span class="string">"Content-Length"</span>: str(len(message))&#125;)</span><br><span class="line">   request.connection.write(message)</span><br><span class="line">   request.connection.finish()</span><br><span class="line"></span><br><span class="line">http_server = tornado.httpserver.HTTPServer(handle_request)</span><br><span class="line">http_server.listen(<span class="number">8888</span>)</span><br><span class="line">tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure>
<p>示例代码实现的是一个简单的 echo 服务器，<code>HTTPServer</code> 接受的是一个以 <code>HTTPServerRequest</code> 作为参数的函数 <code>handle_request</code>。</p>
<p><code>HTTPServerRequest</code> 的 <code>connection</code> 字段是一个 <code>HTTPConnection</code> 实例对象，应用代码通过使用 <code>HTTPConnection</code> 的方法响应客户端（write response ）。</p>
<p><code>HTTPServer</code> 支持 HTTP keep-alive 连接和 <code>X-Real-Ip</code>/<code>X-Forwarded-For</code> HTTP Heads。</p>
<p><strong><code>HTTPServer</code> 实际上还接受 <code>HTTPServerConnectionDelegate</code> 实例作为请求处理的委托对象</strong>。如下代码把对请求的处理委托给 <code>tornado.web.Application</code> 对象处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">application = web.Application([</span><br><span class="line">    (<span class="string">r"/"</span>, MainPageHandler),</span><br><span class="line">])</span><br><span class="line">http_server = httpserver.HTTPServer(application)</span><br><span class="line">http_server.listen(<span class="number">8080</span>)</span><br><span class="line">ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure>
<p><code>Application</code> 和 <code>HTTPServer</code> 都是 <code>HTTPServerConnectionDelegate</code> 的子类，<code>HTTPServer</code> 会委托 <code>Application</code> 完成对请求的处理。<strong>这是大多数情况下我们使用 Tornado 的方式</strong>。<br>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/10/21/tornado.httpserver/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/14/tornado.tcpserver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/10/14/tornado.tcpserver/" class="post-title-link" itemprop="url">tornado.tcpserver 模块解析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-10-14 17:25:01" itemprop="dateCreated datePublished" datetime="2015-10-14T17:25:01+08:00">2015-10-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tornado/" itemprop="url" rel="index"><span itemprop="name">tornado</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>有了 <code>tornado.ioloop</code> 和 <code>tornado.iostream</code> 这两个模块的帮助，在 tornado 中要实现一个异步 Web 服务器就变得容易了。</p>
<p><code>tornado.httpserver</code> 模块是 tornado 的 Web 服务器模块, 该模块中实现了 <code>HTTPServer</code> —— 一个单线程 HTTP 服务器，其实现是基于 <code>tornado.tcpserver</code> 模块的 <code>TCPServer</code>，<code>TCPServer</code> 是一个非阻塞单线程的 TCP 服务器，它负责处理 TCP 协议部分的内容，并预留接口（<code>handle_stream</code> 抽象方法）以便针对相应的应用层协议编写服务器。所以在分析 tornado HTTP 服务器实现之前，我们先来看看 <code>tornado.tcpserver.TCPServer</code> 的实现。</p>
<h3 id="TCPServer"><a href="#TCPServer" class="headerlink" title="TCPServer"></a>TCPServer</h3><p><code>tornado.tcpserver</code> 模块中只定义了一个 <code>TCPServer</code> 类，由于其实现不涉及到具体的应用层协议（例如Http协议），加上有 <code>IOLoop</code> 和 <code>IOStream</code> 的支持，其实现比较简单。</p>
<p><code>TCPServer</code> 是一个非阻塞的单线程 TCP Server，它提供了一个抽象接口方法 <code>handle_stream</code> 供具体的子类去实现，同时支持多进程的运行方式。按照源码注释，通过调用不同的方法我们有 3 中方式使用一个  TCP Server。</p>
<h4 id="三种使用模式"><a href="#三种使用模式" class="headerlink" title="三种使用模式"></a>三种使用模式</h4><h5 id="使用-listen-的单进程模式"><a href="#使用-listen-的单进程模式" class="headerlink" title="使用 listen 的单进程模式"></a>使用 listen 的单进程模式</h5><p>通过 <code>TCPServer</code> 的 <code>listen</code> 方法以单进程的方式运行服务器实例。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server = TCPServer()</span><br><span class="line">server.listen(<span class="number">8888</span>)</span><br><span class="line">IOLoop.instance().start()</span><br></pre></td></tr></table></figure>
<p><code>TCPServer</code> 提供的 <code>listen</code> 方法可以立即启动在指定的端口进行监听，并将相应的 socket 加入到 IOLoop 中。该方法可以多次调用，同时监听多个端口。由于需要 IOLoop 来驱动，所以必须确保相应的 IOLoop 实例已经启动（上述示例代码实例化 server 用的是默认 IOLoop 实例，所以通过 IOLoop.instance().start() 启动）。</p>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/10/14/tornado.tcpserver/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/12/tornado.util.Configurable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/10/12/tornado.util.Configurable/" class="post-title-link" itemprop="url">tornado.util.Configurable</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-10-12 15:25:01" itemprop="dateCreated datePublished" datetime="2015-10-12T15:25:01+08:00">2015-10-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tornado/" itemprop="url" rel="index"><span itemprop="name">tornado</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>tornado.util 模块中的 <code>Configurable</code> 是一个抽象类，该类通过继承机制为实现它的类型提供了一个简单工厂的功能。具体来说就是 <code>Configurable</code> 通过重写 <code>__new__</code> 方法来自定义类的创建，把类的构造函数变成了一个简单工厂，只要一个类继承了 <code>Configurable</code>，那么这个类在实例化时，构造函数就能像简单工厂一样选择这个类的一个子类来实例化。</p>
<p>一般在其他 OO 语言中我们都是通过提供静态工厂方法来实现该功能，有赖于 python 的实例化机制，这里通过重写 <code>__new__</code> 方法而把类的构造函数变成了简单工厂，使用时更直观一些，通过调用类型的构造函数就完成了选择实例化。</p>
<p><code>Configurable</code> 类有两个抽象方法：<code>configurable_base(cls)</code> 和 <code>configurable_default(cls)</code>，前者通常返回直接继承自 <code>Configurable</code> 的基类类型，后者返回实例化时默认使用的子类型。</p>
<p>目前在 tornado 中直接继承自 <code>Configurable</code> 的基类类型是 <code>AsyncHttpClient</code>, <code>IOLoop</code> 和 <code>Resolve</code>。也就是说我们可以通过 <code>AsyncHTTPClient()</code>, <code>IOLoop()</code>，<code>Resolver()</code> 直接完成从这些基类类型的子类型中选择一个配置好的类型来实例化。</p>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/10/12/tornado.util.Configurable/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/28/two_algorithms_for_drop_probability/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/09/28/two_algorithms_for_drop_probability/" class="post-title-link" itemprop="url">计算掉落概率</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-09-28 18:00:21" itemprop="dateCreated datePublished" datetime="2015-09-28T18:00:21+08:00">2015-09-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程基础/" itemprop="url" rel="index"><span itemprop="name">编程基础</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="计算掉落概率"><a href="#计算掉落概率" class="headerlink" title="计算掉落概率"></a>计算掉落概率</h4><p>在游戏中经常遇到按一定的掉落概率来随机掉落指定物品的情况，例如按照：钻石10%，金币20%，银币50%，饰品10%，装备10% 来计算掉落物品的类型。</p>
<p>通常的做法是将物品掉落概率（或者权重）变成一个离散的列表，随后产生一个随机数，再在列表中找到第一个大于该随机数的数，这个数对应的下标也就是对应的物品类型。</p>
<p>对应前面的例子，第一步会构建一个列表 [0.1, 0.3, 0.8, 0.9, 1.0] ；第二步生成一个随机数 0.56（假设）；第三步在列表中查找到第一个大于 0.56 的数是 0.8，下标为 2，此时掉落物品应该为银币。</p>
<p>这种算法比较直观，理解和实现起来也比较容易。很多时候甚至都不需要预先构建列表，而是每次累加概率直到找打大于随机数的那个数的下标。但是运用这个算法的时候，第三步我们往往使用的是顺序查找，这在掉落类型较多的时候确实不怎么好。当然大多数情况类型的种类并不是一个很大的数，所以其实也没有影响。（后面实现时候采用二分查找）</p>
<p>在上周的技术交流会时，同事提到了一个掉落概率算法 Alias Method，这个算法比较有意思，实现的很巧妙。算法的论文在这里：<a href="http://www.keithschwarz.com/darts-dice-coins/" target="_blank" rel="noopener">《Darts, Dice, and Coins: Sampling from a Discrete Distribution》</a></p>
<p>(<strong>以下引用自 <a href="http://www.cnblogs.com/younggun/p/3249772.html" target="_blank" rel="noopener">《抽奖概率-三种算法》</a></strong>)<br>Alias Method 算法大概是这么做的：把 N 种可能性拼装成一个方形（整体），分成 N 列，每列高度为 1 且最多 2 种可能性。可能性抽象为某种颜色，即每列最多有 2 种颜色，且第 n 列中必有第 n 种可能性，这里将第 n 种可能性称为原色。 想象抛出一个硬币，会落在其中一列，并且是落在列上的一种颜色。这样就得到两个数组：一个记录落在原色的概率是多少，记为 Prob 数组，另一个记录列上非原色的颜色名称，记为 Alias 数组，若该列只有原色则记为 null。</p>
<p>为了直接用网上的图片，我把前面例子的掉落概率依次改为 1/4, 1/5, 1/10, 1/20, 2/5。</p>
<img src="/2015/09/28/two_algorithms_for_drop_probability/alias.jpg">
<p>由上图方形可得到两个数组： Prob: [3/4, 1/4, 1/2, 1/4, 1] Alias: [4, 4, 0, 1, null] (记录非原色的下标)。之后就根据 Prob 和 Alias 获取其中一个物品，随机产生一列 C，再随机产生一个数 R，通过与Prob[C] 比较，R 较大则返回 C，反之返回 Alias[C]。</p>
<h4 id="Alias-Method-算法"><a href="#Alias-Method-算法" class="headerlink" title="Alias Method 算法"></a>Alias Method 算法</h4><p>算法论文中已经有了一个 <a href="http://www.keithschwarz.com/interesting/code/?dir=alias-method" target="_blank" rel="noopener">java 的版本</a>，这里我就按照作者 java 实现 “翻译” 了 python 和 C# 版本。<br>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/09/28/two_algorithms_for_drop_probability/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/27/tornado.iostream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/09/27/tornado.iostream/" class="post-title-link" itemprop="url">tornado.iostream 模块解析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-09-27 13:25:01" itemprop="dateCreated datePublished" datetime="2015-09-27T13:25:01+08:00">2015-09-27</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tornado/" itemprop="url" rel="index"><span itemprop="name">tornado</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="从-Files-Sockets-到-Stream"><a href="#从-Files-Sockets-到-Stream" class="headerlink" title="从 Files/Sockets 到 Stream"></a>从 Files/Sockets 到 Stream</h3><p><code>tornado.iostream</code> 模块为 Tornado 提供了一系列读写非阻塞 files/sockets 的工具类。该模块主要包括以下 4 个主要的工具类：</p>
<ul>
<li><code>BaseIOStream</code>: 基础流读写接口，作为特定流的父类；</li>
<li><code>IOStream</code>: 针对非阻塞 sockets 的流实现；</li>
<li><code>SSLIOStream</code>: SSL-aware版本的 <code>IOStream</code> 实现；</li>
<li><code>PipeIOStream</code>: 针对管道(Pipe)的流实现；</li>
</ul>
<p><code>BaseIOStream</code> 作为基础流读写接口，实现了大部分的功能封装。后面的源代码分析中，主要就是基于该类并结合其非阻塞 socket 版本的 <code>IOStream</code> 来讨论。</p>
<p>查看该模块的时候，我们会发现两个模块内函数 <code>_double_prefix(deque)</code> 与 <code>_merge_prefix(deque, size)</code>。这两个工具函数的实现都很简单，但是为流的读写提供通用的操作数据块(chunk)的功能：</p>
<ul>
<li><code>_double_prefix(deque)</code>: 该函数提供了将 buffer 的第 1 个 chunk 增大至少 1 倍的功能，该功能现在用在按条件在流的 buffer 中搜索匹配字符串时逐渐扩大搜索的数据块大小。</li>
<li><code>_merge_prefix(deque, size)</code>: 该函数提供了将 buffer 的第 1 个 chunk 调整到指定 size 大小。这在读写流时非常有用， <code>_double_prefix(deque)</code> 就是通过该函数来调整 chunk 大小的。在将流的 write_buffer 写入 fd 时，通过该函数适当调整第 1 个 chunk 的大小，我们就可以直接操作 buffer 的第 1 个 chunk 来达到操作整个 buffer 的目的，简化了实现的难度。详细可见 <code>BaseStream._handle_writ</code> 函数实现代码。</li>
</ul>
<h3 id="IOStream"><a href="#IOStream" class="headerlink" title="IOStream"></a>IOStream</h3><h4 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h4><p>在源码的开始部分，作者写了一大段介绍 recv/send 与 read/write 函数的区别，以及各平台的操作非阻塞 I/O 时返回的错误码。recv/send 与 read/write 函数的区别大体上就是说，前者是特化的函数，提供了一些额外的选项来控制 fd 的读写操作，针对具体的 fd 实例你可以设置选项忽略 SIGPIPE 信号或者让 socket 发送带外数据等等， 后者只是提供了通用的 fd 读写操作。对于操作非阻塞 fd 返回的错误码，如下模块的静态变量对应的注释所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非阻塞操作时，缓冲区满（无法写）时或者缓冲区空（读不到数据）时返回 EAGAIN， BSD 下使用 EWOULDBLOCK， Windows下使用 WSAEWOULDBLOCK</span></span><br><span class="line">_ERRNO_WOULDBLOCK = (errno.EWOULDBLOCK, errno.EAGAIN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For windows</span></span><br><span class="line"><span class="keyword">if</span> hasattr(errno, <span class="string">"WSAEWOULDBLOCK"</span>):</span><br><span class="line">    _ERRNO_WOULDBLOCK += (errno.WSAEWOULDBLOCK,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># These errnos indicate that a connection has been abruptly terminated.</span></span><br><span class="line"><span class="comment"># They should be caught and handled less noisily than other errors.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># `ECONNRESET`: 该异常一般发生在连接的一端（A）进程较另一端（B)提前终止时。A 进程终止时会向 B 发送 FIN 后进入</span></span><br><span class="line"><span class="comment"># FIN_WAIT1 状态，B 回应 ACK，A 收到 FIN 的 ACK 进入 FIN_WAIT2 状态。B 收到 FIN 时，会向应用程序交付 EOF，</span></span><br><span class="line"><span class="comment"># 进入 CLOSE_WAIT 状态。若此时 B 进程没有正常处理 FIN（例如被阻塞）而再次向处于 FIN_WAIT2 的 A 发送数据，将会</span></span><br><span class="line"><span class="comment"># 收到 RST，引发该错误。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># `ECONNABORTED`: 软件引起的连接中止，当服务端和客户端完成三次握手后，服务端正在等待服务进程调用 accept 时候却收到客户端</span></span><br><span class="line"><span class="comment"># 发来一个 RST 分节，引发该错误。POSIX 规定此时的 errno 值必须 ECONNABORTED。源自 Berkeley 的实现完全在内核中处理中</span></span><br><span class="line"><span class="comment"># 止的连接，服务进程将永远不知道该中止的发生。服务器进程一般可以忽略该错误，直接再次调用 accept。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># `EPIPE`: 错误被描述为 "broken pipe" ，即 "管道破裂"，这种情况一般发生在客户进程不理会（或未及时处理）socket 错误，</span></span><br><span class="line"><span class="comment"># 而继续向 socket 写入更多数据时，内核将向客户进程发送 SIGPIPE 信号，该信号默认会使进程终止（此时该前台进程未进行 core dump）。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># `ETIMEDOUT`: 连接超时， 这种错误一般发生在服务器端崩溃而不响应客户端 ACK 时，客户端最终放弃尝试连接时引发该错误。</span></span><br><span class="line">_ERRNO_CONNRESET = (errno.ECONNRESET, errno.ECONNABORTED, errno.EPIPE,</span><br><span class="line">                    errno.ETIMEDOUT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For windows</span></span><br><span class="line"><span class="keyword">if</span> hasattr(errno, <span class="string">"WSAECONNRESET"</span>):</span><br><span class="line">    _ERRNO_CONNRESET += (errno.WSAECONNRESET, errno.WSAECONNABORTED, errno.WSAETIMEDOUT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># More non-portable errnos:</span></span><br><span class="line"><span class="comment"># 在以非阻塞方式 connect() 时，返回的结果如果是 -1 ，并且错误号为 EINPROGRESS ，那么表示</span></span><br><span class="line"><span class="comment"># 连接还在进行并处理中(IN PROGRESS)，而不是真的发生了错误。</span></span><br><span class="line">_ERRNO_INPROGRESS = (errno.EINPROGRESS,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For windows</span></span><br><span class="line"><span class="keyword">if</span> hasattr(errno, <span class="string">"WSAEINPROGRESS"</span>):</span><br><span class="line">    _ERRNO_INPROGRESS += (errno.WSAEINPROGRESS,)</span><br></pre></td></tr></table></figure></p>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/09/27/tornado.iostream/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/05/true_complemental_ones-complement_code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/08/05/true_complemental_ones-complement_code/" class="post-title-link" itemprop="url">关于机器数的一些知识</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-08-05 14:14:21" itemprop="dateCreated datePublished" datetime="2015-08-05T14:14:21+08:00">2015-08-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程基础/" itemprop="url" rel="index"><span itemprop="name">编程基础</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><h5 id="机器数与真值"><a href="#机器数与真值" class="headerlink" title="机器数与真值"></a>机器数与真值</h5><p><strong>机器数</strong>（computer number）是将符号”数字化”的数，是数字在计算机中的二进制表示形式。机器数有2个特点：一是符号数字化，在计算机用一个数的最高位存放符号, 正数为0, 负数为1；二是其数的大小受机器字长的限制。比如在字长 8bit 的计算机中，+8 机器数就是 00001000，而 -8 的机器数则是 10001000。</p>
<p>不带符号的数是数的绝对值，在绝对值前加上表示正负的符号就成了符号数。直接用正号 “+” 和负号 “-” 来表示其正负的二进制数叫做符号数的<strong>真值</strong>。比如， 01101 和 11101 是两个机器数，而它们的真值分别为 +1101 和 -1101。</p>
<p><em>根据小数点位置固定与否，机器数又可以分为定点数和浮点数。 通常，使用定点数表示整数，而用浮点数表示实数。后面我们讨论的是定点数，即有符号整数。</em></p>
<h5 id="有符号整数的表示：原码、反码、补码"><a href="#有符号整数的表示：原码、反码、补码" class="headerlink" title="有符号整数的表示：原码、反码、补码"></a>有符号整数的表示：原码、反码、补码</h5><p><strong>注：只有有符号整数才存在不同的编码方式，无符号数没有原码、反码和补码一说。</strong></p>
<p>下面以字长 8bit 的机器数来举例。</p>
<h6 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h6><p>将真值中的 “+” 、“-” 分别用 1、0 代替就叫做数的原码形式，简称原码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1]原 = 0000 0001</span><br><span class="line">[-1]原 = 1000 0001</span><br></pre></td></tr></table></figure>
<h6 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h6><p>对正数来说，其反码和原码的相同。负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反</span><br><span class="line">[-1] = [10000001]原 = [11111110]反</span><br></pre></td></tr></table></figure>
<h6 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h6><p>对正数来说，其反码和原码的相同。负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后加1(也就是反码末位加 1)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-1] = [10000001]原 = [11111110]反 = [11111111]补</span><br></pre></td></tr></table></figure>
<p>综上所述，对于正整数而言，原码、反码、补码都一样，只有负整数原码、反码、补码表示不同。</p>
<h4 id="计算机中有符号整数的存储"><a href="#计算机中有符号整数的存储" class="headerlink" title="计算机中有符号整数的存储"></a>计算机中有符号整数的存储</h4><p>我们都知道, 在数学上减一个数等于加上这个数的相反数，所以有符号整数的加减法运算都可以视为加法运算。这没有什么问题，但是对于二进制存储的有符号整数，由于 “符号位” 参与运算便会有一些问题：</p>
<ol>
<li>若使用原码计算，涉及到负整数时就必须对符号位做特殊处理，并且还有 +0 和 -0 的问题；</li>
<li>若使用反码计算，符号位不需要特殊处理，但由于反码与原码的取值范围相同，所以也有 +0 和 -0 的问题；</li>
<li>使用补码则没有上述问题，但是补码的取值范围与原码不同，补码表示的最小值没有对应的原码。</li>
</ol>
<p><strong>注：使用原码和反码存储数都会存在一个 +0 与 -0 的问题，比如 8bit 字长的有符号整数，[0000 0000]原 和 [1000 0000]原 都表示0，[0000 0000]反和[1111 1111]反 都表示0，虽然能够理解，但这实际上没有什么意义。用补码表示时，[0000 0000]补 表示 +0，没有 -0；[1111 1111]补 表示 -1， [1000 0000]补 表示 -128，可以多保存一个最小值，所以 32 位 int 类型, 可以表示范围是: [-2^31, 2^31-1]，用原码或者补码都只能表示 [-2^31 + 1, 2^31-1]。</strong></p>
<p>在计算机中，加减法是基础运算，需要设计的足够简单。对于有符号整数，若让计算机执行加减法时还要去识别 “符号位” ，那么光基础电路至少就得设计两套，显然是复杂了。加上数字电路实现加法电路比减法电路要简单（不要问为什么，我已经还给大学老师了），所以在现代计算机中有符号整数是采用补码存储的（据说历史上曾经生产过使用反码存储的计算机）。<br>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/08/05/true_complemental_ones-complement_code/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/03/nat-napt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/08/03/nat-napt/" class="post-title-link" itemprop="url">NAT 与 NAPT</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-08-03 18:00:00" itemprop="dateCreated datePublished" datetime="2015-08-03T18:00:00+08:00">2015-08-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/computer-network/" itemprop="url" rel="index"><span itemprop="name">computer network</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>在 IP 分组通过路由器或防火墙时重写源 IP 地址或/和目的 IP 地址，网络地址转换 NAT（Network Address Translation）技术提供了一种完全将私有网和公共网隔离的技术。它允许用 1个或多个 IP 地址来实现 1 个私有网中的所有主机和公共网中主机的 IP 通信。</p>
<h4 id="NAT-的类型"><a href="#NAT-的类型" class="headerlink" title="NAT 的类型"></a>NAT 的类型</h4><p>NAT 可以分为基础 NAT 和 NAPT(APT) 两大类。</p>
<h5 id="基础-NAT"><a href="#基础-NAT" class="headerlink" title="基础 NAT"></a>基础 NAT</h5><p>基础 NAT 一般用在当 NAT 拥有很多公网 IP 地址的时候，它将公网 IP 地址与私有网内部主机进行绑定，当私有网主机和公共网主机通信的 IP 包经过 NAT 网关时，将 IP 包中的源 IP（发送时）或目的 IP（接收时）在私有 IP 地址和 NAT 的公网 IP 地址之间进行转换。</p>
<img src="/2015/08/03/nat-napt/nat.gif">
<p><strong>注：图片来自于网络。基础 NAT 虽然只对 IP 地址进行转换，但是通过 NAT 网关可以对外部数据进行拦截，提供防火墙的功能，这与直接为主机设置公网 IP 地址还是不一样。</strong></p>
<h5 id="NAPT-PAT"><a href="#NAPT-PAT" class="headerlink" title="NAPT(PAT)"></a>NAPT(PAT)</h5><p>基础 NAT 中 1 台私有网内部主机要求有一个公网 IP 地址与之对应，这样就导致私有网内部主机数量受到可用公网 IP 数量的限制。显而易见，大多数情况下我们的主机数量远远多于可用的公网 IP 地址数。为了解决这个问题，NAT 进一步扩展为在进行 IP 地址转换的同时也进行 Port (端口)转换，这就是网络地址端口转 NAPT（Network Address Port Translation/Port Address Translation，所以也称为 APT）。NAPT 使得多台私有网主机可以同时利用 1 个公网 IP 地址与公网进行通信。</p>
<img src="/2015/08/03/nat-napt/napt.gif">
<p><strong>注：图片来自于网络。</strong></p>
<p>当一个私有网主机通过 NAT 打开一个 “外出” 的 TCP 或 UDP 会话时，NAPT 分配给这个会话一个公网 IP 地址和端口，用来接收公网的响应的数据包，并经过转换通知私有网的主机。这样 NAPT 就在[私有网 IP 地址:私有端口] 和[公网 IP 地址:公网端口]之间建立了一个端口绑定。<br>
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/08/03/nat-napt/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/31/tornado.platform.posix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="格拉德.尼古拉斯.D.扯淡">
      <meta itemprop="description" content="疏影横斜水清浅，暗香浮动月黄昏。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书影">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2015/07/31/tornado.platform.posix/" class="post-title-link" itemprop="url">tornado.platform.posix 模块解析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2015-07-31 20:04:01" itemprop="dateCreated datePublished" datetime="2015-07-31T20:04:01+08:00">2015-07-31</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-22 23:53:03" itemprop="dateModified" datetime="2019-10-22T23:53:03+08:00">2019-10-22</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tornado/" itemprop="url" rel="index"><span itemprop="name">tornado</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="写在开始之前"><a href="#写在开始之前" class="headerlink" title="写在开始之前"></a>写在开始之前</h4><p>tornado.platform.posix 模块提供了 POSIX 平台下需要用到的一些功能，内容比较少，但是由于之前的工作主要是开发 windows 应用程序，对于这部分不熟悉。虽然这个模块目前提供的功能很少，但是涉及的操作系统底层知识还是值得记录下来。</p>
<p>在开始阅读源码之前，先来看看 UNIX I/O 的文件描述符相关知识。</p>
<h5 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h5><p><a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6" target="_blank" rel="noopener">文件描述符</a>（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念,基于文件描述符的I/O操作兼容 POSIX 标准(在 UNIX 中，一切 I/O 相关的实体都被抽象成了文件。Linux 的设计思想便是把一切设备都视作文件，文件描述符为在该系列平台上进行设备相关的编程实际上提供了一个统一的方法。)。</p>
<p><strong>注：在非 UNIX/Linux 操作系统上，如 Windows 下的文件描述符和信号量、互斥锁等内核对象一样都记作 HANDLE。</strong></p>
<p>文件描述符相当于一个逻辑句柄，在形式上是一个非负整数，open 、close 等 I/O 相关函数就是将文件或物理设备与该逻辑句柄相关联在一起。这个数字实际上是文件描述符表的索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。在 UNIX/Linux 下有 3 个概念与进程打开的文件描述符有关：</p>
<ul>
<li><p><strong>文件描述符表</strong>，每个进程在 PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。用户程序不能直接访问内核中的文件描述符表,而只能使用文件描述符表的索引。该表位于用户区。</p>
</li>
<li><p><strong>系统文件表</strong>，位于内核区，为系统中所有的进程共享。对每个 open 的文件, 它都包含一个条目与之对应。每个系统文件表的条目都包含文件偏移量、文件状态标识（访问模式，读、写或者读-写）以及指向它的文件描述符表的条目计数。</p>
</li>
<li><p><strong>内存索引节点表</strong>，位于内核区，对系统中的每个 open 的文件，内存中索引节点表都包含一个条目。几个系统文件表条目可能对应于同一个内存索引节点表（不同进程打开同一个文件）。</p>
</li>
</ul>
<img src="/2015/07/31/tornado.platform.posix/fd_s.png">
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2015/07/31/tornado.platform.posix/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">格拉德.尼古拉斯.D.扯淡</p>
  <div class="site-description" itemprop="description">疏影横斜水清浅，暗香浮动月黄昏。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">147</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">格拉德.尼古拉斯.D.扯淡</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
