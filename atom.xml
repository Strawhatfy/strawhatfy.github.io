<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>书影</title>
  <icon>https://www.gravatar.com/avatar/ff3f47d90979d26e19524fc989f31375</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-22T15:53:03.335Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>格拉德.尼古拉斯.D.扯淡</name>
    <email>lyd.alexlee.public@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SSL 自签名证书</title>
    <link href="http://yoursite.com/2019/07/07/ssl.cert/"/>
    <id>http://yoursite.com/2019/07/07/ssl.cert/</id>
    <published>2019-07-07T03:25:01.000Z</published>
    <updated>2019-10-22T15:53:03.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSL-自签名证书"><a href="#SSL-自签名证书" class="headerlink" title="SSL 自签名证书"></a>SSL 自签名证书</h1><h2 id="X-509-格式标准"><a href="#X-509-格式标准" class="headerlink" title="X.509 格式标准"></a>X.509 格式标准</h2><p>X.509：这是一种公钥证书的格式格式标准（<br><a href="https://zh.wikipedia.org/wiki/X.509），详情参考" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/X.509），详情参考</a> <a href="https://tools.ietf.org/html/rfc5280" target="_blank" rel="noopener">RFC5280</a></p><h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><ul><li><p>PEM：Privacy Enhanced Mail<br>  文本格式，Apache 和 Unix-like 服务器偏向使用这种编码格式。查看 PEM 格式的证书（可以包含私钥）：<br>  <code>openssl x509 -in certificate.pem -text -noout</code></p><ul><li>DER： Distinguished Encoding Rules<br> 二进制格式， Java 和 Windows 服务器偏向使用这种编码格式。查看 DER 格式的证书（单纯的证书，不可包含私钥）:<br> <code>openssl x509 -in certificate.der -inform der -text -noout</code></li></ul></li></ul><p>PEM 转 DER：<br><code>openssl x509 -in cert.crt -outform der -out cert.der</code></p><p>DER 转 PEM:<br><code>openssl x509 -in cert.crt -inform der -outform pem -out cert.pem</code></p><p><strong>注：</strong> </p><ol><li>查看/转换密钥（公钥或者私钥）文件则使用 <code>openssl rsa</code>；</li><li>查看/转换的是 CSR 文件则使用 <code>openssl req</code>。</li></ol><h2 id="文件后缀名"><a href="#文件后缀名" class="headerlink" title="文件后缀名"></a>文件后缀名</h2><ul><li>crt，certificate 的缩写，Unix-like 证书文件的常见后缀名，通常是 PEM 编码。</li><li>cer，也是 certificate 的缩写，Windows 证书文件的常见后缀名，通常是 DER 编码。</li><li>key, 通常是公钥或者私钥文件的后缀名。</li><li>csr，Certificate Signing Request，证书签名申请文件后缀名。</li><li>pfx/p12，predecessor of PKCS#12，将证书和私钥存放在一个文件中，使用 DER 编码。 通常是 IIS 使用，Unix 系服务器通常证书和私钥是放在不同的文件中。</li><li>JKS，Java Key Storage，通常用在 tomcat 中，Java 提供 keytool 工具支持将 pfx/p12 转换成 JKS：<code>keytool -importkeystore -srckeystore test.pfx -srcstoretype PKCS12 -deststoretype JKS -destkeystore test.jks</code></li></ul><h3 id="PEM-pfx-p12"><a href="#PEM-pfx-p12" class="headerlink" title="PEM  pfx/p12"></a>PEM <--> pfx/p12</--></h3><p>Unix 系的 PEM 证书转 pfx/p12 格式证书：<br><code>openssl pkcs12 -export -in certificate.crt -inkey privateKey.key  [-certfile CACert.crt] -out certificate.pfx</code> </p><p> 反过来：<br> <code>openssl pkcs12 -in certificate.pfx -nodes -out certificate.pem</code></p><p>因为 <code>certificate.pem</code>  是一个同时包含证书和私钥的 PEM 证书，进一步可以通过下面命令分离成单独 PEM 证书和私钥 2 个文件：<br> <code>openssl rsa -in certificate.pem -out privateKey.key</code><br><code>openssl x509 -in server.pem -out certificate.crt</code></p><h2 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h2><h3 id="自签名证书（-x-509-v1）"><a href="#自签名证书（-x-509-v1）" class="headerlink" title="自签名证书（ x.509 v1）"></a>自签名证书（ x.509 v1）</h3><p>自己签署的证书，没有 CA 可以证明其有效性，无法被吊销。由于大多数移动平台不支持使用自签名证书，因此不推荐使用。用下面方法可以生成 x.509 v1 版本的自签名证书。</p><ol><li><p>生成 RSA 私钥（不加密的私钥）：</p><p> <code>openssl genrsa -out server.key 1024</code>  </p><p> 注：通过 <code>man genrsa</code>  查看使用手册。如果证书要使用在 Nginx 上，为避免每次 nginx reload ssl 都要手动输入口令，这里生成的私钥不加密。</p></li><li><p>创建证书签名申请（CSR， Certificate Signning Request）:</p><p> <code>openssl req -new -key server.key -out server.csr</code></p></li><li><p>使用前面生成的私钥对 CSR 进行签名生成自签名证书:</p><p> <code>openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt</code></p></li></ol><a id="more"></a><h3 id="自签名（私有）-CA-证书"><a href="#自签名（私有）-CA-证书" class="headerlink" title="自签名（私有） CA 证书"></a>自签名（私有） CA 证书</h3><p>由自己进行签署的 CA。它既是证书也是 CA。因为它是树中的最顶层证书，因此也是根 CA。不推荐在外部面向因特网的服务器上将私有 CA 签署的证书用于生产，因为可能存在安全隐患。但是，在开发和测试环境中会优先选择此类证书，因为其成本较低。它们也适用于内部（内部网）服务器，因为这些证书可以快速和轻松地部署。</p><p>可以使用 <code>openssl ca</code>  与 <code>openssl x509</code>   都可以自签名 CA 证书和使用自签名 CA 证书签署其他证书。 <code>openssl ca</code>  可以看着是 <code>openssl x509</code>  封装（注：不知道实现上实际是不是），通过配置文件设置默认参数（遵循一定规则和约束），<code>openssl x509</code>  签署证书时需要自己指定所有参数。另外，<code>openssl ca</code>  的 <code>index.txt</code>  还记录着已经签署的证书信息。</p><h4 id="使用-openssl-ca"><a href="#使用-openssl-ca" class="headerlink" title="使用 openssl ca"></a>使用 <code>openssl ca</code></h4><p>openssl ca 的默认配置文件是 <code>/etc/pki/tls/openssl.cnf</code> （openssl-1.0.2k-16.el7_6.1.x86_64，具体路径可能不同），下图是默认工作目录 <code>/etc/pki/CA</code>  的结构和组成：</p><img src="/2019/07/07/ssl.cert/ca_dir_structure.png"><h5 id="初始化工作目录-etc-pki-CA"><a href="#初始化工作目录-etc-pki-CA" class="headerlink" title="初始化工作目录  /etc/pki/CA"></a>初始化工作目录  <code>/etc/pki/CA</code></h5><p>使用 <code>openssl ca</code> 前需要初始化一些文件：</p><p><code>openssl rand -out /etc/pki/CA/private/.rand 1000 &amp;&amp; openssl rand -hex 8 | awk &#39;{print toupper($0)}&#39; &gt; /etc/pki/CA/serial &amp;&amp; touch /etc/pki/CA/index.txt</code></p><p>各个文件含义参考　<code>/etc/pki/tls/openssl.cnf</code> 　文件。 <code>.rand</code>  提供随机数种子，<code>serial</code>  提供证书序列号， <code>index.txt</code>  数据库索引文件，记录签署的所有证书。</p><h5 id="生成自签名-CA-证书（x-509-v3）"><a href="#生成自签名-CA-证书（x-509-v3）" class="headerlink" title="生成自签名 CA 证书（x.509 v3）"></a>生成自签名 CA 证书（x.509 v3）</h5><p> 以下使用的私钥及证书的文件（及后缀名）都是 <code>/etc/pki/tls/openssl.cnf</code>  定义的 <strong>默认值</strong> ，这样之后可以直接使用 <code>openssl ca</code>  签署证书而不用额外指定参数。</p><ol><li>生成 CA 私钥（加密）<br><code>openssl genrsa -aes256 -out /etc/pki/CA/private/cakey.pem 2048</code></li></ol><ol start="2"><li><p>生成自签名 CA 证书：使用 <code>openssl req -x509</code>、<code>openssl x509</code>  和 <code>openssl ca</code>  都可以『自签署』证书请求文件。</p><p> <code>openssl req -x509 -new -days 3650 -extensions v3_ca -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem</code></p><p> 或者</p><p> <code>openssl req -new -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/private/ca.csr</code></p><p> <code>openssl x509 -req -days 3650 -extfile /etc/pki/tls/openssl.cnf -extensions v3_ca   -in /etc/pki/CA/private/ca.csr -signkey  /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem</code></p><p> 或者（推荐 <code>openssl ca</code>）</p><p> <code>openssl req -new -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/private/ca.csr</code></p><p> <code>openssl ca -selfsign -in /etc/pki/CA/private/ca.csr -out /etc/pki/CA/cacert.pem &amp;&amp; rm -f /etc/pki/CA/private/ca.csr</code></p></li></ol><h5 id="使用自签名-CA-证书签署证书"><a href="#使用自签名-CA-证书签署证书" class="headerlink" title="使用自签名 CA 证书签署证书"></a>使用自签名 CA 证书签署证书</h5><ol><li><p>生成私钥（不加密）<br><code>openssl genrsa -out /etc/pki/CA/private/xb29.key 2048</code></p></li><li><p>生成证书签名请求<br><code>openssl req -new -key /etc/pki/CA/private/xb29.key -out /etc/pki/CA/private/xb29.csr</code></p></li><li><p>使用自签名 CA 证书签署证书<br><code>openssl ca -days 3650 -in /etc/pki/CA/private/xb29.csr -out /etc/pki/CA/newcerts/xb29.crt</code></p></li></ol><h4 id="使用-openssl-x509"><a href="#使用-openssl-x509" class="headerlink" title="使用 openssl x509"></a>使用 <code>openssl x509</code></h4><h5 id="生成自签名-CA-证书（x-509-v3）-1"><a href="#生成自签名-CA-证书（x-509-v3）-1" class="headerlink" title="生成自签名 CA 证书（x.509 v3）"></a>生成自签名 CA 证书（x.509 v3）</h5><p> 自签名 CA 证书生成方式如上一节描述，这里再 『描述』 一遍，主要是为了展示证书和私钥可以存放在任意路径，不需要像 <code>openssl ca</code>  一样遵循配置文件。</p><ol><li>生成 CA 私钥（加密）<br><code>openssl genrsa -aes256 -out ca.key 2048</code></li></ol><ol start="2"><li>生成自签名 CA 证书：<br><code>openssl req -new -x509 -days 3650 -extensions v3_ca -key ca.key -out ca.crt</code></li></ol><h5 id="使用自签名-CA-证书签署证书-1"><a href="#使用自签名-CA-证书签署证书-1" class="headerlink" title="使用自签名 CA 证书签署证书"></a>使用自签名 CA 证书签署证书</h5><ol><li><p>生成私钥（不加密）<br><code>openssl genrsa -out xb29.key 2048</code></p></li><li><p>生成证书签名请求<br><code>openssl req -new -key xb29.key -out xb29.csr</code></p></li><li><p>使用自签名 CA 证书签署证书<br><code>openssl x509 -req -days 3650 -extfile /etc/pki/tls/openssl.cnf -extensions v3_req -CA ca.crt -CAkey ca.key -CAcreateserial -in xb29.csr -out xb29.crt</code></p></li></ol><p>注：<code>-CAcreateserial</code>  参数自动在当前目录创建一个证书签发使用的序列号文件 <code>ca.srl</code>（如果不存在的话，文件名同 CA 证书名，后缀 <code>.srl</code> ） 。</p><ol start="4"><li><p>(可选) 有些应用可能不支持设置的单独的证书和私钥，这个时候需要将证书和私钥合并成一个文件。</p><p> <code>cat xb29.crt xb29.key &gt; xb29.pem</code></p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.ibm.com/support/knowledgecenter/zh/SSZH4A_6.2.0/com.ibm.worklight.installconfig.doc/admin/c_ssl_config.html" target="_blank" rel="noopener">通过使用不受信任的证书配置 SSL</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7115871.html" target="_blank" rel="noopener">openssl ca(签署和自建CA)</a></li><li><a href="https://my.oschina.net/itblog/blog/651434" target="_blank" rel="noopener">OpenSSL生成根证书CA及签发子证书</a></li><li><a href="https://zh.wikipedia.org/wiki/X.509" target="_blank" rel="noopener">Wiki X.509</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SSL-自签名证书&quot;&gt;&lt;a href=&quot;#SSL-自签名证书&quot; class=&quot;headerlink&quot; title=&quot;SSL 自签名证书&quot;&gt;&lt;/a&gt;SSL 自签名证书&lt;/h1&gt;&lt;h2 id=&quot;X-509-格式标准&quot;&gt;&lt;a href=&quot;#X-509-格式标准&quot; class=&quot;headerlink&quot; title=&quot;X.509 格式标准&quot;&gt;&lt;/a&gt;X.509 格式标准&lt;/h2&gt;&lt;p&gt;X.509：这是一种公钥证书的格式格式标准（&lt;br&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/X.509），详情参考&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/X.509），详情参考&lt;/a&gt; &lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC5280&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;编码格式&quot;&gt;&lt;a href=&quot;#编码格式&quot; class=&quot;headerlink&quot; title=&quot;编码格式&quot;&gt;&lt;/a&gt;编码格式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;PEM：Privacy Enhanced Mail&lt;br&gt;  文本格式，Apache 和 Unix-like 服务器偏向使用这种编码格式。查看 PEM 格式的证书（可以包含私钥）：&lt;br&gt;  &lt;code&gt;openssl x509 -in certificate.pem -text -noout&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DER： Distinguished Encoding Rules&lt;br&gt; 二进制格式， Java 和 Windows 服务器偏向使用这种编码格式。查看 DER 格式的证书（单纯的证书，不可包含私钥）:&lt;br&gt; &lt;code&gt;openssl x509 -in certificate.der -inform der -text -noout&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PEM 转 DER：&lt;br&gt;&lt;code&gt;openssl x509 -in cert.crt -outform der -out cert.der&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;DER 转 PEM:&lt;br&gt;&lt;code&gt;openssl x509 -in cert.crt -inform der -outform pem -out cert.pem&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看/转换密钥（公钥或者私钥）文件则使用 &lt;code&gt;openssl rsa&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;查看/转换的是 CSR 文件则使用 &lt;code&gt;openssl req&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;文件后缀名&quot;&gt;&lt;a href=&quot;#文件后缀名&quot; class=&quot;headerlink&quot; title=&quot;文件后缀名&quot;&gt;&lt;/a&gt;文件后缀名&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;crt，certificate 的缩写，Unix-like 证书文件的常见后缀名，通常是 PEM 编码。&lt;/li&gt;
&lt;li&gt;cer，也是 certificate 的缩写，Windows 证书文件的常见后缀名，通常是 DER 编码。&lt;/li&gt;
&lt;li&gt;key, 通常是公钥或者私钥文件的后缀名。&lt;/li&gt;
&lt;li&gt;csr，Certificate Signing Request，证书签名申请文件后缀名。&lt;/li&gt;
&lt;li&gt;pfx/p12，predecessor of PKCS#12，将证书和私钥存放在一个文件中，使用 DER 编码。 通常是 IIS 使用，Unix 系服务器通常证书和私钥是放在不同的文件中。&lt;/li&gt;
&lt;li&gt;JKS，Java Key Storage，通常用在 tomcat 中，Java 提供 keytool 工具支持将 pfx/p12 转换成 JKS：&lt;code&gt;keytool -importkeystore -srckeystore test.pfx -srcstoretype PKCS12 -deststoretype JKS -destkeystore test.jks&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;PEM-pfx-p12&quot;&gt;&lt;a href=&quot;#PEM-pfx-p12&quot; class=&quot;headerlink&quot; title=&quot;PEM  pfx/p12&quot;&gt;&lt;/a&gt;PEM &lt;--&gt; pfx/p12&lt;/--&gt;&lt;/h3&gt;&lt;p&gt;Unix 系的 PEM 证书转 pfx/p12 格式证书：&lt;br&gt;&lt;code&gt;openssl pkcs12 -export -in certificate.crt -inkey privateKey.key  [-certfile CACert.crt] -out certificate.pfx&lt;/code&gt; &lt;/p&gt;
&lt;p&gt; 反过来：&lt;br&gt; &lt;code&gt;openssl pkcs12 -in certificate.pfx -nodes -out certificate.pem&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;certificate.pem&lt;/code&gt;  是一个同时包含证书和私钥的 PEM 证书，进一步可以通过下面命令分离成单独 PEM 证书和私钥 2 个文件：&lt;br&gt; &lt;code&gt;openssl rsa -in certificate.pem -out privateKey.key&lt;/code&gt;&lt;br&gt;&lt;code&gt;openssl x509 -in server.pem -out certificate.crt&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;生成证书&quot;&gt;&lt;a href=&quot;#生成证书&quot; class=&quot;headerlink&quot; title=&quot;生成证书&quot;&gt;&lt;/a&gt;生成证书&lt;/h2&gt;&lt;h3 id=&quot;自签名证书（-x-509-v1）&quot;&gt;&lt;a href=&quot;#自签名证书（-x-509-v1）&quot; class=&quot;headerlink&quot; title=&quot;自签名证书（ x.509 v1）&quot;&gt;&lt;/a&gt;自签名证书（ x.509 v1）&lt;/h3&gt;&lt;p&gt;自己签署的证书，没有 CA 可以证明其有效性，无法被吊销。由于大多数移动平台不支持使用自签名证书，因此不推荐使用。用下面方法可以生成 x.509 v1 版本的自签名证书。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;生成 RSA 私钥（不加密的私钥）：&lt;/p&gt;
&lt;p&gt; &lt;code&gt;openssl genrsa -out server.key 1024&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt; 注：通过 &lt;code&gt;man genrsa&lt;/code&gt;  查看使用手册。如果证书要使用在 Nginx 上，为避免每次 nginx reload ssl 都要手动输入口令，这里生成的私钥不加密。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建证书签名申请（CSR， Certificate Signning Request）:&lt;/p&gt;
&lt;p&gt; &lt;code&gt;openssl req -new -key server.key -out server.csr&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用前面生成的私钥对 CSR 进行签名生成自签名证书:&lt;/p&gt;
&lt;p&gt; &lt;code&gt;openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="服务端基础" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="SSL" scheme="http://yoursite.com/tags/SSL/"/>
    
      <category term="X.509" scheme="http://yoursite.com/tags/X-509/"/>
    
      <category term="自签名" scheme="http://yoursite.com/tags/%E8%87%AA%E7%AD%BE%E5%90%8D/"/>
    
      <category term="CA 证书" scheme="http://yoursite.com/tags/CA-%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>KVM 磁盘缓存模式</title>
    <link href="http://yoursite.com/2019/05/22/kvm.disk.cache.modes/"/>
    <id>http://yoursite.com/2019/05/22/kvm.disk.cache.modes/</id>
    <published>2019-05-22T15:44:17.000Z</published>
    <updated>2019-10-22T15:53:03.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KVM-磁盘缓存模式"><a href="#KVM-磁盘缓存模式" class="headerlink" title="KVM 磁盘缓存模式"></a>KVM 磁盘缓存模式</h1><p>本笔记内容无原创，整理自如下资料：</p><ul><li><a href="https://johng.cn/linux-io-sync/" target="_blank" rel="noopener">Linux中如何保证数据安全落盘</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_tuning_and_optimization_guide/sect-virtualization_tuning_optimization_guide-blockio-caching" target="_blank" rel="noopener">RHEL sect-virtualization_tuning_optimization_guide-blockio-caching</a></li><li><a href="https://turlucode.com/qemu-disk-io-performance-comparison-native-or-threads-windows-10-version/#1528572626148-2b30f3e4-f00f" target="_blank" rel="noopener">GUIDES  5.3K<br>QEMU Disk IO performance comparison: Native or threads?</a></li><li><a href="https://www.cnblogs.com/tcicy/p/10193613.html" target="_blank" rel="noopener">KVM总结-KVM性能优化之磁盘IO优化</a></li></ul><h2 id="Cache-modes"><a href="#Cache-modes" class="headerlink" title="Cache modes"></a>Cache modes</h2><p>KVM 目前支持的磁盘缓存模式主要有 none，writethrough，writeback，directsync，unsafe 这 5 种。后面 2 种通常很少使用到。</p><h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><ul><li>I/O from the guest is not cached on the host, but may be kept in a writeback disk cache. Use this option for guests with large I/O requirements.（guest 使用 writeback， host 不使用 page cache，相当于 guest 直接访问主机磁盘。）</li></ul><p>这种模式下虚拟机磁盘镜像文件或者块设备会使用 O_DIRECT 语义， 则 host 的 page cache 被绕过， I/O 直接在 qemu-kvm 的用户空间 buffers 和 host 的存储设备间发生。因为实际存储设备可能在写数据放到写队列后就上报写完成，虚拟机上的存储控制器被告知有回写缓存（writeback cache）， 所以 guest 需要下发刷盘（flush）命令来保证数据一致（落盘）。相当于直接访问 host 磁盘，性能不错。</p><blockquote><blockquote><p>This mode causes qemu-kvm to interact with the disk image file or block device with O_DIRECT semantics, so the host page cache is bypassed and I/O happens directly between the qemu-kvm userspace buffers and the storage device. Because the actual storage device may report a write as completed when placed in its write queue only, the guest’s virtual storage adapter is informed that there is a writeback cache, so the guest would be expected to send down flush commands as needed to manage data integrity. Equivalent to direct access to your hosts’ disk,performance wise.</p></blockquote></blockquote><h3 id="writethrough"><a href="#writethrough" class="headerlink" title="writethrough"></a>writethrough</h3><ul><li>I/O from the guest is cached on the host but written through to the physical medium. （guest 使用 wirtethrough， host 使用 page cache。）</li></ul><p>这种模式下会为每次写操作执行 fdatasync（原文是 fsync 与后面 O_DSYNC 不太一致）， 是一种安全的缓存模式，不用担心丢失数据，但同时也比较慢。这种模式下虚拟机磁盘镜像文件或者块设备被设置成 O_DSYNC 语义， 必须等待所有写数据落盘以后才上报写完成。 host 的 page cache 工作在所谓的 writethrough 模式。guest 的存储控制器会被告知没有 writecache， 所以 guest 不必下发 flush 命令来保证数据一致。存储设备的行为好像是透过缓存（writethrough cache）。</p><blockquote><blockquote><p>Writethrough make a fsync for each write. So it’s the more secure cache mode, you can’t loose data. It’s also the slower. This mode causes qemu-kvm to interact with the disk image file or block device with O_DSYNC semantics, where writes are reported as completed only when the data has been committed to the storage device. The host page cache is used in what can be termed a writethrough caching mode. The guest’s virtual storage adapter is informed that there is no writeback cache, so the guest would not need to send down flush commands to manage data integrity. The storage behaves as if there is a writethrough cache.<br><a id="more"></a></p></blockquote></blockquote><h3 id="writeback"><a href="#writeback" class="headerlink" title="writeback"></a>writeback</h3><ul><li>I/O from the guest is cached on the host.（guest 使用 writeback， host 使用 page cache。）</li></ul><p>这种模式下虚拟机磁盘镜像文件或者块设备不用使用 O_DSYNC 与 O_DIRECT 语义。guest 写数据到达 host page cache 便上报写完成，由 host 的 page cache 管理机制来负责将数据落盘。另外，guest 的虚拟磁盘控制器被告知使用 wirteback 缓存，需要下发 flush 命令来保证数据一致性。类似待由 RAM 缓存的 RAID 控制器。</p><blockquote><blockquote><p>This mode causes qemu-kvm to interact with the disk image file or block device with neither O_DSYNC nor O_DIRECT semantics, so the host page cache is used and writes are reported to the guest as completed when placed in the host page cache, and the normal page cache management will handle commitment to the storage device. Additionally, the guest’s virtual storage adapter is informed of the writeback cache, so the guest would be expected to send down flush commands as needed to manage data integrity. Analogous to a raid controller with RAM cache.</p></blockquote></blockquote><h3 id="directsync"><a href="#directsync" class="headerlink" title="directsync"></a>directsync</h3><ul><li>Similar to writethrough, but I/O from the guest bypasses the host page cache.（guest 使用 writethrough， host 不使用 page cache）</li></ul><p>这种模式下虚拟机磁盘镜像文件或块设置同时使用 O_DSYNC 和 O_DIRECT 语义，绕过 host page cache，等数据落盘才上报写完成。与 writethrough 模式一样， directsync 模式不需要下发 flush 命令，对于不支持 writeback cache 的 guest 很有用（it is helpful to guests that do not send flushes when needed.）。这种模式是最后一种缓存与直接访问的组合语义，是缓存方式的补充。</p><blockquote><blockquote><p>This mode causes qemu-kvm to interact with the disk image file or block device with both O_DSYNC and O_DIRECT semantics, where writes are reported as completed only when the data has been committed to the storage device, and when it is also desirable to bypass the host page cache. Like cache=writethrough, it is helpful to guests that do not send flushes when needed. It was the last cache mode added, completing the possible combinations of caching and direct access semantics.</p></blockquote></blockquote><h3 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h3><ul><li>The host may cache all disk I/O, and sync requests from guest are ignored.</li></ul><p>这种模式与前面讨论的 writecache 模式非常相似。该模式的关键点是由 guest 下发的 flush 命令都会被忽略。 使用这种模式也就意味着接受 host 故障导致数据丢失的风险，以换取性能。这个模式可以在安装系统的时候使用，但是不应该在生成环境使用。</p><blockquote><blockquote><p>This mode is similar to the cache=writeback mode discussed above. The key aspect of this unsafe mode, is that all flush commands from the guests are ignored. Using this mode implies that the user has accepted the trade-off of performance over risk of data loss in the event of a host failure. Useful, for example, during guest install, but not for production workloads.</p></blockquote></blockquote><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><table><thead><tr><th>Mode</th><th>Host Page Cache</th><th>Disk Write Cache</th><th>Notes</th></tr></thead><tbody><tr><td>none</td><td>disable</td><td>enable</td><td>balances performance and safety (better writes)</td></tr><tr><td>writethrough</td><td>enabled</td><td>disable</td><td>balances performance and safety (better reads)</td></tr><tr><td>writeback</td><td>enabled</td><td>enable</td><td>fast, can loose data on power outage depending on hardware used</td></tr><tr><td>directsync</td><td>disable</td><td>disable</td><td>safest but slowest (relative to the others)</td></tr><tr><td>unsafe</td><td>enable</td><td>enable</td><td>doesn’t flush data, fastest and unsafest</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;KVM-磁盘缓存模式&quot;&gt;&lt;a href=&quot;#KVM-磁盘缓存模式&quot; class=&quot;headerlink&quot; title=&quot;KVM 磁盘缓存模式&quot;&gt;&lt;/a&gt;KVM 磁盘缓存模式&lt;/h1&gt;&lt;p&gt;本笔记内容无原创，整理自如下资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://johng.cn/linux-io-sync/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux中如何保证数据安全落盘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_tuning_and_optimization_guide/sect-virtualization_tuning_optimization_guide-blockio-caching&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RHEL sect-virtualization_tuning_optimization_guide-blockio-caching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://turlucode.com/qemu-disk-io-performance-comparison-native-or-threads-windows-10-version/#1528572626148-2b30f3e4-f00f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GUIDES  5.3K&lt;br&gt;QEMU Disk IO performance comparison: Native or threads?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/tcicy/p/10193613.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KVM总结-KVM性能优化之磁盘IO优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Cache-modes&quot;&gt;&lt;a href=&quot;#Cache-modes&quot; class=&quot;headerlink&quot; title=&quot;Cache modes&quot;&gt;&lt;/a&gt;Cache modes&lt;/h2&gt;&lt;p&gt;KVM 目前支持的磁盘缓存模式主要有 none，writethrough，writeback，directsync，unsafe 这 5 种。后面 2 种通常很少使用到。&lt;/p&gt;
&lt;h3 id=&quot;none&quot;&gt;&lt;a href=&quot;#none&quot; class=&quot;headerlink&quot; title=&quot;none&quot;&gt;&lt;/a&gt;none&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;I/O from the guest is not cached on the host, but may be kept in a writeback disk cache. Use this option for guests with large I/O requirements.（guest 使用 writeback， host 不使用 page cache，相当于 guest 直接访问主机磁盘。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种模式下虚拟机磁盘镜像文件或者块设备会使用 O_DIRECT 语义， 则 host 的 page cache 被绕过， I/O 直接在 qemu-kvm 的用户空间 buffers 和 host 的存储设备间发生。因为实际存储设备可能在写数据放到写队列后就上报写完成，虚拟机上的存储控制器被告知有回写缓存（writeback cache）， 所以 guest 需要下发刷盘（flush）命令来保证数据一致（落盘）。相当于直接访问 host 磁盘，性能不错。&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;This mode causes qemu-kvm to interact with the disk image file or block device with O_DIRECT semantics, so the host page cache is bypassed and I/O happens directly between the qemu-kvm userspace buffers and the storage device. Because the actual storage device may report a write as completed when placed in its write queue only, the guest’s virtual storage adapter is informed that there is a writeback cache, so the guest would be expected to send down flush commands as needed to manage data integrity. Equivalent to direct access to your hosts’ disk,performance wise.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;writethrough&quot;&gt;&lt;a href=&quot;#writethrough&quot; class=&quot;headerlink&quot; title=&quot;writethrough&quot;&gt;&lt;/a&gt;writethrough&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;I/O from the guest is cached on the host but written through to the physical medium. （guest 使用 wirtethrough， host 使用 page cache。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种模式下会为每次写操作执行 fdatasync（原文是 fsync 与后面 O_DSYNC 不太一致）， 是一种安全的缓存模式，不用担心丢失数据，但同时也比较慢。这种模式下虚拟机磁盘镜像文件或者块设备被设置成 O_DSYNC 语义， 必须等待所有写数据落盘以后才上报写完成。 host 的 page cache 工作在所谓的 writethrough 模式。guest 的存储控制器会被告知没有 writecache， 所以 guest 不必下发 flush 命令来保证数据一致。存储设备的行为好像是透过缓存（writethrough cache）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Writethrough make a fsync for each write. So it’s the more secure cache mode, you can’t loose data. It’s also the slower. This mode causes qemu-kvm to interact with the disk image file or block device with O_DSYNC semantics, where writes are reported as completed only when the data has been committed to the storage device. The host page cache is used in what can be termed a writethrough caching mode. The guest’s virtual storage adapter is informed that there is no writeback cache, so the guest would not need to send down flush commands to manage data integrity. The storage behaves as if there is a writethrough cache.&lt;br&gt;
    
    </summary>
    
      <category term="virtualization" scheme="http://yoursite.com/categories/virtualization/"/>
    
    
      <category term="KVM" scheme="http://yoursite.com/tags/KVM/"/>
    
      <category term="Cache Mode" scheme="http://yoursite.com/tags/Cache-Mode/"/>
    
      <category term="noe" scheme="http://yoursite.com/tags/noe/"/>
    
      <category term="writethrough" scheme="http://yoursite.com/tags/writethrough/"/>
    
      <category term="writeback" scheme="http://yoursite.com/tags/writeback/"/>
    
      <category term="directsync" scheme="http://yoursite.com/tags/directsync/"/>
    
      <category term="unsafe" scheme="http://yoursite.com/tags/unsafe/"/>
    
  </entry>
  
  <entry>
    <title>v2ray + Nginx + TLS(CentOS 7)</title>
    <link href="http://yoursite.com/2019/05/20/v2ray.tls.nginx/"/>
    <id>http://yoursite.com/2019/05/20/v2ray.tls.nginx/</id>
    <published>2019-05-20T15:11:01.000Z</published>
    <updated>2019-10-22T15:53:03.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="v2ray-Nginx-TLS"><a href="#v2ray-Nginx-TLS" class="headerlink" title="v2ray + Nginx + TLS"></a>v2ray + Nginx + TLS</h1><h2 id="安装-v2ray"><a href="#安装-v2ray" class="headerlink" title="安装 v2ray"></a>安装 v2ray</h2><ol><li>安装 v2ray 最新版本：</li></ol><p><code>bash &lt;(curl -L -s https://install.direct/go.sh)</code></p><ol start="2"><li>编辑 v2ray 配置文件 <code>/etc/v2ray/config.json</code>，这个配置文件简单启用 2 个传输通道，分别是 port 8081 上的 websocket 和 port 8082 上的 mkcp，其他更多配置请参考官方文档：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"log"</span>: &#123;</span><br><span class="line">        <span class="attr">"access"</span>: <span class="string">"/var/log/v2ray/access.log"</span>,</span><br><span class="line">        <span class="attr">"error"</span>: <span class="string">"/var/log/v2ray/error.log"</span>,</span><br><span class="line">        <span class="attr">"loglevel"</span>: <span class="string">"warning"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"dns"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"stats"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"inbounds"</span>: [&#123;</span><br><span class="line">            <span class="attr">"tag"</span>: <span class="string">"in-0"</span>,</span><br><span class="line">            <span class="attr">"settings"</span>: &#123;</span><br><span class="line">                <span class="attr">"clients"</span>: [&#123;</span><br><span class="line">                        <span class="attr">"id"</span>: <span class="string">"xxx"</span>,</span><br><span class="line">                        <span class="attr">"alterId"</span>: <span class="number">64</span>,</span><br><span class="line">                        <span class="attr">"level"</span>: <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">                <span class="attr">"network"</span>: <span class="string">"ws"</span>,</span><br><span class="line">                <span class="attr">"wsSettings"</span>: &#123;</span><br><span class="line">                    <span class="attr">"path"</span>: <span class="string">"/ray"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"security"</span>: <span class="string">"none"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"listen"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">8081</span>,</span><br><span class="line">            <span class="attr">"protocol"</span>: <span class="string">"vmess"</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">"tag"</span>: <span class="string">"in-1"</span>,</span><br><span class="line">            <span class="attr">"settings"</span>: &#123;</span><br><span class="line">                <span class="attr">"clients"</span>: [&#123;</span><br><span class="line">                        <span class="attr">"id"</span>: <span class="string">"xxx"</span>,</span><br><span class="line">                        <span class="attr">"alterId"</span>: <span class="number">64</span>,</span><br><span class="line">                        <span class="attr">"level"</span>: <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">                <span class="attr">"network"</span>: <span class="string">"kcp"</span>,</span><br><span class="line">                <span class="attr">"kcpSettings"</span>: &#123;</span><br><span class="line">                    <span class="attr">"header"</span>: &#123;</span><br><span class="line">                        <span class="attr">"type"</span>: <span class="string">"dtls"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"security"</span>: <span class="string">"none"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">8082</span>,</span><br><span class="line">            <span class="attr">"protocol"</span>: <span class="string">"vmess"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"outbounds"</span>: [&#123;</span><br><span class="line">            <span class="attr">"tag"</span>: <span class="string">"direct"</span>,</span><br><span class="line">            <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">"protocol"</span>: <span class="string">"freedom"</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">"tag"</span>: <span class="string">"blocked"</span>,</span><br><span class="line">            <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">"protocol"</span>: <span class="string">"blackhole"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"routing"</span>: &#123;</span><br><span class="line">        <span class="attr">"rules"</span>: [&#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">                <span class="attr">"ip"</span>: [</span><br><span class="line">                    <span class="string">"geoip:private"</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"outboundTag"</span>: <span class="string">"blocked"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"domainStrategy"</span>: <span class="string">"AsIs"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"policy"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"reverse"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"transport"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ol start="3"><li>配置 v2ray service：</li></ol><p><code>systemctl enable v2ray &amp;&amp; systemctl start v2ray</code></p><p>或者</p><p><code>systemctl start v2ray --now</code></p><ol start="4"><li>开放 v2ray mkcp 端口</li></ol><p><code>firewall-cmd --zone=public --permanent add-port=8082/tcp</code><br><code>firewall-cmd --zone=public --permanent add-port=8082/udp</code><br><code>firewall-cmd --reload</code></p><ol start="5"><li>（推荐）通过 docker 运行 v2ray</li></ol><p><code>docker run --restart=always -d -p 8082:8082/udp -p 127.0.0.1:8081:8081 -v /path/to/v2ray/config.json:/etc/v2ray/config.json -v /path/to/v2ray:/var/log/v2ray/ v2ray/officia</code></p><p>注： </p><ul><li><code>--restart=always</code> 设置 container 随 docker daemon 启动; </li><li><code>127.0.0.1:8081</code> 作为 Nginx 的 upstream 地址，不对外暴露，由 Nginx 代理；    </li><li>port <code>8082</code> 作为 UDP server 监听端口，监听 <code>0.0.0.0</code>；</li><li><code>/path/to/v2ray</code> 作为 v2ray 的配置文件和 log 目录。</li></ul><ol start="6"><li>配置 log rotate</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF &gt; /etc/logrotate.d/v2ray</span><br><span class="line">/path/to/v2ray/*.log &#123;</span><br><span class="line">    daily</span><br><span class="line">    rotate 5</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    compress</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="Centos7-yum-安装-Nginx"><a href="#Centos7-yum-安装-Nginx" class="headerlink" title="Centos7 yum 安装 Nginx"></a>Centos7 yum 安装 Nginx</h2><ol><li>Add nginx Repository：</li></ol><p><code>yum install epel-release</code></p><ol start="2"><li>Instal nginx</li></ol><p><code>yum install nginx</code></p><ol start="3"><li>Config firewall</li></ol><p><code>firewall-cmd --permanent --zone=public --add-service=http</code><br><code>firewall-cmd --permanent --zone=public --add-service=https</code><br><code>firewall-cmd --reload</code></p><ol start="4"><li>Config nginx</li></ol><p><code>systemctl enable nginx &amp;&amp; systemctl start nginx</code> </p><p>或者</p><p><code>systemctl start nginx --now</code></p><h2 id="生成自签名的-SSL-证书（x-509-v1）"><a href="#生成自签名的-SSL-证书（x-509-v1）" class="headerlink" title="生成自签名的 SSL 证书（x.509 v1）"></a>生成自签名的 SSL 证书（x.509 v1）</h2><ol><li>生成 RSA 私钥（不加密）：</li></ol><p><code>openssl genrsa -out server.key 1024</code>  </p><p>注：通过 <code>man genrsa</code>  查看使用手册；为避免每次 nginx reload ssl 都要手动输入口令，这里生成的私钥不要加密。</p><ol start="2"><li>创建证书签名申请（CSR， Certificate Signning Request）:</li></ol><p><code>openssl req -new -key server.key -out server.csr</code></p><ol start="3"><li>使用前面生成的私钥对 CSR 进行签名生成证书:</li></ol><p><code>openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt</code></p><p><code>openssl x509 -noout -text -in server.crt</code>  可以查看证书内容。</p><h2 id="配置-Nginx-使用自签名的-SSL-证书"><a href="#配置-Nginx-使用自签名的-SSL-证书" class="headerlink" title="配置 Nginx 使用自签名的 SSL 证书"></a>配置 Nginx 使用自签名的 SSL 证书</h2><ol><li><p>配置私钥和证书文件的目录 <code>mkdir /etc/nginx/self_cert</code>，将前面生成的 <code>server.key</code> 与 <code>server.crt</code> 文件 copy <code>/etc/nginx/self_cert</code>，将前面生成的。</p></li><li><p>编辑 Nginx 的配置配置文件 <code>/etc/nginx/nginx.conf</code>:</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 default ssl;</span><br><span class="line">        ssl_certificate         /etc/nginx/self_cert/server.crt;</span><br><span class="line">        ssl_certificate_key     /etc/nginx/self_cert/server.key;</span><br><span class="line">        ssl_protocols         TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers           HIGH:!aNULL:!MD5;</span><br><span class="line">        server_name your_server_name_or_ip;</span><br><span class="line"></span><br><span class="line">        location /ray &#123;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_pass http://127.0.0.1:8081;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">            proxy_set_header Host $http_host;</span><br><span class="line">            </span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        location / &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>开启被 SELinux 关闭的 httpd 网络连接，否则会发生 <code>permission denied</code> 导致的 Nginx 502 bad gateway 错误：</li></ol><p><code>setsebool -P httpd_can_network_connect 1</code></p><ol start="4"><li>重启 Nginx： <code>nginx -s reload</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;v2ray-Nginx-TLS&quot;&gt;&lt;a href=&quot;#v2ray-Nginx-TLS&quot; class=&quot;headerlink&quot; title=&quot;v2ray + Nginx + TLS&quot;&gt;&lt;/a&gt;v2ray + Nginx + TLS&lt;/h1&gt;&lt;h2 id=&quot;安装-v2ray&quot;&gt;&lt;a href=&quot;#安装-v2ray&quot; class=&quot;headerlink&quot; title=&quot;安装 v2ray&quot;&gt;&lt;/a&gt;安装 v2ray&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装 v2ray 最新版本：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;bash &amp;lt;(curl -L -s https://install.direct/go.sh)&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;编辑 v2ray 配置文件 &lt;code&gt;/etc/v2ray/config.json&lt;/code&gt;，这个配置文件简单启用 2 个传输通道，分别是 port 8081 上的 websocket 和 port 8082 上的 mkcp，其他更多配置请参考官方文档：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;log&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&quot;access&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;/var/log/v2ray/access.log&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&quot;error&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;/var/log/v2ray/error.log&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&quot;loglevel&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;warning&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;dns&quot;&lt;/span&gt;: &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;stats&quot;&lt;/span&gt;: &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;inbounds&quot;&lt;/span&gt;: [&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;tag&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;in-0&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;settings&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;&quot;clients&quot;&lt;/span&gt;: [&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;attr&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;attr&quot;&gt;&quot;alterId&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;attr&quot;&gt;&quot;level&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;streamSettings&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;&quot;network&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;ws&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;&quot;wsSettings&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;attr&quot;&gt;&quot;path&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;/ray&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;&quot;security&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;listen&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;port&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;8081&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;protocol&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;vmess&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;tag&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;in-1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;settings&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;&quot;clients&quot;&lt;/span&gt;: [&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;attr&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;xxx&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;attr&quot;&gt;&quot;alterId&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;attr&quot;&gt;&quot;level&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;streamSettings&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;&quot;network&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;kcp&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;&quot;kcpSettings&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;attr&quot;&gt;&quot;header&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;dtls&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;&quot;security&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;port&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;8082&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;protocol&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;vmess&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;outbounds&quot;&lt;/span&gt;: [&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;tag&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;direct&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;settings&quot;&lt;/span&gt;: &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;protocol&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;freedom&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;tag&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;blocked&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;settings&quot;&lt;/span&gt;: &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;&quot;protocol&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;blackhole&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;routing&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&quot;rules&quot;&lt;/span&gt;: [&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;field&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;&quot;ip&quot;&lt;/span&gt;: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;string&quot;&gt;&quot;geoip:private&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;&quot;outboundTag&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;blocked&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&quot;domainStrategy&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;AsIs&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;policy&quot;&lt;/span&gt;: &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;reverse&quot;&lt;/span&gt;: &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;transport&quot;&lt;/span&gt;: &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="misc" scheme="http://yoursite.com/categories/misc/"/>
    
    
      <category term="v2ray" scheme="http://yoursite.com/tags/v2ray/"/>
    
      <category term="Nginix" scheme="http://yoursite.com/tags/Nginix/"/>
    
      <category term="TLS" scheme="http://yoursite.com/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 数据类型及存储</title>
    <link href="http://yoursite.com/2017/12/10/MongoDB-datatypes-storage/"/>
    <id>http://yoursite.com/2017/12/10/MongoDB-datatypes-storage/</id>
    <published>2017-12-10T03:25:01.000Z</published>
    <updated>2019-10-22T15:53:03.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-MongoDB"><a href="#What-is-MongoDB" class="headerlink" title="What is MongoDB?"></a>What is MongoDB?</h1><p>MongoDB is a document database with the scalability and flexibility that you want with the querying and indexing that you need.</p><p><strong>Stores data in flexible, JSON-like documents.</strong></p><p>Document =&gt; Collection =&gt; Database</p><p>ref: <a href="[https://www.mongodb.com/what-is-mongodb](https://www.mongodb.com/what-is-mongodb">what-is-mongodb</a>).</p><h1 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h1><h2 id="BSON-vs-JSON"><a href="#BSON-vs-JSON" class="headerlink" title="BSON vs JSON"></a>BSON vs JSON</h2><p><a href="[http://bsonspec.org](http://bsonspec.org">BSON [bee · sahn]</a>), short for Binary JSON, is a binary-encoded serialization of JSON-like documents.</p><ol><li><p>继承自 JSON，具备 JSON 的通用性与 schema-less（例如与 Protocol Buffers 比较）；</p></li><li><p>扩展了 JSON 的数据类型，提供了 JSON 没有的一些数据类型，例如： Date 和 BinData（byte array，有了这种类型以后就不需要像 JSON 一样需要先 base64 编码再存储，减少了计算和存储的开销）；</p></li><li><p>BSON 的存储结构相比较 JSON 有更快的遍历速度；</p></li><li><p>BSON 的存储有数据类型的支持，字段更新的时候更快更方便。JSON 的存储由于没有数据类型的支持，字段的更新需要移动文档的内容，操作代价大。</p></li></ol><p>BSON Spec ref：<a href="[http://bsonspec.org/spec.html](http://bsonspec.org/spec.html">bsonspec</a>)</p><p>头部存有数据结构的长度，有数据类型的支持，遍历起来快，不用像 JSON 一样进行各种复杂的数据结构匹配。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"hello"</span>: <span class="string">"world"</span>&#125;</span><br><span class="line"></span><br><span class="line">\x16\x00\x00\x00                   // total document size</span><br><span class="line">\x02                               // 0x02 = type String</span><br><span class="line">hello\x00                          // field name</span><br><span class="line">\x06\x00\x00\x00world\x00          // field value</span><br><span class="line">\x00                               // 0x00 = type EOO ('end of object')</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">"BSON"</span>: [<span class="string">"awesome"</span>, <span class="number">5.05</span>, <span class="number">1986</span>]&#125;</span><br><span class="line"></span><br><span class="line">\x31\x00\x00\x00</span><br><span class="line">\x04BSON\x00</span><br><span class="line">\x26\x00\x00\x00</span><br><span class="line">\x02\x30\x00\x08\x00\x00\x00awesome\x00</span><br><span class="line">\x01\x31\x00\x33\x33\x33\x33\x33\x33\x14\x40</span><br><span class="line">\x10\x32\x00\xc2\x07\x00\x00</span><br><span class="line">\x00</span><br><span class="line">\x00</span><br></pre></td></tr></table></figure><h2 id="BSON-Types"><a href="#BSON-Types" class="headerlink" title="BSON Types"></a>BSON Types</h2><p>BSON is a binary serialization format used to store documents and make remote procedure calls in MongoDB.</p><p>ref：<a href="https://docs.mongodb.com/v2.6/reference/bson-types/" target="_blank" rel="noopener">https://docs.mongodb.com/v2.6/reference/bson-types/</a></p><table><thead><tr><th>Type</th><th>Number</th><th>Notes</th></tr></thead><tbody><tr><td>Double</td><td>1</td><td></td></tr><tr><td>String</td><td>2</td><td></td></tr><tr><td>Object</td><td>3</td><td></td></tr><tr><td>Array</td><td>4</td><td></td></tr><tr><td>Binary Data</td><td>5</td><td></td></tr><tr><td>Undefined</td><td>6</td><td>deprecated</td></tr><tr><td>Object id</td><td>7</td><td></td></tr><tr><td>Boolean</td><td>8</td><td></td></tr><tr><td>Date</td><td>9</td><td></td></tr><tr><td>Null</td><td>10</td><td></td></tr><tr><td>Regular Expression</td><td>12</td><td></td></tr><tr><td>JavaScript</td><td>13</td><td></td></tr><tr><td>Symbol</td><td>14</td><td>deprecated</td></tr><tr><td>JavaScript (with scope)</td><td>15</td><td></td></tr><tr><td>32-bit integer</td><td>16</td><td></td></tr><tr><td>Timestamp</td><td>17</td><td></td></tr><tr><td>64-bit integer</td><td>18</td><td></td></tr><tr><td>Min key</td><td>255</td><td>Query with -1.</td></tr><tr><td>Max key</td><td>127</td></tr></tbody></table><a id="more"></a><h2 id="Comparison-and-Sort-Order"><a href="#Comparison-and-Sort-Order" class="headerlink" title="Comparison and Sort Order"></a>Comparison and Sort Order</h2><ol><li><p>不同数据类型之间的比较，类型之间有固定的比较优先级；</p></li><li><p>某些类型具有相同的优先级，比如：Numbers (ints, longs, doubles)，比较之前先进行类型转换；</p></li><li><p>non-existent field 与 empty field 等价，即 <code>{}</code> 与 <code>{a: null}</code> 等价；</p></li><li><p>Array 类型之间的比较排序，根据比较排序的类型选择 Array 中最小值（＜,ASC）或最大值(&gt;,DESC) 来比较；只有一个元素的 Array 与非 Array 的元素比较排序时，则直接使用数组中的唯一元素进行比较；Empty Array 将视为小于 Null 或者 缺少字段；</p></li><li><p>String 类型使用的是 UTF-8存储，由不同编程语言的 driver 来负责序列化和反序列化 BSON。另外，由于 <code>sort()</code> 函数内部使用 C++ strcmp api，在多语言环境中排序会有问题。MongoDB v3.4 引入 <a href="[https://docs.mongodb.com/manual/reference/collation/](https://docs.mongodb.com/manual/reference/collation/"><code>collation</code></a>) 参数。</p></li></ol><h2 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId"></a>ObjectId</h2><p>Document 需要 <code>_id</code> 字段作为 primary key，Insert document 时如果没有手动指定的话，该字段由 Driver 或者 MongoDB Server 来负责自动生成。</p><h1 id="MMAPv1-Storage-Engine"><a href="#MMAPv1-Storage-Engine" class="headerlink" title="MMAPv1 Storage Engine"></a>MMAPv1 Storage Engine</h1><p>ref：<a href="https://docs.mongodb.com/manual/core/mmapv1/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/core/mmapv1/</a></p><p><a href="https://github.com/mongodb/mongo/tree/master/src/mongo/db/storage/mmap_v1" target="_blank" rel="noopener">https://github.com/mongodb/mongo/tree/master/src/mongo/db/storage/mmap_v1</a></p><p>MMAPv1 是 MongoDB v3.2 之前的默认存储引擎，基于内存映射文件（<a href="https://docs.mongodb.com/v2.6/faq/storage/#what-are-memory-mapped-files" target="_blank" rel="noopener">memory mapped files</a>），具有优秀的 Insert，read and in-place update 性能。v3.2 之后默认使用的是 WiredTiger 引擎。</p><p>MMAPv1 具有一下一些特点：</p><ul><li><p>Journal，MongoDB 会先写  journal file（write-ahead redo logs），然后才是 data file，默认情况下 journal file 落地的时间是最大是  100ms，data file 落地的时间是最大是 60s（这是一个理论最大时间，实际上 OS 自身也有一个 flush 的落地操作）。这样当 MongoDB 发生故障的时候可以从 Journal 中恢复数据。</p></li><li><p>Document 连续地存储在磁盘中，当 Document 由于更新导致需要更多的存储空间时，需要重新分配空间并移动 Document 及更新相应的 Index。这会导致效率低下和存储碎片。</p><ul><li><p>padding 模式， paddingFactor 存储空间冗余系数，1.0 表示没有冗余，1.5 表示 50% 的冗余，通常在 1.0 ～4.0 之间。这是 MongoDB 根据文档的频繁变化来调整的，我们无法控制，但是在 compact 的时候可以指定这个参数以控制压缩后的 Document 占用的实际空间：<a href="https://docs.mongodb.com/manual/reference/command/compact/#compact-paddingfactor" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/command/compact/#compact-paddingfactor</a>。</p></li><li><p>usePowerOf2Sizes 模式( db.collection.stats())，从 MongoDB v2.6 开始作为默认的存储分配方式：<a href="https://docs.mongodb.com/v2.6/reference/command/collMod/#usePowerOf2Sizes" target="_blank" rel="noopener">https://docs.mongodb.com/v2.6/reference/command/collMod/#usePowerOf2Sizes</a>，按照 2 的 N 次方进行存储空间分配，最小分配 32 bytes，即 32，64，128，256…16777216。MongoDB v3.0 之前当 Document 的空间分配超过 4M 以后就会按照四舍五入的方式分配最接近的 N megabyte。v3.0 开始是达到 2M 以后按照 2M 为最小单位进行增长分配：<a href="https://docs.mongodb.com/manual/core/mmapv1/#power-of-2-sized-allocations" target="_blank" rel="noopener">https://docs.mongodb.com/manual/core/mmapv1/#power-of-2-sized-allocations</a>。</p></li><li><p>nopadding  模式，MongoDB v3.0 之后新增的一种分配方式，顾名思义最适合 insert-only 或者 update 不改变 Document size 的场景。</p></li></ul></li><li><p>Free Memory 会尽可能（100%）被用来做 Cache 以提高性能。</p></li><li><p>Database Level Concurrency，数据库级别的锁。</p></li><li><p>数据库层级分配存储文件，不会自动回收分配出去的空间。</p></li></ul><p><a href="https://docs.mongodb.com/manual/core/wiredtiger/" target="_blank" rel="noopener">WiredTiger </a> 存储引擎相比较 MMAPv1：</p><ul><li><p>Document Level Concurrency，文档那个级别的锁。</p></li><li><p>Snapshot and Checkpoint，故障恢复支持 Snapshot 和 Journal 的方式。</p></li><li><p>Collection 层级分配存储文件，并及时回收空间，优化压缩且可配置压缩算法。</p></li><li><p>v3.2 以后可以配置最大占用内存空间。</p></li></ul><h2 id="Data-File-Structure"><a href="#Data-File-Structure" class="headerlink" title="Data File Structure"></a>Data File Structure</h2><p>MongoDB 的文件分为 3 种，分别是</p><ul><li><p>Journal File，日志文件，存放在 MongoDB 数据目录下的 journal 子目录下；</p></li><li><p>Namespace File，命名空间文件，后缀名为 『.ns』 的文件；</p></li><li><p>Data File，数据文件，存放 Document 和 Index，以 Collection Name 作为文件名前缀的文件。</p></li></ul><h3 id="Journal-File"><a href="#Journal-File" class="headerlink" title="Journal File"></a>Journal File</h3><p>ref：<a href="https://docs.mongodb.com/v2.6/core/journaling/" target="_blank" rel="noopener">https://docs.mongodb.com/v2.6/core/journaling/</a></p><p>存储在单独的 『journal』子目录下面，以 『<strong>j._</strong>』 作为文件名前缀。MongoDB 启动的时候会默认创建 3 个大小为 1 G 的空  journal file（append-only） 备用，当一个 journal file 中操作全部落地以后，MongoDB 便会删除该 journal file，除非有持续海量的数据写入，否也一般只会有 2 ，3 个 journal file。正常的关闭 MongoDB 会删除 journal file。将 Journal File 和 Data File 放在不同的 FileSystem 上可以加速频繁顺序写的性能。</p><p><a href="https://docs.mongodb.com/v2.6/reference/configuration-options/#storage.smallFiles" target="_blank" rel="noopener">调整 MongoDB 默认文件的大小</a>，可以将 Journal File 的默认大小从 1 G 改为 128M。</p><h3 id="Namespace-File"><a href="#Namespace-File" class="headerlink" title="Namespace File"></a>Namespace File</h3><p>ref：<a href="https://docs.mongodb.com/v2.6/reference/limits/#namespaces" target="_blank" rel="noopener">https://docs.mongodb.com/v2.6/reference/limits/#namespaces</a></p><p>MongoDB 每个 database 中都会包含一个后缀名为 『<strong>.ns</strong>』 的文件，用于存储 namespce 信息，实现上是一个 Hash Table 可以快速地定位某个 namespce 在 Data File 中位置。namespace 长度最大为 120 bytes（包括 『<strong>.</strong>』 分隔符在内不超过 120 个字符）。namaspace 在对应的数据结构大小为 624 bytes，默认一个 namaspce file  的大小为 16 M，也就是说可以支持 16M/624=26715 个 namespace。最大可通过参数配置为 2 G 大小。</p><p>Namespace 的数据结构如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node &#123;</span><br><span class="line">    int hash;</span><br><span class="line">    Namespace key;</span><br><span class="line">    NamespaceDetails value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>hash： namespace 的 hash 值，使用的线性探测方式。</p></li><li><p>key：namaspce ，是一个长度为 120 bytes 的字符数组。</p></li><li><p>value：namespace 的详情，包括在 Data File 中起止位置（第一个 Extent 以及最后一个 Extent 的位置）及其他信息。</p></li></ul><h3 id="Data-File"><a href="#Data-File" class="headerlink" title="Data File"></a>Data File</h3><p>ref：<a href="https://docs.mongodb.com/v2.6/faq/storage/#preallocated-data-files" target="_blank" rel="noopener">https://docs.mongodb.com/v2.6/faq/storage/#preallocated-data-files</a></p><p>MongoDB 的 Data 和 Index 都存放在 Data File 中。为了防止文件系统碎片化， MongoDB 会以特定的 size 预先分配 Data File，命名从 0 开始：&lt;database_name&gt;.0, &lt;database_name&gt;.1…&lt;database_name&gt;.N， 第一个文件为 64M，第二个位 128M，直到 2G，之后都以 2G 大小来分配，也就是 MongDB 的 Data File 单个最大为 2G。</p><img src="/2017/12/10/MongoDB-datatypes-storage/data-structure.png"><p>Data File 结构如上图所示：</p><ul><li><p>一个 Data File 由多个 Extent 组成，一个 Extent 由多个  Record 组成，Record 中存储 MongoDB Document。Extent 和 Record 都被实现成双向链表。</p></li><li><p>一个 Extent 只会包含一个 Collection 的 Data 或者 Index，但是同一个 Extent 不会既有 Data 又有 Index。</p></li><li><p>一个 Collection 由多个 Extent 组成，这些 Extent 可以分布在多个 Data File 中。</p></li><li><p>Document 删除或移动（Not in-place update）后留下的未被使用的 Record 会被标记为 『Deleted Record』 而可以重新分配出去，<strong>但不会主动回收</strong>。『Deleted Record』在实现上会按照不同的 Size 组织成链表，加速重新分配过程。删除 Document 释放出来的 Extent 会被放到 Data File 的 Extent Free List 中。</p></li></ul><p>关于 db.stats() 的几个 Size 的区别与联系：</p><ul><li><p>dataSize： Records Total Size，Record 中包括 Header + BSON Data + Padding。</p></li><li><p>storageSize/indexSize： Extents Total Size，由于包含了 Delete Record 所以比 dataSize 大。</p></li><li><p>fileSize： 文件系统中文件的大小，包括了 Data Extent 、Index Extent 以及未被使用的空间，不会随着 DB 中 Document 的删除而减少。</p></li></ul><h4 id="Insert-Document"><a href="#Insert-Document" class="headerlink" title="Insert Document"></a>Insert Document</h4><ol><li><p>检查 Namespace 对应的 『Deleted Record』 中是否有合适 Size 的 Record，如果有则直接复用这个空间，写入 Document（注：Extent 中空闲空间会被作为一个 Big Deleted Record 处理）；</p></li><li><p>检查 Data File 的 Extent Free List 里面是否有合适大小的空闲 Extent 可用，如果有则使用空闲的 Extent，写入 Document；</p></li><li><p>否则就要创建新的 Extent，写入 Document 。如果 Data File 没有足够的空间创建 Extent 则创建新的 Data File。</p></li></ol><h4 id="Delete-Document"><a href="#Delete-Document" class="headerlink" title="Delete Document"></a>Delete Document</h4><p>删除 Document 释放出来的 Record 会作为 『Deleted Record』 复用，但不会主动回收。无法被复用的 Record 就会成为存储碎片，需要通过 <a href="https://docs.mongodb.com/manual/reference/command/compact/" target="_blank" rel="noopener">Compact </a>操作来改善。</p><h4 id="Update-Document"><a href="#Update-Document" class="headerlink" title="Update Document"></a>Update Document</h4><p>In-place Update，否则就是 Delete + Insert 操作。释放出来的 Record 作为 『Deleted Record』 被复用。非 In-place Update 会导致存储碎片，可以通过调整 Document 空间分配模式来改善。</p><h4 id="Query-Document"><a href="#Query-Document" class="headerlink" title="Query Document"></a>Query Document</h4><p>没有索引的情况下就只能遍历整个 Collection ，直到找到对应的 Record（Document）。建立索引可以加速查询。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;What-is-MongoDB&quot;&gt;&lt;a href=&quot;#What-is-MongoDB&quot; class=&quot;headerlink&quot; title=&quot;What is MongoDB?&quot;&gt;&lt;/a&gt;What is MongoDB?&lt;/h1&gt;&lt;p&gt;MongoDB is a document database with the scalability and flexibility that you want with the querying and indexing that you need.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stores data in flexible, JSON-like documents.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Document =&amp;gt; Collection =&amp;gt; Database&lt;/p&gt;
&lt;p&gt;ref: &lt;a href=&quot;[https://www.mongodb.com/what-is-mongodb](https://www.mongodb.com/what-is-mongodb&quot;&gt;what-is-mongodb&lt;/a&gt;).&lt;/p&gt;
&lt;h1 id=&quot;Data-Type&quot;&gt;&lt;a href=&quot;#Data-Type&quot; class=&quot;headerlink&quot; title=&quot;Data Type&quot;&gt;&lt;/a&gt;Data Type&lt;/h1&gt;&lt;h2 id=&quot;BSON-vs-JSON&quot;&gt;&lt;a href=&quot;#BSON-vs-JSON&quot; class=&quot;headerlink&quot; title=&quot;BSON vs JSON&quot;&gt;&lt;/a&gt;BSON vs JSON&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;[http://bsonspec.org](http://bsonspec.org&quot;&gt;BSON [bee · sahn]&lt;/a&gt;), short for Binary JSON, is a binary-encoded serialization of JSON-like documents.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;继承自 JSON，具备 JSON 的通用性与 schema-less（例如与 Protocol Buffers 比较）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;扩展了 JSON 的数据类型，提供了 JSON 没有的一些数据类型，例如： Date 和 BinData（byte array，有了这种类型以后就不需要像 JSON 一样需要先 base64 编码再存储，减少了计算和存储的开销）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BSON 的存储结构相比较 JSON 有更快的遍历速度；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BSON 的存储有数据类型的支持，字段更新的时候更快更方便。JSON 的存储由于没有数据类型的支持，字段的更新需要移动文档的内容，操作代价大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;BSON Spec ref：&lt;a href=&quot;[http://bsonspec.org/spec.html](http://bsonspec.org/spec.html&quot;&gt;bsonspec&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;头部存有数据结构的长度，有数据类型的支持，遍历起来快，不用像 JSON 一样进行各种复杂的数据结构匹配。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;attr&quot;&gt;&quot;hello&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;world&quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x16\x00\x00\x00                   // total document size&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x02                               // 0x02 = type String&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hello\x00                          // field name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x06\x00\x00\x00world\x00          // field value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x00                               // 0x00 = type EOO (&#39;end of object&#39;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;attr&quot;&gt;&quot;BSON&quot;&lt;/span&gt;: [&lt;span class=&quot;string&quot;&gt;&quot;awesome&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5.05&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1986&lt;/span&gt;]&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x31\x00\x00\x00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x04BSON\x00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x26\x00\x00\x00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x02\x30\x00\x08\x00\x00\x00awesome\x00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x01\x31\x00\x33\x33\x33\x33\x33\x33\x14\x40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x10\x32\x00\xc2\x07\x00\x00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x00&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;BSON-Types&quot;&gt;&lt;a href=&quot;#BSON-Types&quot; class=&quot;headerlink&quot; title=&quot;BSON Types&quot;&gt;&lt;/a&gt;BSON Types&lt;/h2&gt;&lt;p&gt;BSON is a binary serialization format used to store documents and make remote procedure calls in MongoDB.&lt;/p&gt;
&lt;p&gt;ref：&lt;a href=&quot;https://docs.mongodb.com/v2.6/reference/bson-types/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.mongodb.com/v2.6/reference/bson-types/&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Number&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Binary Data&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Undefined&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;deprecated&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object id&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Null&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Regular Expression&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JavaScript&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Symbol&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;deprecated&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JavaScript (with scope)&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;32-bit integer&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Timestamp&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;64-bit integer&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Min key&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;Query with -1.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Max key&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://yoursite.com/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
      <category term="datatypes" scheme="http://yoursite.com/tags/datatypes/"/>
    
      <category term="MMAPv1" scheme="http://yoursite.com/tags/MMAPv1/"/>
    
  </entry>
  
  <entry>
    <title>tornado.web.RequestHandler 安全 Cookie 与 XSRF 防护</title>
    <link href="http://yoursite.com/2016/02/15/tornado.web_secure_cookies_xsrf/"/>
    <id>http://yoursite.com/2016/02/15/tornado.web_secure_cookies_xsrf/</id>
    <published>2016-02-15T14:00:01.000Z</published>
    <updated>2019-10-22T15:53:03.350Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>网站安全不外乎就是信息安全的三个基本要点，简单来说就是：</p><ol><li>机密性，网站要保护用户的隐私数据不被窃取，账号不被盗用，面对的主要的攻击方式是植入木马；</li><li>可用性，网站要保证其服务是可用的，面对的主要的攻击方式是DOS和DDOS；</li><li>完整性，网站要确保用户请求信息或数据不被未授权的篡改或在篡改后能够被迅速发现，面对主要的攻击方式是XSS和CSRF；</li></ol><p>这篇笔记主要分析 Tornado 对 CSRF 的防范。众所周知 HTTP 协议是一个无状态协议，这便意味着每次请求都是独立的，要在两次请求之间共享数据（或者称为保持会话状态）便必须在请求时重传数据。 Cookie 和 Session 分别是客户端和服务端保持会话状态的机制。 Tornado Web 框架中已经默认对 Cookie 提供了支持，而对 Session 却没有提供内置的 Session 实现。我猜测这是因为考虑到现在的 Web 应用往往比较复杂并需要分布式存储 Session 数据，若要实现一个大而全 Session 来满足复杂的应能用场景基本上不可能，干脆就不内置而交由应用去自行根据需求来实现。</p><p>通常 Cookie 的使用不当往往导致安全问题， Tornado 在设计时便考虑到这个问题，为此内置 secure cookies 来阻止客户端非法修改 cookie 数据，以此来防范常见的 cookie 安全漏洞。Tornado 官方文档中专门用了一节 <a href="http://www.tornadoweb.org/en/stable/guide/security.html" target="_blank" rel="noopener">《认证和安全》</a> 来介绍相关内容（中文翻译：<a href="https://tornado-zh.readthedocs.org/zh/latest/guide/security.html" target="_blank" rel="noopener">https://tornado-zh.readthedocs.org/zh/latest/guide/security.html</a> ），在网上也有很多介绍这方面的资料，比如：<a href="http://demo.pythoner.com/itt2zh/ch6.html#ch6-2-1" target="_blank" rel="noopener">http://demo.pythoner.com/itt2zh/ch6.html#ch6-2-1</a> 就写的很好，所以这篇笔记不再从 “如何使用 secure cookies 来编写安全应用” 的角度来讨论，而是结合代码分析实现原理。</p><h3 id="Secure-Cookies"><a href="#Secure-Cookies" class="headerlink" title="Secure Cookies"></a>Secure Cookies</h3><p>Cookies 是不安全的，可以被客户端轻易修改和伪造，Tornado 的 Secure Cookies 使用加密签名来验证 Cookie 数据是否被非法修改过，签名后的 Cookie 数据包括时间戳、 HMAC 签名和编码后的 cookie 值等信。<code>tornado.web.RequestHandler</code> 通过 <code>set_secure_cookie()</code> 和 <code>get_secure_cookie()</code> 方法来设置和获取 Secure Cookies，因为 HMAC 签名密钥是由 <code>tornado.web.Application</code> 实例来提供的，所以在实例化  <code>tornado.web.Application</code> 时必须在 <code>settings</code> 中提供 <code>cookie_secret</code> 参数才能使用安全 Cookies。否则，<code>self.require_setting(&quot;cookie_secret&quot;, &quot;secure cookies&quot;)</code> 会抛出未设置 <code>cookie_secret</code>  异常。</p><p><code>cookie_secret</code> 参数是一个随机字节序列，用来制作 HMAC 签名，可以使用下面的代码来生成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64, uuid</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64encode(uuid.uuid4().bytes + uuid.uuid4().bytes)</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="set-secure-cookie-方法"><a href="#set-secure-cookie-方法" class="headerlink" title="set_secure_cookie 方法"></a>set_secure_cookie 方法</h4><p><code>set_secure_cookie</code> 方法是对 <code>set_cookie</code> 方法的包装，其方法签名中需要注意的是 <code>expires_days</code> 和 <code>version</code> 参数。</p><ol><li><p><code>expires_days</code> 按照 HTTP 协议的规定，用于指示客户端该 Cookie 的有效期，默认 30 天。这个参数与 <code>get_secure_cookie</code> 方法的 <code>max_age_days</code> 参数严格来讲没有必然的联系，我们可以使用一个小于 <code>expires_days</code> 的 <code>max_age_days</code> 值在服务端控制安全 Cookie 的有效期（这个是与安全 Cookie 中的时间戳比较得到的，后面会从代码中看到）。</p></li><li><p><code>version</code> 参数的引入主要是兼容旧的签名方式（版本号为 1 ，使用 SHA1 签名），目前默认使用新的签名方式（版本号为 2，使用 SHA256 签名）。两种方式不仅签名算法不同，签名输出的 Cookie 数据字段和格式也不同。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_secure_cookie</span><span class="params">(self, name, value, expires_days=<span class="number">30</span>, version=None, **kwargs)</span>:</span></span><br><span class="line">    self.set_cookie(name, self.create_signed_value(name, value,</span><br><span class="line">                                                   version=version),</span><br><span class="line">                    expires_days=expires_days, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_signed_value</span><span class="params">(self, name, value, version=None)</span>:</span></span><br><span class="line">    self.require_setting(<span class="string">"cookie_secret"</span>, <span class="string">"secure cookies"</span>)</span><br><span class="line">    <span class="keyword">return</span> create_signed_value(self.application.settings[<span class="string">"cookie_secret"</span>],</span><br><span class="line">                               name, value, version=version)</span><br></pre></td></tr></table></figure><p>上面代码明确调用 <code>self.require_setting(&quot;cookie_secret&quot;, &quot;secure cookies&quot;)</code> 来检查是否已经设置有签名密钥。</p><p><code>create_signed_value</code> 函数的代码及相关签名函数如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_SIGNED_VALUE_VERSION = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_signed_value</span><span class="params">(secret, name, value, version=None, clock=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> version <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        version = DEFAULT_SIGNED_VALUE_VERSION</span><br><span class="line">    <span class="keyword">if</span> clock <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        clock = time.time</span><br><span class="line">    timestamp = utf8(str(int(clock())))</span><br><span class="line">    value = base64.b64encode(utf8(value))</span><br><span class="line">    <span class="keyword">if</span> version == <span class="number">1</span>:</span><br><span class="line">        signature = _create_signature_v1(secret, name, value, timestamp)</span><br><span class="line">        value = <span class="string">b"|"</span>.join([value, timestamp, signature])</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">elif</span> version == <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># The v2 format consists of a version number and a series of</span></span><br><span class="line">        <span class="comment"># length-prefixed fields "%d:%s", the last of which is a</span></span><br><span class="line">        <span class="comment"># signature, all separated by pipes.  All numbers are in</span></span><br><span class="line">        <span class="comment"># decimal format with no leading zeros.  The signature is an</span></span><br><span class="line">        <span class="comment"># HMAC-SHA256 of the whole string up to that point, including</span></span><br><span class="line">        <span class="comment"># the final pipe.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># The fields are:</span></span><br><span class="line">        <span class="comment"># - format version (i.e. 2; no length prefix)</span></span><br><span class="line">        <span class="comment"># - key version (currently 0; reserved for future key rotation features)</span></span><br><span class="line">        <span class="comment"># - timestamp (integer seconds since epoch)</span></span><br><span class="line">        <span class="comment"># - name (not encoded; assumed to be ~alphanumeric)</span></span><br><span class="line">        <span class="comment"># - value (base64-encoded)</span></span><br><span class="line">        <span class="comment"># - signature (hex-encoded; no length prefix)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">format_field</span><span class="params">(s)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> utf8(<span class="string">"%d:"</span> % len(s)) + utf8(s)</span><br><span class="line">        to_sign = <span class="string">b"|"</span>.join([</span><br><span class="line">            <span class="string">b"2|1:0"</span>,</span><br><span class="line">            format_field(timestamp),</span><br><span class="line">            format_field(name),</span><br><span class="line">            format_field(value),</span><br><span class="line">            <span class="string">b''</span>])</span><br><span class="line">        signature = _create_signature_v2(secret, to_sign)</span><br><span class="line">        <span class="keyword">return</span> to_sign + signature</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"Unsupported version %d"</span> % version)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_create_signature_v1</span><span class="params">(secret, *parts)</span>:</span></span><br><span class="line">    hash = hmac.new(utf8(secret), digestmod=hashlib.sha1)</span><br><span class="line">    <span class="keyword">for</span> part <span class="keyword">in</span> parts:</span><br><span class="line">        hash.update(utf8(part))</span><br><span class="line">    <span class="keyword">return</span> utf8(hash.hexdigest())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_create_signature_v2</span><span class="params">(secret, s)</span>:</span></span><br><span class="line">    hash = hmac.new(utf8(secret), digestmod=hashlib.sha256)</span><br><span class="line">    hash.update(utf8(s))</span><br><span class="line">    <span class="keyword">return</span> utf8(hash.hexdigest())</span><br></pre></td></tr></table></figure><p>Cookie 值通过 <code>value = base64.b64encode(utf8(value))</code> 进行 base64 编码转换，所以 <code>set_secure_cookie</code> 能支持任意的字符，这与 <code>set_cookie</code> 方法不同（python2 是转换为 str，python3 时转换为 unicode string，且不允许输入 “\x00-\x20” 之间的字符，其实现代码中由正则表达式来检查）。</p><p>模块变量 <code>DEFAULT_SIGNED_VALUE_VERSION</code>  硬编码指示默认的签名版本是 2，除非调用 <code>set_secure_cookie</code> 时指定版本号。两个版本之间的数据格式看代码就很明确，版本 1 就是简单的 “value|timestamp|signature” 拼接，版本 2 多了几个字段，并且记录值的字符串长度，尤其是预留的 <code>key_version</code> 字段为后续轮流使用多个 <code>cookie_secret</code> 提供了支持（我目前分析使用的 Tornado v4.0.1 还没有实现这个特性，但最新的 v4.3 已经默认支持，具体我没有去查看代码，感兴趣可以去看看），<strong>并且对整个字符串进行签名（版本 1 仅仅对 value 进行了签名</strong>），这样可以大大增加安全系数。<strong>这里额外提一下时间戳（timestamp）字段，由于客户端在发送 Cookie 时并不会提供有效期，为了能够准确控制有效期，这里将 Cookie 生成的时间戳写入值当中，以便后续在服务端进行有效期验证。</strong></p><h4 id="get-secure-cookie-方法"><a href="#get-secure-cookie-方法" class="headerlink" title="get_secure_cookie 方法"></a>get_secure_cookie 方法</h4><p><code>get_secure_cookie</code> 方法签名中的 <code>value</code> 参数指的是通过 <code>set_secure_cookie</code> 加密签名后的 Cookie 值，默认是 <code>None</code> 则会从客户端发送回来的 Cookies 中获取指定名称的 Cookie 值作为 <code>value</code>，再进行签名验证，传入的 <code>max_age_days</code>，<code>min_version</code> 将对 Cookie 做进一步比较验证，验证通过以后返回 base64 解码的 Cookie 值（也就是下面注释中说的不论 python 的版本，返回的是 byte string，与 <code>get_cookie</code> 方法不同。<code>get_cookie</code> 方法在 python3 中返回的是 unicode string。）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_secure_cookie</span><span class="params">(self, name, value=None, max_age_days=<span class="number">31</span>, min_version=None)</span>:</span></span><br><span class="line">    <span class="string">"""Returns the given signed cookie if it validates, or None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The decoded cookie value is returned as a byte string (unlike</span></span><br><span class="line"><span class="string">    `get_cookie`).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionchanged:: 3.2.1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Added the ``min_version`` argument.  Introduced cookie version 2;</span></span><br><span class="line"><span class="string">       both versions 1 and 2 are accepted by default.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.require_setting(<span class="string">"cookie_secret"</span>, <span class="string">"secure cookies"</span>)</span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        value = self.get_cookie(name)</span><br><span class="line">    <span class="keyword">return</span> decode_signed_value(self.application.settings[<span class="string">"cookie_secret"</span>],</span><br><span class="line">                               name, value, max_age_days=max_age_days,</span><br><span class="line">                               min_version=min_version)</span><br></pre></td></tr></table></figure><p><code>decode_signed_value</code> 方法的相关代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_SIGNED_VALUE_MIN_VERSION = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A leading version number in decimal with no leading zeros, followed by a pipe.</span></span><br><span class="line">_signed_value_version_re = re.compile(<span class="string">br"^([1-9][0-9]*)\|(.*)$"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_signed_value</span><span class="params">(secret, name, value, max_age_days=<span class="number">31</span>, clock=None, min_version=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> clock <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        clock = time.time</span><br><span class="line">    <span class="keyword">if</span> min_version <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        min_version = DEFAULT_SIGNED_VALUE_MIN_VERSION</span><br><span class="line">    <span class="keyword">if</span> min_version &gt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"Unsupported min_version %d"</span> % min_version)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> value:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Figure out what version this is.  Version 1 did not include an</span></span><br><span class="line">    <span class="comment"># explicit version field and started with arbitrary base64 data,</span></span><br><span class="line">    <span class="comment"># which makes this tricky.</span></span><br><span class="line">    value = utf8(value)</span><br><span class="line">    m = _signed_value_version_re.match(value)</span><br><span class="line">    <span class="keyword">if</span> m <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        version = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            version = int(m.group(<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> version &gt; <span class="number">999</span>:</span><br><span class="line">                <span class="comment"># Certain payloads from the version-less v1 format may</span></span><br><span class="line">                <span class="comment"># be parsed as valid integers.  Due to base64 padding</span></span><br><span class="line">                <span class="comment"># restrictions, this can only happen for numbers whose</span></span><br><span class="line">                <span class="comment"># length is a multiple of 4, so we can treat all</span></span><br><span class="line">                <span class="comment"># numbers up to 999 as versions, and for the rest we</span></span><br><span class="line">                <span class="comment"># fall back to v1 format.</span></span><br><span class="line">                version = <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            version = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> version &lt; min_version:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> version == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> _decode_signed_value_v1(secret, name, value, max_age_days, clock)</span><br><span class="line">    <span class="keyword">elif</span> version == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> _decode_signed_value_v2(secret, name, value, max_age_days, clock)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_decode_signed_value_v1</span><span class="params">(secret, name, value, max_age_days, clock)</span>:</span></span><br><span class="line">    parts = utf8(value).split(<span class="string">b"|"</span>)</span><br><span class="line">    <span class="keyword">if</span> len(parts) != <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    signature = _create_signature_v1(secret, name, parts[<span class="number">0</span>], parts[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> _time_independent_equals(parts[<span class="number">2</span>], signature):</span><br><span class="line">        gen_log.warning(<span class="string">"Invalid cookie signature %r"</span>, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    timestamp = int(parts[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> timestamp &lt; clock() - max_age_days * <span class="number">86400</span>:</span><br><span class="line">        gen_log.warning(<span class="string">"Expired cookie %r"</span>, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> timestamp &gt; clock() + <span class="number">31</span> * <span class="number">86400</span>:</span><br><span class="line">        <span class="comment"># _cookie_signature does not hash a delimiter between the</span></span><br><span class="line">        <span class="comment"># parts of the cookie, so an attacker could transfer trailing</span></span><br><span class="line">        <span class="comment"># digits from the payload to the timestamp without altering the</span></span><br><span class="line">        <span class="comment"># signature.  For backwards compatibility, sanity-check timestamp</span></span><br><span class="line">        <span class="comment"># here instead of modifying _cookie_signature.</span></span><br><span class="line">        gen_log.warning(<span class="string">"Cookie timestamp in future; possible tampering %r"</span>, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> parts[<span class="number">1</span>].startswith(<span class="string">b"0"</span>):</span><br><span class="line">        gen_log.warning(<span class="string">"Tampered cookie %r"</span>, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> base64.b64decode(parts[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_decode_signed_value_v2</span><span class="params">(secret, name, value, max_age_days, clock)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_consume_field</span><span class="params">(s)</span>:</span></span><br><span class="line">        length, _, rest = s.partition(<span class="string">b':'</span>)</span><br><span class="line">        n = int(length)</span><br><span class="line">        field_value = rest[:n]</span><br><span class="line">        <span class="comment"># In python 3, indexing bytes returns small integers; we must</span></span><br><span class="line">        <span class="comment"># use a slice to get a byte string as in python 2.</span></span><br><span class="line">        <span class="keyword">if</span> rest[n:n + <span class="number">1</span>] != <span class="string">b'|'</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"malformed v2 signed value field"</span>)</span><br><span class="line">        rest = rest[n + <span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> field_value, rest</span><br><span class="line">    rest = value[<span class="number">2</span>:]  <span class="comment"># remove version number</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        key_version, rest = _consume_field(rest)</span><br><span class="line">        timestamp, rest = _consume_field(rest)</span><br><span class="line">        name_field, rest = _consume_field(rest)</span><br><span class="line">        value_field, rest = _consume_field(rest)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    passed_sig = rest</span><br><span class="line">    signed_string = value[:-len(passed_sig)]</span><br><span class="line">    expected_sig = _create_signature_v2(secret, signed_string)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> _time_independent_equals(passed_sig, expected_sig):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> name_field != utf8(name):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    timestamp = int(timestamp)</span><br><span class="line">    <span class="keyword">if</span> timestamp &lt; clock() - max_age_days * <span class="number">86400</span>:</span><br><span class="line">        <span class="comment"># The signature has expired.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> base64.b64decode(value_field)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hasattr(hmac, <span class="string">'compare_digest'</span>):  <span class="comment"># python 3.3</span></span><br><span class="line">    _time_independent_equals = hmac.compare_digest</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_time_independent_equals</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(a) != len(b):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(a[<span class="number">0</span>], int):  <span class="comment"># python3 byte strings</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b):</span><br><span class="line">                result |= x ^ y</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># python2</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b):</span><br><span class="line">                result |= ord(x) ^ ord(y)</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>_signed_value_version_re</code> 正则表达式用于获取签名所用的版本号，对于旧版本（版本 1 ）加密签名的 cookie 数据中没有版本号这个字段，默认取 1。然后与指定的 <code>min_version</code> 进行比较，仅当大于等于 <code>min_version</code> 才进行下一步验证。版本 1 由函数 <code>_decode_signed_value_v1</code> 验证，版本 2 由 函数 <code>_decode_signed_value_v2</code> 验证，这两个函数主要就是按照对应签名格式解析数据，并对目标签名和时间戳等字段进行比较验证。<strong>需要说一下的是由于版本 1 的设计缺陷，没有对 <code>timestamp</code> 进行签名，为了尽可能防止攻击者篡改时间戳来进行攻击， <code>_decode_signed_value_v1</code> 函数对 <code>timestamp</code> 执行了额外的检查（<code>timestamp &gt; clock() + 31 * 86400</code>），但这个检查并不能完全杜绝此类攻击。这应该也是重新设计版本 2 的一个原因。</strong></p><h3 id="XSRF"><a href="#XSRF" class="headerlink" title="XSRF"></a>XSRF</h3><p><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">XSRF（Cross-site request forgery，跨站请求伪造）</a>，也被简写为 CSRF，发音为”sea surf”，这是一个常见的安全漏洞（这里有一篇写的不错的文章<a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">《浅谈CSRF攻击方式》</a>，有兴趣的可以简单了解下）。通常 Synchronizer token pattern 是一种常见的解决方案，该方案利用了第三方站点无法访问 cookie 的限制，为每个客户端设置一个不同的 token，并将其存储在 cookie 中。当用户发起有副作用的 HTTP 请求时，则必须携带一个包含该 token 的参数（也可以通过 Http Header 传递），服务端将对存储在 cookie 和请求参数中的 token 进行比较，以防止潜在的跨站请求伪造。</p><h4 id="生成-xsrf-token"><a href="#生成-xsrf-token" class="headerlink" title="生成 xsrf_token"></a>生成 xsrf_token</h4><p><code>tornado.web.RequestHandler</code> 中与生成跨站请求伪造 token 直接相关的是 <code>xsrf_token</code> 属性和 <code>xsrf_form_html</code> 方法。</p><ol><li><p><code>xsrf_token</code> 属性在首次访问时会为客户端设置一个名为 <code>_xsrf</code> 的 cookie，其值变为前面所说的 token。token 有两个版本，版本号分别为 1 和 2，若没有在应用中设置 <code>xsrf_cookie_version</code> 参数则默认使用版本 2。版本 2 为每次请求都生成一个随机的掩码，相比较版本 1 而言安全性大大增强。</p></li><li><p><code>xsrf_form_html</code> 就是返回一个隐藏的 HTML &lt; input/&gt; 元素，用于包含在页面的 Form 元素中以便在 POST 请求时将 token 发送给服务端验证。</p></li></ol><p>详细代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xsrf_token</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">"_xsrf_token"</span>):</span><br><span class="line">        version, token, timestamp = self._get_raw_xsrf_token()</span><br><span class="line">        output_version = self.settings.get(<span class="string">"xsrf_cookie_version"</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> output_version == <span class="number">1</span>:</span><br><span class="line">            self._xsrf_token = binascii.b2a_hex(token)</span><br><span class="line">        <span class="keyword">elif</span> output_version == <span class="number">2</span>:</span><br><span class="line">            mask = os.urandom(<span class="number">4</span>)</span><br><span class="line">            self._xsrf_token = <span class="string">b"|"</span>.join([</span><br><span class="line">                <span class="string">b"2"</span>,</span><br><span class="line">                binascii.b2a_hex(mask),</span><br><span class="line">                binascii.b2a_hex(_websocket_mask(mask, token)),</span><br><span class="line">                utf8(str(int(timestamp)))])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"unknown xsrf cookie version %d"</span>,</span><br><span class="line">                             output_version)</span><br><span class="line">        <span class="keyword">if</span> version <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            expires_days = <span class="number">30</span> <span class="keyword">if</span> self.current_user <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            self.set_cookie(<span class="string">"_xsrf"</span>, self._xsrf_token,</span><br><span class="line">                            expires_days=expires_days)</span><br><span class="line">    <span class="keyword">return</span> self._xsrf_token</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xsrf_form_html</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""An HTML ``&lt;input/&gt;`` element to be included with all POST forms.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It defines the ``_xsrf`` input value, which we check on all POST</span></span><br><span class="line"><span class="string">    requests to prevent cross-site request forgery. If you have set</span></span><br><span class="line"><span class="string">    the ``xsrf_cookies`` application setting, you must include this</span></span><br><span class="line"><span class="string">    HTML within all of your HTML forms.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    In a template, this method should be called with ``&#123;% module</span></span><br><span class="line"><span class="string">    xsrf_form_html() %&#125;``</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See `check_xsrf_cookie()` above for more information.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;input type="hidden" name="_xsrf" value="'</span> + \</span><br><span class="line">        escape.xhtml_escape(self.xsrf_token) + <span class="string">'"/&gt;'</span></span><br></pre></td></tr></table></figure></p><p>上述两个方法关联的另外几个方法是 <code>_get_raw_xsrf_token</code> 和 <code>_decode_xsrf_token</code>。首次访问 <code>_get_raw_xsrf_token</code> 方法时，将尝试为当前用户请求生成 token（若已经生成，则直接从 cookie “_xsrf” 中获取），并赋值给 handler 的 <code>_raw_xsrf_token</code> 字段。<code>_decode_xsrf_token</code> 方法将 token 解析为 (version, token, timestamp) 元组返回（兼容版本 1 ，版本 1 中没有 version 和 timestamp 字段）。代码很简单，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_raw_xsrf_token</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Read or generate the xsrf token in its raw form.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The raw_xsrf_token is a tuple containing:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    * version: the version of the cookie from which this token was read,</span></span><br><span class="line"><span class="string">      or None if we generated a new token in this request.</span></span><br><span class="line"><span class="string">    * token: the raw token data; random (non-ascii) bytes.</span></span><br><span class="line"><span class="string">    * timestamp: the time this token was generated (will not be accurate</span></span><br><span class="line"><span class="string">      for version 1 cookies)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'_raw_xsrf_token'</span>):</span><br><span class="line">        cookie = self.get_cookie(<span class="string">"_xsrf"</span>)</span><br><span class="line">        <span class="keyword">if</span> cookie:</span><br><span class="line">            version, token, timestamp = self._decode_xsrf_token(cookie)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            version, token, timestamp = <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            version = <span class="literal">None</span></span><br><span class="line">            token = os.urandom(<span class="number">16</span>)</span><br><span class="line">            timestamp = time.time()</span><br><span class="line">        self._raw_xsrf_token = (version, token, timestamp)</span><br><span class="line">    <span class="keyword">return</span> self._raw_xsrf_token</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_decode_xsrf_token</span><span class="params">(self, cookie)</span>:</span></span><br><span class="line">    <span class="string">"""Convert a cookie string into a the tuple form returned by</span></span><br><span class="line"><span class="string">    _get_raw_xsrf_token.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m = _signed_value_version_re.match(utf8(cookie))</span><br><span class="line">    <span class="keyword">if</span> m:</span><br><span class="line">        version = int(m.group(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> version == <span class="number">2</span>:</span><br><span class="line">            _, mask, masked_token, timestamp = cookie.split(<span class="string">"|"</span>)</span><br><span class="line">            mask = binascii.a2b_hex(utf8(mask))</span><br><span class="line">            token = _websocket_mask(</span><br><span class="line">                mask, binascii.a2b_hex(utf8(masked_token)))</span><br><span class="line">            timestamp = int(timestamp)</span><br><span class="line">            <span class="keyword">return</span> version, token, timestamp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Treat unknown versions as not present instead of failing.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        version = <span class="number">1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            token = binascii.a2b_hex(utf8(cookie))</span><br><span class="line">        <span class="keyword">except</span> (binascii.Error, TypeError):</span><br><span class="line">            token = utf8(cookie)</span><br><span class="line">        <span class="comment"># We don't have a usable timestamp in older versions.</span></span><br><span class="line">        timestamp = int(time.time())</span><br><span class="line">        <span class="keyword">return</span> (version, token, timestamp)</span><br></pre></td></tr></table></figure><h4 id="检查-xsrf-token"><a href="#检查-xsrf-token" class="headerlink" title="检查 xsrf_token"></a>检查 xsrf_token</h4><p>对 xsrf_token 的检查在 <code>_execute</code> 方法中委托 <code>check_xsrf_cookie</code> 方法进行，代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self, transforms, *args, **kwargs)</span>:</span></span><br><span class="line">…………</span><br><span class="line">    <span class="comment"># If XSRF cookies are turned on, reject form submissions without</span></span><br><span class="line">    <span class="comment"># the proper cookie</span></span><br><span class="line">    <span class="keyword">if</span> self.request.method <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">"GET"</span>, <span class="string">"HEAD"</span>, <span class="string">"OPTIONS"</span>) <span class="keyword">and</span> \</span><br><span class="line">            self.application.settings.get(<span class="string">"xsrf_cookies"</span>):</span><br><span class="line">        self.check_xsrf_cookie()</span><br><span class="line">    …………</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_xsrf_cookie</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Verifies that the ``_xsrf`` cookie matches the ``_xsrf`` argument.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    To prevent cross-site request forgery, we set an ``_xsrf``</span></span><br><span class="line"><span class="string">    cookie and include the same value as a non-cookie</span></span><br><span class="line"><span class="string">    field with all ``POST`` requests. If the two do not match, we</span></span><br><span class="line"><span class="string">    reject the form submission as a potential forgery.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The ``_xsrf`` value may be set as either a form field named ``_xsrf``</span></span><br><span class="line"><span class="string">    or in a custom HTTP header named ``X-XSRFToken`` or ``X-CSRFToken``</span></span><br><span class="line"><span class="string">    (the latter is accepted for compatibility with Django).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    See http://en.wikipedia.org/wiki/Cross-site_request_forgery</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Prior to release 1.1.1, this check was ignored if the HTTP header</span></span><br><span class="line"><span class="string">    ``X-Requested-With: XMLHTTPRequest`` was present.  This exception</span></span><br><span class="line"><span class="string">    has been shown to be insecure and has been removed.  For more</span></span><br><span class="line"><span class="string">    information please see</span></span><br><span class="line"><span class="string">    http://www.djangoproject.com/weblog/2011/feb/08/security/</span></span><br><span class="line"><span class="string">    http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionchanged:: 3.2.2</span></span><br><span class="line"><span class="string">       Added support for cookie version 2.  Both versions 1 and 2 are</span></span><br><span class="line"><span class="string">       supported.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    token = (self.get_argument(<span class="string">"_xsrf"</span>, <span class="literal">None</span>) <span class="keyword">or</span></span><br><span class="line">             self.request.headers.get(<span class="string">"X-Xsrftoken"</span>) <span class="keyword">or</span></span><br><span class="line">             self.request.headers.get(<span class="string">"X-Csrftoken"</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> token:</span><br><span class="line">        <span class="keyword">raise</span> HTTPError(<span class="number">403</span>, <span class="string">"'_xsrf' argument missing from POST"</span>)</span><br><span class="line">    _, token, _ = self._decode_xsrf_token(token)</span><br><span class="line">    _, expected_token, _ = self._get_raw_xsrf_token()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> _time_independent_equals(utf8(token), utf8(expected_token)):</span><br><span class="line">        <span class="keyword">raise</span> HTTPError(<span class="number">403</span>, <span class="string">"XSRF cookie does not match POST argument"</span>)</span><br></pre></td></tr></table></figure><p><code>check_xsrf_cookie</code> 方法代码显示与 cookie 中的 token 进行比较的 token 来源于请求参数 <code>_xsrf</code> 或者 HTTP 头域（<code>X-Xsrftoken</code> 或者 <code>X-Csrftoken</code>）。目前仅比较 token 值，对其中的 timestamp 和 version 字段不做比较验证。</p><p>由上可见，xsrf cookies 的生成仅与是否访问 <code>xsrf_token</code> 属性相关，要进行验证则需要为应用设置 <code>xsrf_cookies</code> 为 True。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;网站安全不外乎就是信息安全的三个基本要点，简单来说就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;机密性，网站要保护用户的隐私数据不被窃取，账号不被盗用，面对的主要的攻击方式是植入木马；&lt;/li&gt;
&lt;li&gt;可用性，网站要保证其服务是可用的，面对的主要的攻击方式是DOS和DDOS；&lt;/li&gt;
&lt;li&gt;完整性，网站要确保用户请求信息或数据不被未授权的篡改或在篡改后能够被迅速发现，面对主要的攻击方式是XSS和CSRF；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这篇笔记主要分析 Tornado 对 CSRF 的防范。众所周知 HTTP 协议是一个无状态协议，这便意味着每次请求都是独立的，要在两次请求之间共享数据（或者称为保持会话状态）便必须在请求时重传数据。 Cookie 和 Session 分别是客户端和服务端保持会话状态的机制。 Tornado Web 框架中已经默认对 Cookie 提供了支持，而对 Session 却没有提供内置的 Session 实现。我猜测这是因为考虑到现在的 Web 应用往往比较复杂并需要分布式存储 Session 数据，若要实现一个大而全 Session 来满足复杂的应能用场景基本上不可能，干脆就不内置而交由应用去自行根据需求来实现。&lt;/p&gt;
&lt;p&gt;通常 Cookie 的使用不当往往导致安全问题， Tornado 在设计时便考虑到这个问题，为此内置 secure cookies 来阻止客户端非法修改 cookie 数据，以此来防范常见的 cookie 安全漏洞。Tornado 官方文档中专门用了一节 &lt;a href=&quot;http://www.tornadoweb.org/en/stable/guide/security.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《认证和安全》&lt;/a&gt; 来介绍相关内容（中文翻译：&lt;a href=&quot;https://tornado-zh.readthedocs.org/zh/latest/guide/security.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tornado-zh.readthedocs.org/zh/latest/guide/security.html&lt;/a&gt; ），在网上也有很多介绍这方面的资料，比如：&lt;a href=&quot;http://demo.pythoner.com/itt2zh/ch6.html#ch6-2-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://demo.pythoner.com/itt2zh/ch6.html#ch6-2-1&lt;/a&gt; 就写的很好，所以这篇笔记不再从 “如何使用 secure cookies 来编写安全应用” 的角度来讨论，而是结合代码分析实现原理。&lt;/p&gt;
&lt;h3 id=&quot;Secure-Cookies&quot;&gt;&lt;a href=&quot;#Secure-Cookies&quot; class=&quot;headerlink&quot; title=&quot;Secure Cookies&quot;&gt;&lt;/a&gt;Secure Cookies&lt;/h3&gt;&lt;p&gt;Cookies 是不安全的，可以被客户端轻易修改和伪造，Tornado 的 Secure Cookies 使用加密签名来验证 Cookie 数据是否被非法修改过，签名后的 Cookie 数据包括时间戳、 HMAC 签名和编码后的 cookie 值等信。&lt;code&gt;tornado.web.RequestHandler&lt;/code&gt; 通过 &lt;code&gt;set_secure_cookie()&lt;/code&gt; 和 &lt;code&gt;get_secure_cookie()&lt;/code&gt; 方法来设置和获取 Secure Cookies，因为 HMAC 签名密钥是由 &lt;code&gt;tornado.web.Application&lt;/code&gt; 实例来提供的，所以在实例化  &lt;code&gt;tornado.web.Application&lt;/code&gt; 时必须在 &lt;code&gt;settings&lt;/code&gt; 中提供 &lt;code&gt;cookie_secret&lt;/code&gt; 参数才能使用安全 Cookies。否则，&lt;code&gt;self.require_setting(&amp;quot;cookie_secret&amp;quot;, &amp;quot;secure cookies&amp;quot;)&lt;/code&gt; 会抛出未设置 &lt;code&gt;cookie_secret&lt;/code&gt;  异常。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cookie_secret&lt;/code&gt; 参数是一个随机字节序列，用来制作 HMAC 签名，可以使用下面的代码来生成：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; base64, uuid&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;base64.b64encode(uuid.uuid4().bytes + uuid.uuid4().bytes)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="Secure Cookies" scheme="http://yoursite.com/tags/Secure-Cookies/"/>
    
      <category term="XSRF" scheme="http://yoursite.com/tags/XSRF/"/>
    
      <category term="CSRF" scheme="http://yoursite.com/tags/CSRF/"/>
    
      <category term="跨站请求伪造" scheme="http://yoursite.com/tags/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>tornado.web.RequestHandler 异常处理</title>
    <link href="http://yoursite.com/2016/01/30/tornado.web_handle_exception/"/>
    <id>http://yoursite.com/2016/01/30/tornado.web_handle_exception/</id>
    <published>2016-01-30T06:00:01.000Z</published>
    <updated>2019-10-22T15:53:03.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RequestHandler-异常处理"><a href="#RequestHandler-异常处理" class="headerlink" title="RequestHandler 异常处理"></a>RequestHandler 异常处理</h3><p>之前的笔记中已经提到过 <code>RequestHandler</code> 的 <code>_execute</code> 方法完全处于一个异常处理块中，所以异常处理入口 <code>_handle_request_exception</code> 便在这里开始处理流程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_request_exception</span><span class="params">(self, e)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(e, Finish):</span><br><span class="line">        <span class="comment"># Not an error; just finish the request without logging.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._finished:</span><br><span class="line">            self.finish()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self.log_exception(*sys.exc_info())</span><br><span class="line">    <span class="keyword">if</span> self._finished:</span><br><span class="line">        <span class="comment"># Extra errors after the request has been finished should</span></span><br><span class="line">        <span class="comment"># be logged, but there is no reason to continue to try and</span></span><br><span class="line">        <span class="comment"># send a response.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(e, HTTPError):</span><br><span class="line">        <span class="keyword">if</span> e.status_code <span class="keyword">not</span> <span class="keyword">in</span> httputil.responses <span class="keyword">and</span> <span class="keyword">not</span> e.reason:</span><br><span class="line">            gen_log.error(<span class="string">"Bad HTTP status code: %d"</span>, e.status_code)</span><br><span class="line">            self.send_error(<span class="number">500</span>, exc_info=sys.exc_info())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.send_error(e.status_code, exc_info=sys.exc_info())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.send_error(<span class="number">500</span>, exc_info=sys.exc_info())</span><br></pre></td></tr></table></figure><p>由前面的代码可以看到，与请求异常处理相关的自定义异常类型是 <code>Finish</code>、<code>HTTPError</code>，方法有 <code>log_exception</code> 和 <code>send_error</code>。</p><p>在 <code>_handle_request_exception</code> 的处理流程中，除去 <code>Finish</code> 类型外的所有异常都需要调用 <code>log_exception</code> 方法来记录异常信息。如果响应没有结束，还需要尝试向客户端响应异常信息（只所以说是 “尝试”，是因为我们无法修改已经 <code>flush</code> 到客户端的数据，只能在尚未 <code>flush</code> 过数据时响应异常信息）。</p><h4 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h4><p><code>Finish</code> 是一个特别的自定义异常类型，为应用程序提供一种提前结束请求的方式。因抛出 <code>Finish</code> 而结束的请求不会输出一个异常响应（即不被视为请求处理异常）。如代码中所示，在 <code>RequestHandler</code> 请求处理过程中抛出 <code>Finish</code> 时，如果没有调用 <code>finish</code> 则调用 <code>finish</code> 结束请求，并立即返回，结束处理流程。这样一来后续与异常处理相关的方法就不会被调用，也就不会影响到已经 <code>flush</code> 的内容。</p><a id="more"></a><h4 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h4><p><code>HTTPError</code> 用来包装一个异常，将其转换为一个 HTTP 错误响应。与 <code>Finish</code> 一样，抛出一个 <code>HTTPError</code> 便会自动结束一个请求，相对于直接调用 <code>send_error</code> 来向客户端输出一个 HTTP 错误响应更方便。</p><p>由 <code>_handle_request_exception</code> 的代码可知，对于一般的未捕获的异常，直接响应为 HTTP 500 错误。对于 <code>HTTPError</code> 异常实例，如果其没有设置 HTTP 状态码和错误原因也响应为 HTTP 500 错误，否则按照 <code>HTTPError</code> 实例提供的错误码响应。</p><h4 id="log-exception-method"><a href="#log-exception-method" class="headerlink" title="log_exception method"></a>log_exception method</h4><p><code>log_exception</code> 为请求处理器提供记录未处理异常的日志功能，<strong><code>RequestHandler</code> 的子类可以覆写该方法来自定义日志的等级和输出内容、格式等。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_exception</span><span class="params">(self, typ, value, tb)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(value, HTTPError):</span><br><span class="line">        <span class="keyword">if</span> value.log_message:</span><br><span class="line">            format = <span class="string">"%d %s: "</span> + value.log_message</span><br><span class="line">            args = ([value.status_code, self._request_summary()] +</span><br><span class="line">                    list(value.args))</span><br><span class="line">            gen_log.warning(format, *args)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        app_log.error(<span class="string">"Uncaught exception %s\n%r"</span>, self._request_summary(),</span><br><span class="line">                      self.request, exc_info=(typ, value, tb))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_request_summary</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.request.method + <span class="string">" "</span> + self.request.uri + \</span><br><span class="line">        <span class="string">" ("</span> + self.request.remote_ip + <span class="string">")"</span></span><br></pre></td></tr></table></figure><p>默认情况下，<code>HTTPError</code> 通过 <code>tornado.general</code> 日志实例记录为 “warning” 等级，并且不会记录异常堆栈信息。其他异常类型则通过 <code>tornado.application</code> 日志实例记录为 “error” 等级，并有完整的异常堆栈信息。</p><p>另外，<code>_request_summary</code> 方法只能输出请求的 HttpMethod、uri、remote_ip 信息。发生非 <code>HTTPError</code> 类型异常时，甚至连上述信息都没有记录。这在实际使用时可能并不够用，通常我们可能还需要将请求（GET/POST）参数一并记录下来分析。</p><h4 id="send-error-method"><a href="#send-error-method" class="headerlink" title="send_error method"></a>send_error method</h4><p><code>send_error</code> 在请求处理器捕获到未处理异常时尝试向客户端发送一个 HTTP 错误响应。如果已经调用过 <code>flush</code> 方法，则不可能再发送错误码，便简单地结束响应。如果仅仅输出了响应信息，但还没有 <code>flush</code> 到客户端，则会放弃输出的响应信息，而使用错误页面代替。方法中调用 <code>write_error</code> 方法便是输出错误页面，通过在 <code>RequestHandler</code> 子类中覆写这个方法可以自定义错误页面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_error</span><span class="params">(self, status_code=<span class="number">500</span>, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._headers_written:</span><br><span class="line">        gen_log.error(<span class="string">"Cannot send error response after headers written"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._finished:</span><br><span class="line">            self.finish()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self.clear()</span><br><span class="line"></span><br><span class="line">    reason = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'exc_info'</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        exception = kwargs[<span class="string">'exc_info'</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> isinstance(exception, HTTPError) <span class="keyword">and</span> exception.reason:</span><br><span class="line">            reason = exception.reason</span><br><span class="line">    self.set_status(status_code, reason=reason)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.write_error(status_code, **kwargs)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        app_log.error(<span class="string">"Uncaught exception in write_error"</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._finished:</span><br><span class="line">        self.finish()</span><br></pre></td></tr></table></figure><h4 id="write-error-method"><a href="#write-error-method" class="headerlink" title="write_error method"></a>write_error method</h4><p><strong>用户可以覆写 <code>write_error</code> 方法来输出自定义的错误页面。</strong> 在方法中可以调用诸如 <code>write</code>, <code>render</code>, <code>set_header</code> 等一系列辅助响应输出的方法。如果错误是由未捕获的异常（包括 HTTP Error）导致的，那么一个 <code>exc_info</code> 元组应包含在关键字参数 <code>kwargs[&quot;exc_info&quot;]</code> 中。另外需要注意的是这个异常可能个并不是 “当前异常”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_error</span><span class="params">(self, status_code, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Override to implement custom error pages.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ``write_error`` may call `write`, `render`, `set_header`, etc</span></span><br><span class="line"><span class="string">    to produce output as usual.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If this error was caused by an uncaught exception (including</span></span><br><span class="line"><span class="string">    HTTPError), an ``exc_info`` triple will be available as</span></span><br><span class="line"><span class="string">    ``kwargs["exc_info"]``.  Note that this exception may not be</span></span><br><span class="line"><span class="string">    the "current" exception for purposes of methods like</span></span><br><span class="line"><span class="string">    ``sys.exc_info()`` or ``traceback.format_exc``.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> self.settings.get(<span class="string">"serve_traceback"</span>) <span class="keyword">and</span> <span class="string">"exc_info"</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        <span class="comment"># in debug mode, try to send a traceback</span></span><br><span class="line">        self.set_header(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> traceback.format_exception(*kwargs[<span class="string">"exc_info"</span>]):</span><br><span class="line">            self.write(line)</span><br><span class="line">        self.finish()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.finish(<span class="string">"&lt;html&gt;&lt;title&gt;%(code)d: %(message)s&lt;/title&gt;"</span></span><br><span class="line">                    <span class="string">"&lt;body&gt;%(code)d: %(message)s&lt;/body&gt;&lt;/html&gt;"</span> % &#123;</span><br><span class="line">                        <span class="string">"code"</span>: status_code,</span><br><span class="line">                        <span class="string">"message"</span>: self._reason,</span><br><span class="line">                    &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RequestHandler-异常处理&quot;&gt;&lt;a href=&quot;#RequestHandler-异常处理&quot; class=&quot;headerlink&quot; title=&quot;RequestHandler 异常处理&quot;&gt;&lt;/a&gt;RequestHandler 异常处理&lt;/h3&gt;&lt;p&gt;之前的笔记中已经提到过 &lt;code&gt;RequestHandler&lt;/code&gt; 的 &lt;code&gt;_execute&lt;/code&gt; 方法完全处于一个异常处理块中，所以异常处理入口 &lt;code&gt;_handle_request_exception&lt;/code&gt; 便在这里开始处理流程。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_handle_request_exception&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, e)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; isinstance(e, Finish):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# Not an error; just finish the request without logging.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; self._finished:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.finish()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.log_exception(*sys.exc_info())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; self._finished:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# Extra errors after the request has been finished should&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# be logged, but there is no reason to continue to try and&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# send a response.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; isinstance(e, HTTPError):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; e.status_code &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; httputil.responses &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; e.reason:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            gen_log.error(&lt;span class=&quot;string&quot;&gt;&quot;Bad HTTP status code: %d&quot;&lt;/span&gt;, e.status_code)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.send_error(&lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;, exc_info=sys.exc_info())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.send_error(e.status_code, exc_info=sys.exc_info())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.send_error(&lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;, exc_info=sys.exc_info())&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由前面的代码可以看到，与请求异常处理相关的自定义异常类型是 &lt;code&gt;Finish&lt;/code&gt;、&lt;code&gt;HTTPError&lt;/code&gt;，方法有 &lt;code&gt;log_exception&lt;/code&gt; 和 &lt;code&gt;send_error&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;_handle_request_exception&lt;/code&gt; 的处理流程中，除去 &lt;code&gt;Finish&lt;/code&gt; 类型外的所有异常都需要调用 &lt;code&gt;log_exception&lt;/code&gt; 方法来记录异常信息。如果响应没有结束，还需要尝试向客户端响应异常信息（只所以说是 “尝试”，是因为我们无法修改已经 &lt;code&gt;flush&lt;/code&gt; 到客户端的数据，只能在尚未 &lt;code&gt;flush&lt;/code&gt; 过数据时响应异常信息）。&lt;/p&gt;
&lt;h4 id=&quot;Finish&quot;&gt;&lt;a href=&quot;#Finish&quot; class=&quot;headerlink&quot; title=&quot;Finish&quot;&gt;&lt;/a&gt;Finish&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Finish&lt;/code&gt; 是一个特别的自定义异常类型，为应用程序提供一种提前结束请求的方式。因抛出 &lt;code&gt;Finish&lt;/code&gt; 而结束的请求不会输出一个异常响应（即不被视为请求处理异常）。如代码中所示，在 &lt;code&gt;RequestHandler&lt;/code&gt; 请求处理过程中抛出 &lt;code&gt;Finish&lt;/code&gt; 时，如果没有调用 &lt;code&gt;finish&lt;/code&gt; 则调用 &lt;code&gt;finish&lt;/code&gt; 结束请求，并立即返回，结束处理流程。这样一来后续与异常处理相关的方法就不会被调用，也就不会影响到已经 &lt;code&gt;flush&lt;/code&gt; 的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="Finish" scheme="http://yoursite.com/tags/Finish/"/>
    
      <category term="HTTPError" scheme="http://yoursite.com/tags/HTTPError/"/>
    
      <category term="log_exception" scheme="http://yoursite.com/tags/log-exception/"/>
    
      <category term="send_error" scheme="http://yoursite.com/tags/send-error/"/>
    
      <category term="write_error" scheme="http://yoursite.com/tags/write-error/"/>
    
  </entry>
  
  <entry>
    <title>tornado.web 消息响应实现</title>
    <link href="http://yoursite.com/2016/01/29/tornado.web_response/"/>
    <id>http://yoursite.com/2016/01/29/tornado.web_response/</id>
    <published>2016-01-29T14:25:01.000Z</published>
    <updated>2019-10-22T15:53:03.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这部分笔记主要是简单分析 Tornado 中 Http 响应相关的代码，但没有涉及到安全相关的 cookie 实现以及 HTML 模板引擎。</p><h3 id="HTTPConnection"><a href="#HTTPConnection" class="headerlink" title="HTTPConnection"></a>HTTPConnection</h3><p><code>tornado.httputil</code> 模块定义了 Tornado 的响应接口 <code>HTTPConnection</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPConnection</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Applications use this interface to write their responses.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionadded:: 4.0</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_headers</span><span class="params">(self, start_line, headers, chunk=None, callback=None)</span>:</span></span><br><span class="line">        <span class="string">"""Write an HTTP header block.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :arg start_line: a `.RequestStartLine` or `.ResponseStartLine`.</span></span><br><span class="line"><span class="string">        :arg headers: a `.HTTPHeaders` instance.</span></span><br><span class="line"><span class="string">        :arg chunk: the first (optional) chunk of data.  This is an optimization</span></span><br><span class="line"><span class="string">            so that small responses can be written in the same call as their</span></span><br><span class="line"><span class="string">            headers.</span></span><br><span class="line"><span class="string">        :arg callback: a callback to be run when the write is complete.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns a `.Future` if no callback is given.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, chunk, callback=None)</span>:</span></span><br><span class="line">        <span class="string">"""Writes a chunk of body data.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The callback will be run when the write is complete.  If no callback</span></span><br><span class="line"><span class="string">        is given, returns a Future.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Indicates that the last body data has been written.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br></pre></td></tr></table></figure><p>之前已经分析过的 <code>tornado.http1connection.HTTP1Connection</code> 是该接口的实现（另一个实现是 <code>tornado.wsgi._WSGIConnection</code>）。上述定义的三个接口方法注释很完整，简单来说：</p><ol><li><p><code>write_headers</code> 方法用于写 Http 消息头，一次响应应该只调用一次。其中可选参数 <code>chunk</code>，是消息体数据，在响应数据较少的情况下灰常有用，很多时候我们都是调用一次该方法完成写消息头和消息体，而不会去单独调用 <code>write</code> 方法单独写消息体。</p></li><li><p><code>write</code> 方法用于写消息体。</p></li><li><p><code>finish</code> 方法用于告诉接口此次请求响应结束。</p></li></ol><a id="more"></a><h3 id="HTTP1Connection"><a href="#HTTP1Connection" class="headerlink" title="HTTP1Connection"></a>HTTP1Connection</h3><h4 id="write-headers-write"><a href="#write-headers-write" class="headerlink" title="write_headers/write"></a>write_headers/write</h4><p><code>write</code> 方法的实现基本上就是 <code>write_headers</code> 的一部分，这里就把二者的代码放在一起分析。相关代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_headers</span><span class="params">(self, start_line, headers, chunk=None, callback=None)</span>:</span></span><br><span class="line">    <span class="string">"""Implements `.HTTPConnection.write_headers`."""</span></span><br><span class="line">    <span class="keyword">if</span> self.is_client:</span><br><span class="line">        self._request_start_line = start_line</span><br><span class="line">        <span class="comment"># Client requests with a non-empty body must have either a</span></span><br><span class="line">        <span class="comment"># Content-Length or a Transfer-Encoding.</span></span><br><span class="line">        <span class="comment"># 不检查是否 Http/1.0 是不完备的。</span></span><br><span class="line">        self._chunking_output = (</span><br><span class="line">            start_line.method <span class="keyword">in</span> (<span class="string">'POST'</span>, <span class="string">'PUT'</span>, <span class="string">'PATCH'</span>) <span class="keyword">and</span></span><br><span class="line">            <span class="string">'Content-Length'</span> <span class="keyword">not</span> <span class="keyword">in</span> headers <span class="keyword">and</span></span><br><span class="line">            <span class="string">'Transfer-Encoding'</span> <span class="keyword">not</span> <span class="keyword">in</span> headers)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._response_start_line = start_line</span><br><span class="line">        <span class="comment"># 对于 HTTP/1.0 ``self._chunking_output=False``，不支持分块传输编码。</span></span><br><span class="line">        self._chunking_output = (</span><br><span class="line">            <span class="comment"># <span class="doctag">TODO:</span> should this use</span></span><br><span class="line">            <span class="comment"># self._request_start_line.version or</span></span><br><span class="line">            <span class="comment"># start_line.version?</span></span><br><span class="line">            self._request_start_line.version == <span class="string">'HTTP/1.1'</span> <span class="keyword">and</span></span><br><span class="line">            <span class="comment"># 304 responses have no body (not even a zero-length body), and so</span></span><br><span class="line">            <span class="comment"># should not have either Content-Length or Transfer-Encoding.</span></span><br><span class="line">            <span class="comment"># headers.</span></span><br><span class="line">            start_line.code != <span class="number">304</span> <span class="keyword">and</span></span><br><span class="line">            <span class="comment"># No need to chunk the output if a Content-Length is specified.</span></span><br><span class="line">            <span class="string">'Content-Length'</span> <span class="keyword">not</span> <span class="keyword">in</span> headers <span class="keyword">and</span></span><br><span class="line">            <span class="comment"># Applications are discouraged from touching Transfer-Encoding,</span></span><br><span class="line">            <span class="comment"># but if they do, leave it alone.</span></span><br><span class="line">            <span class="string">'Transfer-Encoding'</span> <span class="keyword">not</span> <span class="keyword">in</span> headers)</span><br><span class="line">        <span class="comment"># If a 1.0 client asked for keep-alive, add the header.</span></span><br><span class="line">        <span class="comment"># HTTP/1.1 默认就是持久化连接，不需要单独指定。</span></span><br><span class="line">        <span class="comment"># 假设客户端请求使用 HTTP/1.0 和 `Connection:Keep-Alive`，服务端响应时没有指定</span></span><br><span class="line">        <span class="comment"># `Content-Length` （比如在 handler 中多次调用 flush 方法）,那么响应数据就无法</span></span><br><span class="line">        <span class="comment"># 判断边界，代码中应该对这个条件做特别处理。</span></span><br><span class="line">        <span class="keyword">if</span> (self._request_start_line.version == <span class="string">'HTTP/1.0'</span> <span class="keyword">and</span></span><br><span class="line">            (self._request_headers.get(<span class="string">'Connection'</span>, <span class="string">''</span>).lower()</span><br><span class="line">             == <span class="string">'keep-alive'</span>)):</span><br><span class="line">            headers[<span class="string">'Connection'</span>] = <span class="string">'Keep-Alive'</span></span><br><span class="line">    <span class="keyword">if</span> self._chunking_output:</span><br><span class="line">        headers[<span class="string">'Transfer-Encoding'</span>] = <span class="string">'chunked'</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> self.is_client <span class="keyword">and</span></span><br><span class="line">        (self._request_start_line.method == <span class="string">'HEAD'</span> <span class="keyword">or</span></span><br><span class="line">         start_line.code == <span class="number">304</span>)):</span><br><span class="line">        self._expected_content_remaining = <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'Content-Length'</span> <span class="keyword">in</span> headers:</span><br><span class="line">        self._expected_content_remaining = int(headers[<span class="string">'Content-Length'</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._expected_content_remaining = <span class="literal">None</span></span><br><span class="line">    lines = [utf8(<span class="string">"%s %s %s"</span> % start_line)]</span><br><span class="line">    <span class="comment"># 通过 add 添加的响应头会输出多个，比如：“Set-Cookie” 响应头。</span></span><br><span class="line">    lines.extend([utf8(n) + <span class="string">b": "</span> + utf8(v) <span class="keyword">for</span> n, v <span class="keyword">in</span> headers.get_all()])</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b'\n'</span> <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Newline in header: '</span> + repr(line))</span><br><span class="line">    future = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> self.stream.closed():</span><br><span class="line">        future = self._write_future = Future()</span><br><span class="line">        future.set_exception(iostream.StreamClosedError())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># "写回调" 是一个实例字段 `_write_callback`，当上一次写操作还没有回调时就再次执行</span></span><br><span class="line">        <span class="comment"># 写操作，那么上一次写操作的回调将被放弃（callback is not None）</span></span><br><span class="line">        <span class="keyword">if</span> callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self._write_callback = stack_context.wrap(callback)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 没有 callback 时，返回 Future(self._write_future)</span></span><br><span class="line">            future = self._write_future = Future()</span><br><span class="line">        <span class="comment"># Headers</span></span><br><span class="line">        data = <span class="string">b"\r\n"</span>.join(lines) + <span class="string">b"\r\n\r\n"</span></span><br><span class="line">        <span class="comment"># message-body</span></span><br><span class="line">        <span class="keyword">if</span> chunk:</span><br><span class="line">            data += self._format_chunk(chunk)</span><br><span class="line">        self._pending_write = self.stream.write(data)</span><br><span class="line">        self._pending_write.add_done_callback(self._on_write_complete)</span><br><span class="line">    <span class="keyword">return</span> future</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, chunk, callback=None)</span>:</span></span><br><span class="line">    <span class="string">"""Implements `.HTTPConnection.write`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    For backwards compatibility is is allowed but deprecated to</span></span><br><span class="line"><span class="string">    skip `write_headers` and instead call `write()` with a</span></span><br><span class="line"><span class="string">    pre-encoded header block.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    future = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> self.stream.closed():</span><br><span class="line">        future = self._write_future = Future()</span><br><span class="line">        self._write_future.set_exception(iostream.StreamClosedError())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self._write_callback = stack_context.wrap(callback)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            future = self._write_future = Future()</span><br><span class="line">        self._pending_write = self.stream.write(self._format_chunk(chunk))</span><br><span class="line">        self._pending_write.add_done_callback(self._on_write_complete)</span><br><span class="line">    <span class="keyword">return</span> future</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_on_write_complete</span><span class="params">(self, future)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._write_callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        callback = self._write_callback</span><br><span class="line">        self._write_callback = <span class="literal">None</span></span><br><span class="line">        self.stream.io_loop.add_callback(callback)</span><br><span class="line">    <span class="keyword">if</span> self._write_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        future = self._write_future</span><br><span class="line">        self._write_future = <span class="literal">None</span></span><br><span class="line">        future.set_result(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_format_chunk</span><span class="params">(self, chunk)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._expected_content_remaining <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self._expected_content_remaining -= len(chunk)</span><br><span class="line">        <span class="keyword">if</span> self._expected_content_remaining &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># Close the stream now to stop further framing errors.</span></span><br><span class="line">            self.stream.close()</span><br><span class="line">            <span class="keyword">raise</span> httputil.HTTPOutputError(</span><br><span class="line">                <span class="string">"Tried to write more data than Content-Length"</span>)</span><br><span class="line">    <span class="keyword">if</span> self._chunking_output <span class="keyword">and</span> chunk:</span><br><span class="line">        <span class="comment"># Don't write out empty chunks because that means END-OF-STREAM</span></span><br><span class="line">        <span class="comment"># with chunked encoding</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># Each chunk: the number of octets of the data(hex number) + CRLF + chunk data + CRLF</span></span><br><span class="line">        <span class="keyword">return</span> utf8(<span class="string">"%x"</span> % len(chunk)) + <span class="string">b"\r\n"</span> + chunk + <span class="string">b"\r\n"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br></pre></td></tr></table></figure><p>上述代码逻辑不复杂，但是有几点需要注意一下：</p><ol><li><p><code>self._chunking_output</code> 是分块传输编码 <code>Transfer-Encoding: chunked</code>  启用标识，仅在 Http/1.1 提供。<strong>对于客户端请求而言，不检查是否 HTTP/1.0 是不完备的，会导致问题。</strong></p></li><li><p><code>Connection:Keep-Alive</code> 响应头在 HTTP/1.1 是默认的，不需要特别设置，而 HTTP/1.0 则需要显示设置。所以服务端响应时要根据请求的 HTTP 版本及 <code>Connection</code> 值来决定是否发送 <code>Connection:Keep-Alive</code>。这里其实有一个问题：<strong>假设客户端请求使用 HTTP/1.0 和 <code>Connection:Keep-Alive</code>，服务端响应时没有指定 <code>Content-Length</code> （比如在 handler 中多次调用 flush 方法）,那么响应数据就无法判断边界，代码中没有对这个条件做特别处理。</strong>两个解决方案：1. 检测到这种情况时响应非 Keep-Alive 模式；2. 只支持 HTTP/1.1 响应。</p></li><li><p><code>write_headers</code> 调用时没有指定 <code>callback</code> 时返回 Future 对象，否则返回 None，且在写操作完成后执行 <code>callback</code>。</p></li><li><p>连续执行两次带 <code>callback</code> 的写操作，由于 <code>callback</code> 保存在实例字段 <code>_write_callback</code>中，当上一次写操作还没有回调时就再次执行下一次写操作，那么上一次的 <code>callback</code> 将被放弃。</p></li></ol><p><strong>注：</strong>octet 总是指 8bit，byte 通常情况下也是指 8bit，但是准确来说， byte 指的是计算机 CPU 可以独立寻址的最小内存单位。曾几何时，有些计算机的寻址并不是 8bit，不过现在的计算机几乎 octet 等价于 byte，仅当你要强调准确的 8bit 时就应该使用 octet 而不是 byte。</p><h4 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Implements `.HTTPConnection.finish`."""</span></span><br><span class="line">    <span class="keyword">if</span> (self._expected_content_remaining <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span></span><br><span class="line">            self._expected_content_remaining != <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">            <span class="keyword">not</span> self.stream.closed()):</span><br><span class="line">        self.stream.close()</span><br><span class="line">        <span class="keyword">raise</span> httputil.HTTPOutputError(</span><br><span class="line">            <span class="string">"Tried to write %d bytes less than Content-Length"</span> %</span><br><span class="line">            self._expected_content_remaining)</span><br><span class="line">    <span class="keyword">if</span> self._chunking_output:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stream.closed():</span><br><span class="line">            <span class="comment"># `Transfer-Encoding:chunked`: The terminating chunk is a</span></span><br><span class="line">            <span class="comment"># regular chunk, with the exception that its length is zero.</span></span><br><span class="line">            self._pending_write = self.stream.write(<span class="string">b"0\r\n\r\n"</span>)</span><br><span class="line">            self._pending_write.add_done_callback(self._on_write_complete)</span><br><span class="line">    self._write_finished = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># If the app finished the request while we're still reading,</span></span><br><span class="line">    <span class="comment"># divert any remaining data away from the delegate and</span></span><br><span class="line">    <span class="comment"># close the connection when we're done sending our response.</span></span><br><span class="line">    <span class="comment"># Closing the connection is the only way to avoid reading the</span></span><br><span class="line">    <span class="comment"># whole input body.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._read_finished:</span><br><span class="line">        self._disconnect_on_finish = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># No more data is coming, so instruct TCP to send any remaining</span></span><br><span class="line">    <span class="comment"># data immediately instead of waiting for a full packet or ack.</span></span><br><span class="line">    <span class="comment"># 关闭 Nagle 算法，效果相当于让 socket 立即 flush 数据到客户端，随后将在</span></span><br><span class="line">    <span class="comment"># `_finish_request` 中恢复 Nagle 算法。</span></span><br><span class="line">    self.stream.set_nodelay(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> self._pending_write <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self._finish_request(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 最后一次挂起的写操作完成后回调 `_finish_request` 方法。</span></span><br><span class="line">        self._pending_write.add_done_callback(self._finish_request)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_finish_request</span><span class="params">(self, future)</span>:</span></span><br><span class="line">    <span class="comment"># ``close`` 中还会执行一次，调整到后面执行更好</span></span><br><span class="line">    self._clear_callbacks()</span><br><span class="line">    <span class="comment"># 服务端不需要支持长连接时，执行关闭操作</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.is_client <span class="keyword">and</span> self._disconnect_on_finish:</span><br><span class="line">        self.close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># Turn Nagle's algorithm back on, leaving the stream in its</span></span><br><span class="line">    <span class="comment"># default state for the next request.</span></span><br><span class="line">    self.stream.set_nodelay(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._finish_future.done():</span><br><span class="line">        self._finish_future.set_result(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_clear_callbacks</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Clears the callback attributes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This allows the request handler to be garbage collected more</span></span><br><span class="line"><span class="string">    quickly in CPython by breaking up reference cycles.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self._write_callback = <span class="literal">None</span></span><br><span class="line">    self._write_future = <span class="literal">None</span></span><br><span class="line">    self._close_callback = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> self.stream <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.stream.set_close_callback(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.stream <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.stream.close()</span><br><span class="line">    self._clear_callbacks()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._finish_future.done():</span><br><span class="line">        self._finish_future.set_result(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><code>finish</code> 方法基本上就是做了这几件事：</p><ol><li>检查指定长度的消息体是否发送完成或者在 <code>Transfer-Encoding:chunked</code> 模式下发送结束块。</li><li>如果在请求数据读取完成之前就响应完成就直接关闭连接。</li><li>设置响应结束标识 <code>_write_finished</code>，立即 flush 数据到客户端。</li><li>立即执行 <code>_finish_request</code> 方法或者等挂起的写操作完成后执行。</li></ol><h3 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h3><p><code>languageRequestHandler</code> 与响应直接相关的方法是 <code>flush</code> 和 <code>finish</code>，这两个方法内部都是委托 <code>HTTP1Connection</code> 来执行。</p><h4 id="finish-1"><a href="#finish-1" class="headerlink" title="finish"></a>finish</h4><p><code>finish</code> 方法用来结束此次请求和响应。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self, chunk=None)</span>:</span></span><br><span class="line">    <span class="string">"""Finishes this response, ending the HTTP request."""</span></span><br><span class="line">    <span class="keyword">if</span> self._finished:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"finish() called twice.  May be caused "</span></span><br><span class="line">                           <span class="string">"by using async operations without the "</span></span><br><span class="line">                           <span class="string">"@asynchronous decorator."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> chunk <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.write(chunk)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Automatically support ETags and add the Content-Length header if</span></span><br><span class="line">    <span class="comment"># we have not flushed any content yet.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._headers_written:</span><br><span class="line">        <span class="keyword">if</span> (self._status_code == <span class="number">200</span> <span class="keyword">and</span></span><br><span class="line">            self.request.method <span class="keyword">in</span> (<span class="string">"GET"</span>, <span class="string">"HEAD"</span>) <span class="keyword">and</span></span><br><span class="line">                <span class="string">"Etag"</span> <span class="keyword">not</span> <span class="keyword">in</span> self._headers):</span><br><span class="line">            self.set_etag_header()</span><br><span class="line">            <span class="keyword">if</span> self.check_etag_header():</span><br><span class="line">                self._write_buffer = []</span><br><span class="line">                self.set_status(<span class="number">304</span>)</span><br><span class="line">        <span class="keyword">if</span> self._status_code == <span class="number">304</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">not</span> self._write_buffer, <span class="string">"Cannot send body with 304"</span></span><br><span class="line">            self._clear_headers_for_304()</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">"Content-Length"</span> <span class="keyword">not</span> <span class="keyword">in</span> self._headers:</span><br><span class="line">            content_length = sum(len(part) <span class="keyword">for</span> part <span class="keyword">in</span> self._write_buffer)</span><br><span class="line">            self.set_header(<span class="string">"Content-Length"</span>, content_length)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> hasattr(self.request, <span class="string">"connection"</span>):</span><br><span class="line">        <span class="comment"># Now that the request is finished, clear the callback we</span></span><br><span class="line">        <span class="comment"># set on the HTTPConnection (which would otherwise prevent the</span></span><br><span class="line">        <span class="comment"># garbage collection of the RequestHandler when there</span></span><br><span class="line">        <span class="comment"># are keepalive connections)</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># <span class="doctag">NOTE:</span> 这里注释说请求处理完成时将 `HTTPConnection` 的连接关闭回调设置为 None，</span></span><br><span class="line">        <span class="comment"># 否则长连接情况下当前 `RequestHandler` 实例由于被连接引用而不能被及时垃圾回收。</span></span><br><span class="line">        <span class="comment"># 这个问题应该是 Tornado v4.0 之前由 `HTTPConnection` 处理 “连接保持”造成的，</span></span><br><span class="line">        <span class="comment"># 之后的版本由于分离出 `HTTP1ServerConnection` 来处理连接保持已经不存在这个问题：</span></span><br><span class="line">        <span class="comment"># 每次请求都是单独生成一个 `HTTP1Connection` 实例处理，并且在请求处理完成后会调用</span></span><br><span class="line">        <span class="comment"># `_clear_callbacks` 方法自动清空回调（参见 `_read_message` 的 finally 块）。</span></span><br><span class="line">        self.request.connection.set_close_callback(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    self.flush(include_footers=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 按 `HttpServerRequest.finish` 的注释，该方法在 v4.0 已经放弃，而建议直接使用</span></span><br><span class="line">    <span class="comment"># `request.connection.finish` 方法。</span></span><br><span class="line">    self.request.finish()</span><br><span class="line">    self._log()</span><br><span class="line">    self._finished = <span class="literal">True</span></span><br><span class="line">    self.on_finish()</span><br><span class="line">    <span class="comment"># Break up a reference cycle between this handler and the</span></span><br><span class="line">    <span class="comment"># _ui_module closures to allow for faster GC on CPython.</span></span><br><span class="line">    self.ui = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><code>finish</code> 时如果之前没有 <code>flush</code> 过数据则会自动为响应增加 “Etag” 和 “Content-Length” 头域，并会尝试比较新增的 “Etag” 与请求的 “If-None-Match” 值（），若是相同则会修改默认的响应编码 <strong>200</strong> 为 <strong>304</strong>。<code>finish</code> 会调用 <code>flush</code> 方法将响应数据发送到客户端，接着执行一些资源清理和调用 “模板” 方法。</p><p><strong>注：</strong></p><ol><li><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19" target="_blank" rel="noopener">“Etag”（实体标签， rfc2616）</a>是 HTTP/1.1 协议的一部分，但不是必须的头域（可选），HTTP/1.1 协议规范从未规定过其生成方法。“Etag” 是 HTTP 提供的若干缓存验证机制中的一种，允许客户端进行缓存协商。通常 “Etag” 类似资源内容的指纹，服务端响应时返回资源的 “Etag” 值，客户端可以决定是否缓存这个资源和 “Etag” 值。之后客户端想再请求相同 URL 时，<strong>通常</strong>会把缓存的 “Etag” 值放在 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.26" target="_blank" rel="noopener">“Etag/”</a> 字段中发送给服务端。服务端可能在接收请求后比较客户端的 “If-None-Match” 与 服务端 “Etag” 值，如果匹配，就意味着资源未发生变化，服务器就会发送一个 <strong>HTTP 304(GET/HEAD) 或者 412(other request methods)</strong> 状态码，而不需要再次发送响应消息体。反之，服务端会发送一个包含消息体的完整响应。前面说 <strong>“通常”</strong>，是因为 HTTP 规范中还定义了 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.24" target="_blank" rel="noopener">“If-Match”（不匹配时响应 HTTP 412）</a> 字段，rfc2616 上说的很不明确，通常不推荐使用，至少 Tornado 目前仅仅支持 “GET/HEAD” 与 “Etag/If-None-Match”。关于 “If-Match” 的问题，我在 stackoverflow 查到一个资料说是： <a href="http://stackoverflow.com/questions/14303295/get-request-with-if-match-and-etags" target="_blank" rel="noopener">不推荐使用</a>，还有一个对 rfc2616 <a href="http://stackoverflow.com/questions/2157124/http-if-none-match-vs-if-match/2157609#2157609" target="_blank" rel="noopener">“If-Match”</a> 的总结。</p></li><li><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.29" target="_blank" rel="noopener">Last-Modified</a> 实体头字段，该字段用于指示资源最后修改时间，在服务端响应时发送给客户端，在之后客户端请求相同 URL 时会把这个字段值放在 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25" target="_blank" rel="noopener">If-Modified-Since</a> 或者 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.28" target="_blank" rel="noopener">If-Unmodified-Since</a>请求头中发送给服务端。服务端将资源当前修改时间与该值进行比较以确定是否响应 HTTP 304。</p></li><li><p>“Etag” 比 “Last-Modified” 控制的更准确，能够解决一些 “Last-Modified” 无法解决的问题，比如：1. 周期性修改的文件，但内容不改变；2. “Last-Modified” 只能精确到秒；3. 某些时候可能无法准确得到文件的修改时间。</p></li><li><p>这里有人做了一个 <a href="https://code.google.com/archive/p/http-headers-status/" target="_blank" rel="noopener">http headers status</a> 的草图，看图更清晰。</p></li></ol><h4 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flush</span><span class="params">(self, include_footers=False, callback=None)</span>:</span></span><br><span class="line">    <span class="string">"""Flushes the current output buffer to the network.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The ``callback`` argument, if given, can be used for flow control:</span></span><br><span class="line"><span class="string">    it will be run when all flushed data has been written to the socket.</span></span><br><span class="line"><span class="string">    Note that only one flush callback can be outstanding at a time;</span></span><br><span class="line"><span class="string">    if another flush occurs before the previous flush's callback</span></span><br><span class="line"><span class="string">    has been run, the previous callback will be discarded.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionchanged:: 4.0</span></span><br><span class="line"><span class="string">       Now returns a `.Future` if no callback is given.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    chunk = <span class="string">b""</span>.join(self._write_buffer)</span><br><span class="line">    self._write_buffer = []</span><br><span class="line">    <span class="comment"># 响应头只会写一次，flush 操作以后再修改的响应头是不会发送到客户端的，但也不会抛异常，</span></span><br><span class="line">    <span class="comment"># 这个与其他的一些 web framework 抛异常的处理方式不一样。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._headers_written:</span><br><span class="line">        self._headers_written = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> transform <span class="keyword">in</span> self._transforms:</span><br><span class="line">            self._status_code, self._headers, chunk = \</span><br><span class="line">                transform.transform_first_chunk(</span><br><span class="line">                    self._status_code, self._headers, chunk, include_footers)</span><br><span class="line">        <span class="comment"># Ignore the chunk and only write the headers for HEAD requests</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">"HEAD"</span>:</span><br><span class="line">            chunk = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Finalize the cookie headers (which have been stored in a side</span></span><br><span class="line">        <span class="comment"># object so an outgoing cookie could be overwritten before it</span></span><br><span class="line">        <span class="comment"># is sent).</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self, <span class="string">"_new_cookie"</span>):</span><br><span class="line">            <span class="keyword">for</span> cookie <span class="keyword">in</span> self._new_cookie.values():</span><br><span class="line">                self.add_header(<span class="string">"Set-Cookie"</span>, cookie.OutputString(<span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># NOTE：在 Keep-Alive 模式下（`Connection: Keep-Alive`），判断消息边界只能通过</span></span><br><span class="line">        <span class="comment"># `Content-Length` 或者 `Transfer-Encoding: chunked`，后者仅在 Http/1.1</span></span><br><span class="line">        <span class="comment"># 提供。若客户端请求是 Http/1.0，在没有指定 `Content-Length` 头域的情况下，按照</span></span><br><span class="line">        <span class="comment"># 目前实现主动多次调用 `flush(include_footers=False)` 方法写数据，</span></span><br><span class="line">        <span class="comment"># `write_headers` 中没法支持 chunked，会有问题。看了一下之后的代码，这里已经不依赖</span></span><br><span class="line">        <span class="comment"># `self.request.version`，`write_headers` 强制启用 Http/1.1。</span></span><br><span class="line">        start_line = httputil.ResponseStartLine(self.request.version,</span><br><span class="line">                                                self._status_code,</span><br><span class="line">                                                self._reason)</span><br><span class="line">        <span class="keyword">return</span> self.request.connection.write_headers(</span><br><span class="line">            start_line, self._headers, chunk, callback=callback)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> transform <span class="keyword">in</span> self._transforms:</span><br><span class="line">            chunk = transform.transform_chunk(chunk, include_footers)</span><br><span class="line">        <span class="comment"># Ignore the chunk and only write the headers for HEAD requests</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method != <span class="string">"HEAD"</span>:</span><br><span class="line">            <span class="keyword">return</span> self.request.connection.write(chunk, callback=callback)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            future = Future()</span><br><span class="line">            future.set_result(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">return</span> future</span><br></pre></td></tr></table></figure><p><code>flush</code> 方法根据是否需要写 headers 来决定调用 <code>Http1Connection</code> 实例的 <code>write_headers</code>  方法或者 <code>write</code> 方法。需要注意的是，响应的 HTTP 版本与请求的 HTTP 版本是一致的，这样 HTTP/1.0 时一次请求多次调用 <code>flush</code> 可能会因为没有提前指定 <code>Content-Length</code> 而导致 “Keep-Alive” 时数据无边界问题（HTTP/1.1 支持分块传输编码便不会有这个问题，在前面分析 <code>Http1Connection</code> 的 <code>write_headers</code> 方法时有解释）。</p><p>Cookie 的设置是通过响应头 “Set-Cookie” 实现的，代码中将每一个 cookie 通过 <code>self.add_header(&quot;Set-Cookie&quot;, cookie.OutputString(None))</code> 方法加入到响应头 “Set-Cookie”，<strong>最终会有多个 “Set-Cookie” 响应头输出到客户端。</strong></p><p>还有就是 <code>OutputTransform</code> 的使用，<code>OutputTransform</code> 定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutputTransform</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""A transform modifies the result of an HTTP request (e.g., GZip encoding)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Applications are not expected to create their own OutputTransforms</span></span><br><span class="line"><span class="string">    or interact with them directly; the framework chooses which transforms</span></span><br><span class="line"><span class="string">    (if any) to apply.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform_first_chunk</span><span class="params">(self, status_code, headers, chunk, finishing)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> status_code, headers, chunk</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform_chunk</span><span class="params">(self, chunk, finishing)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> chunk</span><br></pre></td></tr></table></figure><p><code>OutputTransform</code> 定义了转换响应数据的转换器基类型，因为 HTTP 响应头和消息体格式的差异，该基类型定义了两个方法 <code>transform_first_chunk</code> 和 <code>transform_chunk</code>，分别对响应头和消息体进行数据转换。我们可以自定义实现自己的转化器，在 <code>Application</code> 初始化时传递给它，目前框架默认实现的转换器是 <code>GZipContentEncoding</code>，仅在没有指定任何转换器时根据设置尝试使用，下面是 <code>Application</code> 构造方法的相关代码代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handlers=None, default_host=<span class="string">""</span>, transforms=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             **settings)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> transforms <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.transforms = []</span><br><span class="line">        <span class="keyword">if</span> settings.get(<span class="string">"compress_response"</span>) <span class="keyword">or</span> settings.get(<span class="string">"gzip"</span>):</span><br><span class="line">            self.transforms.append(GZipContentEncoding)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.transforms = transforms</span><br><span class="line"></span><br><span class="line">    ……略……</span><br></pre></td></tr></table></figure><p><code>GZipContentEncoding</code> 实现对响应数据进行 gzip 压缩的功能，一般生产环境下 Tornado 进程不会直接位于请求最前端，所以可能不常使用。通常这个 gzip 压缩功能我都交给 Nginx 去做。</p><h4 id="header-methods"><a href="#header-methods" class="headerlink" title="header methods"></a>header methods</h4><p><code>clear</code> 方法，用来重置响应头，请求处理器在 <code>__init__</code> 调用该方法初始化响应头：默认的响应头有 “Server”，“Content-Type”，“Date”，状态码是 200。<code>set_default_headers</code> 方法是个模板方法，子类可以实现该方法来为每次请求添加其他的默认响应头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Resets all headers and content for this response."""</span></span><br><span class="line">    self._headers = httputil.HTTPHeaders(&#123;</span><br><span class="line">        <span class="string">"Server"</span>: <span class="string">"TornadoServer/%s"</span> % tornado.version,</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"text/html; charset=UTF-8"</span>,</span><br><span class="line">        <span class="string">"Date"</span>: httputil.format_timestamp(time.time()),</span><br><span class="line">    &#125;)</span><br><span class="line">    self.set_default_headers()</span><br><span class="line">    self._write_buffer = []</span><br><span class="line">    self._status_code = <span class="number">200</span></span><br><span class="line">    self._reason = httputil.responses[<span class="number">200</span>]</span><br></pre></td></tr></table></figure><p><code>set_header</code> 设置给定响应头，如果给定的 “datetime” 类型的值， Tornado 自动按照 HTTP 要求将其格式化。如果不是 “string”，Tornado 会将其转为 “string”，所有的值都会按照 utf8 编码。</p><p><code>add_header</code> 添加给定的响应头，与 <code>set_header</code> 不同，该方法可以被多次调用而为同一个响应头设置多个值。</p><p><code>clear_header</code> 清除给定的响应头，撤销前一个 “set_header” 调用，但不是撤销 “add_header” 调用（这个说的可能有点绕，具体可以看 <code>HttpHeader</code> 的实现代码。简单来说就是因为 <code>HttpHeader</code> 重写了 <code>__setitem__</code>  方法，<code>add_header</code> 绕过了重写的 <code>__setitem__</code> 方法，所以说不能通过 <code>clear_header</code> 中调用 del 操作撤销。）。</p><p><code>set_status</code> 和 <code>get_status</code> 用于设置和获取响应的状态码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_status</span><span class="params">(self, status_code, reason=None)</span>:</span></span><br><span class="line">    <span class="string">"""Sets the status code for our response.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :arg int status_code: Response status code. If ``reason`` is ``None``,</span></span><br><span class="line"><span class="string">        it must be present in `httplib.responses &lt;http.client.responses&gt;`.</span></span><br><span class="line"><span class="string">    :arg string reason: Human-readable reason phrase describing the status</span></span><br><span class="line"><span class="string">        code. If ``None``, it will be filled in from</span></span><br><span class="line"><span class="string">        `httplib.responses &lt;http.client.responses&gt;`.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self._status_code = status_code</span><br><span class="line">    <span class="keyword">if</span> reason <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self._reason = escape.native_str(reason)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._reason = httputil.responses[status_code]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"unknown status code %d"</span>, status_code)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_status</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Returns the status code for our response."""</span></span><br><span class="line">    <span class="keyword">return</span> self._status_code</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_header</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">    <span class="string">"""Sets the given response header name and value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If a datetime is given, we automatically format it according to the</span></span><br><span class="line"><span class="string">    HTTP specification. If the value is not a string, we convert it to</span></span><br><span class="line"><span class="string">    a string. All header values are then encoded as UTF-8.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self._headers[name] = self._convert_header_value(value)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_header</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">    <span class="string">"""Adds the given response header and value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Unlike `set_header`, `add_header` may be called multiple times</span></span><br><span class="line"><span class="string">    to return multiple values for the same header.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self._headers.add(name, self._convert_header_value(value))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clear_header</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="string">"""Clears an outgoing header, undoing a previous `set_header` call.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note that this method does not apply to multi-valued headers</span></span><br><span class="line"><span class="string">    set by `add_header`.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> self._headers:</span><br><span class="line">        <span class="keyword">del</span> self._headers[name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ASCII 0～31 的字符将视为非法的 Header 字符。后面有提到，比如如果允许 `\r\n` 字符，</span></span><br><span class="line"><span class="comment"># 便可能导致意外的 Header 注入(按照 Http 协议，Header 之间是以 `\r\n` 分割)。</span></span><br><span class="line">_INVALID_HEADER_CHAR_RE = re.compile(<span class="string">br"[\x00-\x1f]"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_convert_header_value</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(value, bytes_type):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">elif</span> isinstance(value, unicode_type):</span><br><span class="line">        value = value.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">elif</span> isinstance(value, numbers.Integral):</span><br><span class="line">        <span class="comment"># return immediately since we know the converted value will be safe</span></span><br><span class="line">        <span class="keyword">return</span> str(value)</span><br><span class="line">    <span class="keyword">elif</span> isinstance(value, datetime.datetime):</span><br><span class="line">        <span class="keyword">return</span> httputil.format_timestamp(value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">"Unsupported header value %r"</span> % value)</span><br><span class="line">    <span class="comment"># If \n is allowed into the header, it is possible to inject</span></span><br><span class="line">    <span class="comment"># additional headers or split the request. Also cap length to</span></span><br><span class="line">    <span class="comment"># prevent obviously erroneous values.</span></span><br><span class="line">    <span class="keyword">if</span> (len(value) &gt; <span class="number">4000</span> <span class="keyword">or</span></span><br><span class="line">            RequestHandler._INVALID_HEADER_CHAR_RE.search(value)):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"Unsafe header value %r"</span>, value)</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><h3 id="附：http-headers-status-图"><a href="#附：http-headers-status-图" class="headerlink" title="附：http-headers-status 图"></a>附：<a href="(https://code.google.com/archive/p/http-headers-status/">http-headers-status 图</a></h3><img src="/2016/01/29/tornado.web_response/http-headers-status.png">]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;这部分笔记主要是简单分析 Tornado 中 Http 响应相关的代码，但没有涉及到安全相关的 cookie 实现以及 HTML 模板引擎。&lt;/p&gt;
&lt;h3 id=&quot;HTTPConnection&quot;&gt;&lt;a href=&quot;#HTTPConnection&quot; class=&quot;headerlink&quot; title=&quot;HTTPConnection&quot;&gt;&lt;/a&gt;HTTPConnection&lt;/h3&gt;&lt;p&gt;&lt;code&gt;tornado.httputil&lt;/code&gt; 模块定义了 Tornado 的响应接口 &lt;code&gt;HTTPConnection&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HTTPConnection&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;Applications use this interface to write their responses.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    .. versionadded:: 4.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;write_headers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, start_line, headers, chunk=None, callback=None)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;Write an HTTP header block.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        :arg start_line: a `.RequestStartLine` or `.ResponseStartLine`.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        :arg headers: a `.HTTPHeaders` instance.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        :arg chunk: the first (optional) chunk of data.  This is an optimization&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;            so that small responses can be written in the same call as their&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;            headers.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        :arg callback: a callback to be run when the write is complete.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        Returns a `.Future` if no callback is given.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        &quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; NotImplementedError()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, chunk, callback=None)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;Writes a chunk of body data.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        The callback will be run when the write is complete.  If no callback&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        is given, returns a Future.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        &quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; NotImplementedError()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;finish&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;Indicates that the last body data has been written.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        &quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; NotImplementedError()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之前已经分析过的 &lt;code&gt;tornado.http1connection.HTTP1Connection&lt;/code&gt; 是该接口的实现（另一个实现是 &lt;code&gt;tornado.wsgi._WSGIConnection&lt;/code&gt;）。上述定义的三个接口方法注释很完整，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;write_headers&lt;/code&gt; 方法用于写 Http 消息头，一次响应应该只调用一次。其中可选参数 &lt;code&gt;chunk&lt;/code&gt;，是消息体数据，在响应数据较少的情况下灰常有用，很多时候我们都是调用一次该方法完成写消息头和消息体，而不会去单独调用 &lt;code&gt;write&lt;/code&gt; 方法单独写消息体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;write&lt;/code&gt; 方法用于写消息体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;finish&lt;/code&gt; 方法用于告诉接口此次请求响应结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="HTTPConnection" scheme="http://yoursite.com/tags/HTTPConnection/"/>
    
      <category term="HTTP1Connection" scheme="http://yoursite.com/tags/HTTP1Connection/"/>
    
      <category term="Application" scheme="http://yoursite.com/tags/Application/"/>
    
      <category term="RequestHandler" scheme="http://yoursite.com/tags/RequestHandler/"/>
    
  </entry>
  
  <entry>
    <title>tornado.httputil 对 Http request message-body 的解析</title>
    <link href="http://yoursite.com/2016/01/24/tornado.httputil.parse_body_arguments/"/>
    <id>http://yoursite.com/2016/01/24/tornado.httputil.parse_body_arguments/</id>
    <published>2016-01-24T13:25:01.000Z</published>
    <updated>2019-10-22T15:53:03.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTPServerRequest-解析-message-body"><a href="#HTTPServerRequest-解析-message-body" class="headerlink" title="HTTPServerRequest 解析 message-body"></a>HTTPServerRequest 解析 message-body</h3><p>Tornado 对每次请求都会创建一个 <code>tornado.httputil.HTTPServerRequest</code> 实例。由之前的分析我们知道 Http Request 的 “Request-Line” 和头域解析工作已经在 <code>tornado.http1connection.Http1Connection</code> 中完成，所以在 <code>tornado.httputil.HTTPServerRequest</code> 中的主要工作就是对请求参数的解析，而其中对 message-body 的解析相比较 query 要复杂一些。</p><p>下面是 <code>HTTPServerRequest</code> 解析 message-body 的方法代码，其中解析结果存放在 <code>body_arguments</code> 和 <code>files</code> 字段中（注：字段 <code>arguments</code> 存放所有请求参数，包括 query 参数和 body 参数，对 query 的解析已经在 <code>HTTPServerRequest</code> 的构造函数中完成）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_parse_body</span><span class="params">(self)</span>:</span></span><br><span class="line">    parse_body_arguments(</span><br><span class="line">        self.headers.get(<span class="string">"Content-Type"</span>, <span class="string">""</span>), self.body,</span><br><span class="line">        self.body_arguments, self.files,</span><br><span class="line">        self.headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> self.body_arguments.items():</span><br><span class="line">        self.arguments.setdefault(k, []).extend(v)</span><br></pre></td></tr></table></figure><p>由代码可知，<code>_parse_body</code> 方法对 body 解析是委托模块函数 <code>parse_body_arguments</code> 完成的。</p><h3 id="parse-body-arguments-函数"><a href="#parse-body-arguments-函数" class="headerlink" title="parse_body_arguments 函数"></a>parse_body_arguments 函数</h3><p>Http 协议是以ASCII码传输，建立在 TCP/IP 协议之上的应用层协议。协议把 Http 请求分成了三部分：<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5" target="_blank" rel="noopener">请求行，请求头，消息体</a>。协议没有规定消息体中数据的编码方式。在浏览器 Form 表单 POST 提交时，如没有指定 <code>enctype</code> 属性的值，默认使用 <code>application/x-www-form-urlencoded</code> 方式编码提交，该编码方式不能用于文件上传。通常使用表单上传文件时使用 <code>multipart/form-data</code> 方式编码提交，这是浏览器原生支持的，就目前而言原生 Form 表单也只支持这<a href="https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4" target="_blank" rel="noopener">两种方式</a>。另外还有 <code>application/json</code> 、 <code>text/xml</code>、<code>text/plain</code>、 <code>text/html</code> 等等编码方式，不过这些方式大多都用在 Response 上。实际上只要服务器支持，任何一种编码都可以在请求中使用，我觉得通过 <code>application/json</code> 编码请求数据在 RESTful 接口中非常有用。</p><p><code>tornado.httputil</code> 模块中的 <code>parse_body_arguments</code> 函数默认支持解析 <code>application/x-www-form-urlencoded</code> 和 <code>multipart/form-data</code> 编码的 body 数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_body_arguments</span><span class="params">(content_type, body, arguments, files, headers=None)</span>:</span></span><br><span class="line">    <span class="string">"""Parses a form request body.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Supports ``application/x-www-form-urlencoded`` and</span></span><br><span class="line"><span class="string">    ``multipart/form-data``.  The ``content_type`` parameter should be</span></span><br><span class="line"><span class="string">    a string and ``body`` should be a byte string.  The ``arguments``</span></span><br><span class="line"><span class="string">    and ``files`` parameters are dictionaries that will be updated</span></span><br><span class="line"><span class="string">    with the parsed contents.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 只支持解码后（或无编码）的 body 数据。实际上在 Tornado 中有专门的</span></span><br><span class="line">    <span class="comment"># `_GzipMessageDelegate` 类支持 `gzip` 解码，body 数据都通过其解码后再调用</span></span><br><span class="line">    <span class="comment"># `parse_body_arguments` 函数。参见 `Http1Connection.read_response` 实现。</span></span><br><span class="line">    <span class="comment"># `_GzipMessageDelegate` 处理请求后会删除其中的 'Content-Encoding' 头域，用</span></span><br><span class="line">    <span class="comment"># 'X-Consumed-Content-Encoding' 头域代替。</span></span><br><span class="line">    <span class="keyword">if</span> headers <span class="keyword">and</span> <span class="string">'Content-Encoding'</span> <span class="keyword">in</span> headers:</span><br><span class="line">        gen_log.warning(<span class="string">"Unsupported Content-Encoding: %s"</span>,</span><br><span class="line">                        headers[<span class="string">'Content-Encoding'</span>])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> content_type.startswith(<span class="string">"application/x-www-form-urlencoded"</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            uri_arguments = parse_qs_bytes(native_str(body), keep_blank_values=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            gen_log.warning(<span class="string">'Invalid x-www-form-urlencoded body: %s'</span>, e)</span><br><span class="line">            uri_arguments = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, values <span class="keyword">in</span> uri_arguments.items():</span><br><span class="line">            <span class="keyword">if</span> values:</span><br><span class="line">                arguments.setdefault(name, []).extend(values)</span><br><span class="line">    <span class="keyword">elif</span> content_type.startswith(<span class="string">"multipart/form-data"</span>):</span><br><span class="line">        fields = content_type.split(<span class="string">";"</span>)</span><br><span class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> fields:</span><br><span class="line">            k, sep, v = field.strip().partition(<span class="string">"="</span>)</span><br><span class="line">            <span class="keyword">if</span> k == <span class="string">"boundary"</span> <span class="keyword">and</span> v:</span><br><span class="line">                parse_multipart_form_data(utf8(v), body, arguments, files)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gen_log.warning(<span class="string">"Invalid multipart/form-data"</span>)</span><br></pre></td></tr></table></figure><h4 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h4><p>这是浏览器原生表单 <code>POST</code> 默认的编码方式，<code>GET</code> 默认的请求数据编码方式也是它，差别就在于 <code>GET</code> 时编码后的数据是放在 URL 中一起发送给服务器的，并且 URL 有一个 2048 字符长度的限制；<code>POST</code> 时编码后的数据是放在 Message-Body 中发送给服务器的，协议上并没有限制长度。</p><a id="more"></a><p>从网上找了一个 <code>POST</code> 提交的请求数据，删除无关的消息头域后，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line"></span><br><span class="line">title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</span><br></pre></td></tr></table></figure><p>其中 <code>Content-Type</code> 被指定为 <code>application/x-www-form-urlencoded;charset=utf-8</code>, 消息体部分是 URL 编码后的数据且为 utf-8 编码（<strong><em>注：Tornado 默认支持的是 utf-8，若要使用其他的编码例如 GBK，则需要自己覆写一下 <code>RequestHandler.decode_argument</code> 方法。</em></strong>）</p><p>在 Tornado 中 <code>application/x-www-form-urlencoded</code> 编码数据的解析是由 <code>parse_qs_bytes</code> 函数支持的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs <span class="keyword">as</span> _parse_qs  <span class="comment"># py3</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> urlparse <span class="keyword">import</span> parse_qs <span class="keyword">as</span> _parse_qs  <span class="comment"># Python 2.6+</span></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.version_info[<span class="number">0</span>] &lt; <span class="number">3</span>:</span><br><span class="line">parse_qs_bytes = _parse_qs</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_qs_bytes</span><span class="params">(qs, keep_blank_values=False, strict_parsing=False)</span>:</span></span><br><span class="line">        <span class="string">"""Parses a query string like urlparse.parse_qs, but returns the</span></span><br><span class="line"><span class="string">        values as byte strings.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Keys still become type str (interpreted as latin1 in python3!)</span></span><br><span class="line"><span class="string">        because it's too painful to keep them as byte strings in</span></span><br><span class="line"><span class="string">        python3 and in practice they're nearly always ascii anyway.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># This is gross, but python3 doesn't give us another way.</span></span><br><span class="line">        <span class="comment"># Latin1 is the universal donor of character encodings.</span></span><br><span class="line">        result = _parse_qs(qs, keep_blank_values, strict_parsing,</span><br><span class="line">                           encoding=<span class="string">'latin1'</span>, errors=<span class="string">'strict'</span>)</span><br><span class="line">        encoded = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> result.items():</span><br><span class="line">            encoded[k] = [i.encode(<span class="string">'latin1'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> v]</span><br><span class="line">        <span class="keyword">return</span> encoded</span><br></pre></td></tr></table></figure><p>注意一下，在 python3 时 <code>parse_qs_bytes</code> 函数返回字典 key 是 unicode str，value 是 byte strings。在 python2 中 key/value 都是 str（对应 python3 的 byte strings）。这个应该是由于在 python3 中字符串默认使用的 unicode str，使用 byte strings 作为字典的 key，读取参数时操作不便。</p><h4 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h4><p><a href="https://tools.ietf.org/html/rfc7578#page-4" target="_blank" rel="noopener"><code>multipart/form-data</code></a> 编码的 body 包含一系列由 ”boundary“ 分割的字段数据。”boundary“ 是一段字符串，为了与避免与正文内容重复，一般这段字符串都很长。消息体里按照字段分为不同的部分，每部分以 ”–boundary“ 开始，紧接着内容描述信息，然后是两个回车换行，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息体最后以 ”–boundary–“ 结束。<code>multipart/form-data</code> 的具体定义请前往 <a href="https://tools.ietf.org/html/rfc7578" target="_blank" rel="noopener">rfc7578</a> 查看。下面是一段从网上 copy 的示例数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">title</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PNG ... content of chrome.png ...</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure><p>其中<code>Content-Type</code> 被指定为 <code>multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</code>， <code>boundary</code> 为 ”—-WebKitFormBoundaryrGKCBY7qhFd3TrwA“，body 部分包含两个字段，一个是名为 ”text“ 的文本，一个是图片文件 ”chrome.png“。对照这个示例数据，理解下面 <code>parse_multipart_form_data</code> 函数就很容易。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_multipart_form_data</span><span class="params">(boundary, data, arguments, files)</span>:</span></span><br><span class="line">    <span class="string">"""Parses a ``multipart/form-data`` body.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The ``boundary`` and ``data`` parameters are both byte strings.</span></span><br><span class="line"><span class="string">    The dictionaries given in the arguments and files parameters</span></span><br><span class="line"><span class="string">    will be updated with the contents of the body.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># The standard allows for the boundary to be quoted in the header,</span></span><br><span class="line">    <span class="comment"># although it's rare (it happens at least for google app engine</span></span><br><span class="line">    <span class="comment"># xmpp).  I think we're also supposed to handle backslash-escapes</span></span><br><span class="line">    <span class="comment"># here but I'll save that until we see a client that uses them</span></span><br><span class="line">    <span class="comment"># in the wild.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 兼容以引号包围的 ”boundary“ 字符串，示例中是没有引号的。</span></span><br><span class="line">    <span class="keyword">if</span> boundary.startswith(<span class="string">b'"'</span>) <span class="keyword">and</span> boundary.endswith(<span class="string">b'"'</span>):</span><br><span class="line">        boundary = boundary[<span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 消息体结束符 ”--boundary--“</span></span><br><span class="line">    final_boundary_index = data.rfind(<span class="string">b"--"</span> + boundary + <span class="string">b"--"</span>)</span><br><span class="line">    <span class="keyword">if</span> final_boundary_index == <span class="number">-1</span>:</span><br><span class="line">        gen_log.warning(<span class="string">"Invalid multipart/form-data: no final boundary"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取以 ”--boundary“ 分割的各部分列表</span></span><br><span class="line">    parts = data[:final_boundary_index].split(<span class="string">b"--"</span> + boundary + <span class="string">b"\r\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> part <span class="keyword">in</span> parts:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> part:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        eoh = part.find(<span class="string">b"\r\n\r\n"</span>)</span><br><span class="line">        <span class="keyword">if</span> eoh == <span class="number">-1</span>:</span><br><span class="line">            gen_log.warning(<span class="string">"multipart/form-data missing headers"</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        headers = HTTPHeaders.parse(part[:eoh].decode(<span class="string">"utf-8"</span>))</span><br><span class="line">        disp_header = headers.get(<span class="string">"Content-Disposition"</span>, <span class="string">""</span>)</span><br><span class="line">        disposition, disp_params = _parse_header(disp_header)</span><br><span class="line">        <span class="keyword">if</span> disposition != <span class="string">"form-data"</span> <span class="keyword">or</span> <span class="keyword">not</span> part.endswith(<span class="string">b"\r\n"</span>):</span><br><span class="line">            gen_log.warning(<span class="string">"Invalid multipart/form-data"</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># b"\r\n\r\n" 的长度为 4，b"\r\n" 的长度为 2。</span></span><br><span class="line">        value = part[eoh + <span class="number">4</span>:<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> disp_params.get(<span class="string">"name"</span>):</span><br><span class="line">            gen_log.warning(<span class="string">"multipart/form-data value missing name"</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        name = disp_params[<span class="string">"name"</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 上传的若是文件，则 ”Content-Disposition“ 中包含 ”filename“ 字段，且包含 ”Content-Type“   头域。</span></span><br><span class="line">        <span class="keyword">if</span> disp_params.get(<span class="string">"filename"</span>):</span><br><span class="line">            ctype = headers.get(<span class="string">"Content-Type"</span>, <span class="string">"application/unknown"</span>)</span><br><span class="line">            files.setdefault(name, []).append(HTTPFile(</span><br><span class="line">                filename=disp_params[<span class="string">"filename"</span>], body=value,</span><br><span class="line">                content_type=ctype))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arguments.setdefault(name, []).append(value)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTTPServerRequest-解析-message-body&quot;&gt;&lt;a href=&quot;#HTTPServerRequest-解析-message-body&quot; class=&quot;headerlink&quot; title=&quot;HTTPServerRequest 解析 message-body&quot;&gt;&lt;/a&gt;HTTPServerRequest 解析 message-body&lt;/h3&gt;&lt;p&gt;Tornado 对每次请求都会创建一个 &lt;code&gt;tornado.httputil.HTTPServerRequest&lt;/code&gt; 实例。由之前的分析我们知道 Http Request 的 “Request-Line” 和头域解析工作已经在 &lt;code&gt;tornado.http1connection.Http1Connection&lt;/code&gt; 中完成，所以在 &lt;code&gt;tornado.httputil.HTTPServerRequest&lt;/code&gt; 中的主要工作就是对请求参数的解析，而其中对 message-body 的解析相比较 query 要复杂一些。&lt;/p&gt;
&lt;p&gt;下面是 &lt;code&gt;HTTPServerRequest&lt;/code&gt; 解析 message-body 的方法代码，其中解析结果存放在 &lt;code&gt;body_arguments&lt;/code&gt; 和 &lt;code&gt;files&lt;/code&gt; 字段中（注：字段 &lt;code&gt;arguments&lt;/code&gt; 存放所有请求参数，包括 query 参数和 body 参数，对 query 的解析已经在 &lt;code&gt;HTTPServerRequest&lt;/code&gt; 的构造函数中完成）。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_parse_body&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    parse_body_arguments(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.headers.get(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;), self.body,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.body_arguments, self.files,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.headers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; self.body_arguments.items():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.arguments.setdefault(k, []).extend(v)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由代码可知，&lt;code&gt;_parse_body&lt;/code&gt; 方法对 body 解析是委托模块函数 &lt;code&gt;parse_body_arguments&lt;/code&gt; 完成的。&lt;/p&gt;
&lt;h3 id=&quot;parse-body-arguments-函数&quot;&gt;&lt;a href=&quot;#parse-body-arguments-函数&quot; class=&quot;headerlink&quot; title=&quot;parse_body_arguments 函数&quot;&gt;&lt;/a&gt;parse_body_arguments 函数&lt;/h3&gt;&lt;p&gt;Http 协议是以ASCII码传输，建立在 TCP/IP 协议之上的应用层协议。协议把 Http 请求分成了三部分：&lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;请求行，请求头，消息体&lt;/a&gt;。协议没有规定消息体中数据的编码方式。在浏览器 Form 表单 POST 提交时，如没有指定 &lt;code&gt;enctype&lt;/code&gt; 属性的值，默认使用 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 方式编码提交，该编码方式不能用于文件上传。通常使用表单上传文件时使用 &lt;code&gt;multipart/form-data&lt;/code&gt; 方式编码提交，这是浏览器原生支持的，就目前而言原生 Form 表单也只支持这&lt;a href=&quot;https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两种方式&lt;/a&gt;。另外还有 &lt;code&gt;application/json&lt;/code&gt; 、 &lt;code&gt;text/xml&lt;/code&gt;、&lt;code&gt;text/plain&lt;/code&gt;、 &lt;code&gt;text/html&lt;/code&gt; 等等编码方式，不过这些方式大多都用在 Response 上。实际上只要服务器支持，任何一种编码都可以在请求中使用，我觉得通过 &lt;code&gt;application/json&lt;/code&gt; 编码请求数据在 RESTful 接口中非常有用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tornado.httputil&lt;/code&gt; 模块中的 &lt;code&gt;parse_body_arguments&lt;/code&gt; 函数默认支持解析 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 和 &lt;code&gt;multipart/form-data&lt;/code&gt; 编码的 body 数据。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;parse_body_arguments&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(content_type, body, arguments, files, headers=None)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;Parses a form request body.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    Supports ``application/x-www-form-urlencoded`` and&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    ``multipart/form-data``.  The ``content_type`` parameter should be&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    a string and ``body`` should be a byte string.  The ``arguments``&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    and ``files`` parameters are dictionaries that will be updated&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    with the parsed contents.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 只支持解码后（或无编码）的 body 数据。实际上在 Tornado 中有专门的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# `_GzipMessageDelegate` 类支持 `gzip` 解码，body 数据都通过其解码后再调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# `parse_body_arguments` 函数。参见 `Http1Connection.read_response` 实现。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# `_GzipMessageDelegate` 处理请求后会删除其中的 &#39;Content-Encoding&#39; 头域，用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# &#39;X-Consumed-Content-Encoding&#39; 头域代替。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; headers &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Content-Encoding&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; headers:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        gen_log.warning(&lt;span class=&quot;string&quot;&gt;&quot;Unsupported Content-Encoding: %s&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        headers[&lt;span class=&quot;string&quot;&gt;&#39;Content-Encoding&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; content_type.startswith(&lt;span class=&quot;string&quot;&gt;&quot;application/x-www-form-urlencoded&quot;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            uri_arguments = parse_qs_bytes(native_str(body), keep_blank_values=&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; Exception &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; e:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            gen_log.warning(&lt;span class=&quot;string&quot;&gt;&#39;Invalid x-www-form-urlencoded body: %s&#39;&lt;/span&gt;, e)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            uri_arguments = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; name, values &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; uri_arguments.items():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; values:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                arguments.setdefault(name, []).extend(values)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; content_type.startswith(&lt;span class=&quot;string&quot;&gt;&quot;multipart/form-data&quot;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fields = content_type.split(&lt;span class=&quot;string&quot;&gt;&quot;;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; field &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fields:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            k, sep, v = field.strip().partition(&lt;span class=&quot;string&quot;&gt;&quot;=&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; k == &lt;span class=&quot;string&quot;&gt;&quot;boundary&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; v:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                parse_multipart_form_data(utf8(v), body, arguments, files)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            gen_log.warning(&lt;span class=&quot;string&quot;&gt;&quot;Invalid multipart/form-data&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;application-x-www-form-urlencoded&quot;&gt;&lt;a href=&quot;#application-x-www-form-urlencoded&quot; class=&quot;headerlink&quot; title=&quot;application/x-www-form-urlencoded&quot;&gt;&lt;/a&gt;application/x-www-form-urlencoded&lt;/h4&gt;&lt;p&gt;这是浏览器原生表单 &lt;code&gt;POST&lt;/code&gt; 默认的编码方式，&lt;code&gt;GET&lt;/code&gt; 默认的请求数据编码方式也是它，差别就在于 &lt;code&gt;GET&lt;/code&gt; 时编码后的数据是放在 URL 中一起发送给服务器的，并且 URL 有一个 2048 字符长度的限制；&lt;code&gt;POST&lt;/code&gt; 时编码后的数据是放在 Message-Body 中发送给服务器的，协议上并没有限制长度。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="application/x-www-form-urlencoded" scheme="http://yoursite.com/tags/application-x-www-form-urlencoded/"/>
    
      <category term="multipart/form-data" scheme="http://yoursite.com/tags/multipart-form-data/"/>
    
      <category term="message-body" scheme="http://yoursite.com/tags/message-body/"/>
    
      <category term="_parse_body" scheme="http://yoursite.com/tags/parse-body/"/>
    
      <category term="parse_body_arguments" scheme="http://yoursite.com/tags/parse-body-arguments/"/>
    
      <category term="Content-Type" scheme="http://yoursite.com/tags/Content-Type/"/>
    
  </entry>
  
  <entry>
    <title>tornado.web 模块解析</title>
    <link href="http://yoursite.com/2016/01/19/tornado.web/"/>
    <id>http://yoursite.com/2016/01/19/tornado.web/</id>
    <published>2016-01-19T09:25:01.000Z</published>
    <updated>2019-10-22T15:53:03.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在前面 Tornado 的分析文章中已经详细介绍了 HttpServer 接收处理客户端 Http 连接请求，并将请求委托给请求回调（即 HttpServer.request_callback 字段，由 HttpServer 的构造参数来完成初始化）处理的流程。基于 HttpServer 的支持，tornado.web 模块为我们提供了一个简单的 Web 框架，该框架支持路由请求到对应的（自定义/默认）请求处理器（RequestHandler）并自带一个简易的 HTML 模板引擎。在分析 tornado.web 模块的设计之前，先通过一张图来回顾一下 HttpServer 的处理流程，看看 web.tornado 提供的框架是如何获得支持的。</p><img src="/2016/01/19/tornado.web/tornado.httpserver.jpg"><p>由上图可知：</p><ol><li><p><code>httpsever.HttpServer</code> 继承自 <code>tcpserver.TCPServer</code> 并覆写了 <code>handle_stream(stream, address)</code> 方法。</p></li><li><p><code>httpsever.HttpServer.handle_stream(stream, address)</code> 方法中将请求相关的 IOStream、地址和协议描述（http/https）保证成 <code>httpsever._HTTPRequestContext</code> 实例以构建 <code>http1connection.HTTP1ServerConnection</code> 实例，并调用 <code>Http1ServerConnection.start_serving</code> 方法启动请求处理。</p></li><li><p><code>http1connection.HTTP1ServerConnection</code> 是一个支持 Http/1.x 的服务端抽象连接类型，也就是说能支持 Http/1.1 的长连接。在该连接实例服务周期中（实现在其 <code>_server_request_loop</code> 方法的 while 循环），其内部对于每一次 Http 请求会生成一个 <code>http1connection.HTTP1Connection</code> 实例。</p><ul><li><p><code>http1connection.Http1ServerConnection.start_serving(delegate:httputil.HTTPServerConnectionDelegate)</code> 方法要求接收一个 <code>httputil.HTTPServerConnectionDelegate</code> 实例，该实例的 <code>start_request(server_conn, request_conn:HTTP1Connection)</code> 方法返回一个 <code>httputil.HTTPMessageDelegate</code> 实例，该实例将与 <code>http1connection.HTTP1Connection</code> 实例配合处理 Http 请求的各个阶段。</p></li><li><p><code>http1connection.HTTP1Connection</code> 是 <code>httputil.HTTPConnection</code> 的 Http/1.x 子类实现，是每次 Http 连接请求的抽象，提供了读取请求和数据和发送响应数据的接口。<code>http1connection.HTTP1ServerConnection</code> 抽象了一个服务端的物理连接，<code>http1connection.HTTP1Connection</code> 则抽象了每次 Http 请求的连接，这样一来前者就可以基于同一个物理连接处理多个 Http 请求，也就是支持了 Http 协议要求的长连接。</p></li></ul></li><li><p><code>httpsever.HttpServer</code> 同时继承自 <code>httputil.HTTPServerConnectionDelegate</code>，所以它能作为 <code>http1connection.HTTP1ServerConnection.start_serving()</code> 方法的参数为其提供实际的请求处理。对请求的处理工作 <code>httpsever.HttpServer</code> 实际上是委托给其内部的 <code>request_callback</code> 字段来进行，该字段在 <code>httpsever.HttpServer</code> 构造时初始化。在 Tornado v4.0 之前的版本中，<code>request_callback</code> 是一个以 <code>httputil.HTTPServerRequest</code> 作为参数的回调对象，v4.0 之后引入 <code>httputil.HTTPMessageDelegate</code> 类型，随之 <code>request_callback</code> 改为支持 <code>httputil.HTTPMessageDelegate</code> 实例。为了向后兼容，<code>httpsever.HttpServer.start_request</code> 方法返回一个 <code>httpserver._ServerRequestAdapter</code> 类型实例。<code>httpserver._ServerRequestAdapter</code> 是一个对象适配器，它负责将之前的回调对象（适配者）适配到 <code>httputil.HTTPMessageDelegate</code> 类型。</p></li><li><p><code>web.Application</code> 继承自 <code>httputil.HTTPServerConnectionDelegate</code>，可作为请求连接处理回调对象传递给 <code>httpsever.HttpServer</code>， 作为其 <code>request_callback</code> 字段负责处理请求。</p></li></ol><p>到这里，<code>httpsever.HttpServer</code> 的整个处理过程基本回顾了一遍，后面处理将转到 <code>web.Application</code> ，开始进入 Tornado Web Framework 的处理流程。</p><a id="more"></a><h3 id="Tornado-Web-Framwork"><a href="#Tornado-Web-Framwork" class="headerlink" title="Tornado Web Framwork"></a>Tornado Web Framwork</h3><p><code>tornado.web</code> 中实现的 Web 框架总的来看主要由 3 个部分（类）组成：</p><ol><li><p><code>Application</code> 类型继承自 <code>httputil.HTTPServerConnectionDelegate</code>，其实例可直接传递给 HttpServer 来处理客户端连接；</p></li><li><p><code>RequestHandler</code> 类型是请求处理的基类型，其子类实例负责处理具体的请求，也就是 Tornado Web 框架分发请求的目标对象；</p></li><li><p><code>_RequestDispatcher</code> 是一个模块内部类，继承自 <code>httputil.HTTPMessageDelegate</code> 。它把映射请求到具体 <code>RequestHandler</code> 实例的逻辑从 <code>Application</code> 分离出来，简化 <code>Application</code> 的实现。</p></li></ol><p>也就是说实现上，<code>Application</code>  是一系列 <code>RequestHandler</code> 子类实例的集合，具体请求将根据主机和资源路径进行映射。映射关系则由 <code>URLSpec</code> 类型实例来描述，映射动作的执行（或者说请求分发）则由 <code>_RequestDispatcher</code> 来完成。</p><h4 id="URLSpec"><a href="#URLSpec" class="headerlink" title="URLSpec"></a>URLSpec</h4><p><code>URLSpec</code> 用于描述请求 URLs 与 handlers 的映射关系，别名是 <code>url</code>，即通过 <code>web.url</code> 也能引用该类型。<code>URLSpec</code> 的实现从构造方法就可窥见，与 URLs 的映射是通过正则表达式匹配来完成的。下面是其构造方法的签名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pattern, handler, kwargs=None, name=None)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><ol><li><p><code>pattern</code> 是用来匹配 URL 的正则表达式字符串。通过匹配得到的分组将作为 handler 实例 get/post 等等方法的参数调用；</p></li><li><p><code>handler</code> 是将被实例化后用来处理器请求的 <code>RequestHandler</code> 子类，可以是一个 “module.ClassName” 格式的字符串；</p></li><li><p><code>kwargs</code> 是 <code>handler</code> 实例化是传递给构造方法的参数；</p></li><li><p><code>name</code> 是为给 <code>Application.reverse_url</code> 使用给 <code>handler</code> 取的名字。<code>URLSpec</code> 提供方法 <code>reverse</code> 来配合 Application 工作，但不支持复杂的 <code>pattern</code> ，实现代码不复杂，感兴趣的可以看看。</p></li></ol><h4 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h4><p><code>RequestHandler</code> 是负责请求的处理（响应）的基类，是 Tornado 简单 Web 框架的重要组成部分。一般我们都会从它派生子类型来处理器具体的请求。<code>RequestHandler</code> 在 Tornado Web Framework 中的位置，有点类似Java Web 中的 Servlet 或者 ASP.NET 中的 HTTPHandler。</p><p><code>RequestHandler</code> 中封装的功能细节比较多，基本上包含了响应的方方面面，这里我们主要关注其处理流程，具体的功能细节后续再分析。<code>RequestHandler</code> 请求处理流程的入口是方法 <code>_execute</code>，该方法会被 <code>_RequestDispatcher</code> 在 <code>execute</code> 方法中调用。<code>_execute</code> 方法代码不多，清晰表达了 <code>RequestHandler</code> 的处理流程。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self, transforms, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Executes this request with the given output transforms."""</span></span><br><span class="line">    self._transforms = transforms</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> self.request.method <span class="keyword">not</span> <span class="keyword">in</span> self.SUPPORTED_METHODS:</span><br><span class="line">            <span class="keyword">raise</span> HTTPError(<span class="number">405</span>)</span><br><span class="line">        self.path_args = [self.decode_argument(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args]</span><br><span class="line">        self.path_kwargs = dict((k, self.decode_argument(v, name=k))</span><br><span class="line">                                <span class="keyword">for</span> (k, v) <span class="keyword">in</span> kwargs.items())</span><br><span class="line">        <span class="comment"># If XSRF cookies are turned on, reject form submissions without</span></span><br><span class="line">        <span class="comment"># the proper cookie</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">"GET"</span>, <span class="string">"HEAD"</span>, <span class="string">"OPTIONS"</span>) <span class="keyword">and</span> \</span><br><span class="line">                self.application.settings.get(<span class="string">"xsrf_cookies"</span>):</span><br><span class="line">            self.check_xsrf_cookie()</span><br><span class="line"></span><br><span class="line">        result = self.prepare()</span><br><span class="line">        <span class="keyword">if</span> is_future(result):</span><br><span class="line">            result = <span class="keyword">yield</span> result</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"Expected None, got %r"</span> % result)</span><br><span class="line">        <span class="keyword">if</span> self._prepared_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Tell the Application we've finished with prepare()</span></span><br><span class="line">            <span class="comment"># and are ready for the body to arrive.</span></span><br><span class="line">            self._prepared_future.set_result(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> self._finished:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> _has_stream_request_body(self.__class__):</span><br><span class="line">            <span class="comment"># In streaming mode request.body is a Future that signals</span></span><br><span class="line">            <span class="comment"># the body has been completely received.  The Future has no</span></span><br><span class="line">            <span class="comment"># result; the data has been passed to self.data_received</span></span><br><span class="line">            <span class="comment"># instead.</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">yield</span> self.request.body</span><br><span class="line">            <span class="keyword">except</span> iostream.StreamClosedError:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        method = getattr(self, self.request.method.lower())</span><br><span class="line">        result = method(*self.path_args, **self.path_kwargs)</span><br><span class="line">        <span class="keyword">if</span> is_future(result):</span><br><span class="line">            result = <span class="keyword">yield</span> result</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"Expected None, got %r"</span> % result)</span><br><span class="line">        <span class="comment"># 就目前版本的实现而言，默认 `self._auto_finish=True`，只有当方法被</span></span><br><span class="line">        <span class="comment"># `asynchronous` 装饰时才设置为 False，此时 `self.finish()` 将在</span></span><br><span class="line">        <span class="comment"># 异步方法执行完成后回调。</span></span><br><span class="line">        <span class="keyword">if</span> self._auto_finish <span class="keyword">and</span> <span class="keyword">not</span> self._finished:</span><br><span class="line">            self.finish()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        self._handle_request_exception(e)</span><br><span class="line">        <span class="keyword">if</span> (self._prepared_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span></span><br><span class="line">                <span class="keyword">not</span> self._prepared_future.done()):</span><br><span class="line">            <span class="comment"># In case we failed before setting _prepared_future, do it</span></span><br><span class="line">            <span class="comment"># now (to unblock the HTTP server).  Note that this is not</span></span><br><span class="line">            <span class="comment"># in a finally block to avoid GC issues prior to Python 3.4.</span></span><br><span class="line">            self._prepared_future.set_result(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>从上面的代码可看出 <code>RequestHandler</code> 中通过类字段 <code>SUPPORTED_METHODS</code> 来定义 Handler  支持的请求方法（Http method）列表，处理方法名字就是 Http Method 名称的小写字符（<code>method = getattr(self, self.request.method.lower())</code>），例如<code>POST</code> 请求对应 <code>post</code>  方法，<code>GET</code> 请求对应 <code>get</code> 方法。若 Handler 支持当前 Http Method，则进入处理流程：execute prepare method -&gt; execute http method -&gt; execute finish method。另外需要指出的一点是该方法被 <code>gen.coroutine</code> 装饰，没有返回值（或者说返回值 None ），但被一个完整的异常处理块包围而不会抛出任何异常，所以在 <code>_RequestDispatcher</code> 中可以不去关心其返回的 Future 实例何时完成，结果是什么，是否在异步执行时发生异常。</p><h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><p><code>Application</code> 是一个 Web 应用的 Request Handler 集合。它支持按照虚拟主机/子域名/泛域名对 handler 进行映射，通过 <code>add_handlers</code> 方法可以指定 handler 对应的主机。<code>Application</code>  实例化时可以指定一些默认的 handler，这些 handler 适用于所有的主机地址（匹配主机地址的正则表达式被设置为 <code>&quot;.*$&quot;</code>），构造方法内也是通过调用 <code>add_handlers</code> 方法完成 handler 添加。下面是 <code>add_handlers</code> 的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_handlers</span><span class="params">(self, host_pattern, host_handlers)</span>:</span></span><br><span class="line">    <span class="string">"""Appends the given handlers to our handler list.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Host patterns are processed sequentially in the order they were</span></span><br><span class="line"><span class="string">    added. All matching patterns will be considered.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> host_pattern.endswith(<span class="string">"$"</span>):</span><br><span class="line">        host_pattern += <span class="string">"$"</span></span><br><span class="line">    handlers = []</span><br><span class="line">    <span class="comment"># The handlers with the wildcard host_pattern are a special</span></span><br><span class="line">    <span class="comment"># case - they're added in the constructor but should have lower</span></span><br><span class="line">    <span class="comment"># precedence than the more-precise handlers added later.</span></span><br><span class="line">    <span class="comment"># If a wildcard handler group exists, it should always be last</span></span><br><span class="line">    <span class="comment"># in the list, so insert new groups just before it.</span></span><br><span class="line">    <span class="keyword">if</span> self.handlers <span class="keyword">and</span> self.handlers[<span class="number">-1</span>][<span class="number">0</span>].pattern == <span class="string">'.*$'</span>:</span><br><span class="line">        self.handlers.insert(<span class="number">-1</span>, (re.compile(host_pattern), handlers))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.handlers.append((re.compile(host_pattern), handlers))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> spec <span class="keyword">in</span> host_handlers:</span><br><span class="line">        <span class="keyword">if</span> isinstance(spec, (tuple, list)):</span><br><span class="line">            <span class="comment"># 需要满足 `URLSpec` 构造函数参数列表的要求：(pattern, handler, kwargs=None, name=None)</span></span><br><span class="line">            <span class="keyword">assert</span> len(spec) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">            spec = URLSpec(*spec)</span><br><span class="line">        handlers.append(spec)</span><br><span class="line">        <span class="keyword">if</span> spec.name:</span><br><span class="line">            <span class="keyword">if</span> spec.name <span class="keyword">in</span> self.named_handlers:</span><br><span class="line">                app_log.warning(</span><br><span class="line">                    <span class="string">"Multiple handlers named %s; replacing previous value"</span>,</span><br><span class="line">                    spec.name)</span><br><span class="line">            self.named_handlers[spec.name] = spec</span><br></pre></td></tr></table></figure><p>对上述代码可以做一些分析：</p><ol><li><p>参数 <code>host_pattern</code> 指定匹配主机地址的正则表达式字符串， <code>host_handlers</code> 是一个 <code>list</code>，其中的元素可以是 <code>URLSpec</code> 实例或者用于构造 <code>URLSpec</code> 实例的参数列表，若是后者需要动态创建 <code>URLSpec</code> 实例。</p></li><li><p><code>self.handlers</code> 字段保存着所有的 handler 列表，其中的每个元素是一个 tuple 实例，tuple 实例的第一个元素是匹配主机的正则表达式实例，第二个元素是 <code>URLSpec</code> 实例列表，其中通配所有主机的元素优先级最低，默认添加到 handler 列表的尾部。</p></li><li><p>对于命名的 handler 同时会被保存在 <code>named_handlers</code> 字段中，以备 <code>reverse_url</code> 方法使用。</p></li></ol><p><code>Application</code> 作为 <code>httputil.HTTPServerConnectionDelegate</code> 的子类，其 <code>start_request</code> 方法将返回一个 <code>_RequestDispatcher</code> 实例来处理请求。在 Tornado v4.0.2 中，<code>start_request</code> 的方法签名与 <code>httputil.HTTPServerConnectionDelegate</code> 定义的不一致，貌似没有重构完成一样，不过后面版本中已经做了修正。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_request</span><span class="params">(self, connection)</span>:</span></span><br><span class="line">    <span class="comment"># Modern HTTPServer interface</span></span><br><span class="line">    <span class="keyword">return</span> _RequestDispatcher(self, connection)</span><br></pre></td></tr></table></figure></p><p><code>Application</code> 本身还有一些诸如启动 HttpSever，配置 debug 参数，HTML 模板解析支持等功能，这里我们仅分析梳理其处理请求的流程，这些功能就不再一一介绍。</p><h4 id="RequestDispatcher"><a href="#RequestDispatcher" class="headerlink" title="_RequestDispatcher"></a>_RequestDispatcher</h4><p><code>_RequestDispatcher</code> 是 <code>httputil.HTTPMessageDelegate</code> 的子类，负责将请求按照主机地址和资源路径分发到具体的 handler 实例。在 Tornado v4.0 之前，这部分功能属于 <code>Application</code>。这样的职责分离是程序不断重构的结果。</p><p><code>_RequestDispatcher</code> 的代码比较简单，结合前面的介绍很容易看懂，这里就直接将分析内容写在代码注释中，不再单独赘述。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RequestDispatcher</span><span class="params">(httputil.HTTPMessageDelegate)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, application, connection)</span>:</span></span><br><span class="line">        self.application = application</span><br><span class="line">        self.connection = connection</span><br><span class="line">        self.request = <span class="literal">None</span></span><br><span class="line">        self.chunks = []</span><br><span class="line">        self.handler_class = <span class="literal">None</span></span><br><span class="line">        self.handler_kwargs = <span class="literal">None</span></span><br><span class="line">        self.path_args = []</span><br><span class="line">        self.path_kwargs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">headers_received</span><span class="params">(self, start_line, headers)</span>:</span></span><br><span class="line">        self.set_request(httputil.HTTPServerRequest(</span><br><span class="line">            connection=self.connection, start_line=start_line, headers=headers))</span><br><span class="line">        <span class="comment"># 当前请求处理器若支持 `streaming body` 模式，便直接进入请求处理器的处理阶段，否则便需要</span></span><br><span class="line">        <span class="comment"># 等待 body 数据接收解析完成后才进入（由 finish 方法中进入）。</span></span><br><span class="line">        <span class="keyword">if</span> self.stream_request_body:</span><br><span class="line">            self.request.body = Future()</span><br><span class="line">            <span class="comment"># self.execute() 方法将返回 `handler._prepared_future` 字段，对于 `streaming body` 模式</span></span><br><span class="line">            <span class="comment"># `handler._prepared_future=Future()`,一旦 futrue 完成就表明 `handler` 已准备好接收 body</span></span><br><span class="line">            <span class="comment"># 数据。对于非 `streaming body` 模式，没有准备接收 body 数据这个前提，所以 `handler._prepared_future=None`</span></span><br><span class="line">            <span class="keyword">return</span> self.execute()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        self.request = request</span><br><span class="line">        self._find_handler()</span><br><span class="line">        <span class="comment"># 检查目标请求处理器类是否支持 `streaming body`，实际上也就是看看类型是否被</span></span><br><span class="line">        <span class="comment"># `stream_request_body` 装饰。`stream_request_body` 装饰器由 Tornado v4.0</span></span><br><span class="line">        <span class="comment"># 开始引入，在之前版本中客户端上传的 body 默认会被解析到 request.arguments 和 request.files</span></span><br><span class="line">        <span class="comment"># 中。这就预示着在处理文件上传时，文件被整个暂存在内存中，很显然非常不适合较大文件上传。</span></span><br><span class="line">        <span class="comment"># `streaming body` 模式的引入，可以让使用者去直接处理 raw body 数据，一边接收一</span></span><br><span class="line">        <span class="comment"># 边写到存储中，减少内存的开销。详细一点说明请参考 `stream_request_body` 装饰器说</span></span><br><span class="line">        <span class="comment"># 明。</span></span><br><span class="line">        <span class="comment"># 注：对于文件上传， raw body 是 multipart/form-data 包装的数据，不仅仅包括文件数据。对</span></span><br><span class="line">        <span class="comment"># raw body 的数据解析，可以参考 httputil.parse_body_arguments/parse_multipart_form_data 方法。</span></span><br><span class="line">        self.stream_request_body = _has_stream_request_body(self.handler_class)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_find_handler</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Identify the handler to use as soon as we have the request.</span></span><br><span class="line">        <span class="comment"># Save url path arguments for later.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># 根据请求的主机和资源路径来定位请求处理器类。</span></span><br><span class="line">        <span class="comment"># 1. 查找对应主机的所有请求处理器。Tornado 支持虚拟主机，可以为不同的虚拟主机配置不同的请求处理器，</span></span><br><span class="line">        <span class="comment">#    参见 Application.add_handlers。 不过，一般生产环境都不会直接把 Tornado 进程暴露在请求处</span></span><br><span class="line">        <span class="comment">#    理最前端，这个功能可以由处理前端来支持，比如 nginx。</span></span><br><span class="line">        <span class="comment"># 2. 没有为请求的虚拟主机配置处理器时由 `RedirectHandler` 重新定位到默认主机。</span></span><br><span class="line">        <span class="comment"># 3. 接着根据资源路径来定位具体的请求处理器。如有需要便将 path parameters 解析出来放到 path_kwargs</span></span><br><span class="line">        <span class="comment">#    或 path_args 字段中。放到哪一个字段取决于资源路径匹配的正则表达式分组是否命名。</span></span><br><span class="line">        <span class="comment"># 4. 若上一步没有定位到请求处理器，则尝试交由默认的处理器进行处理，否则由 `ErrorHandler` 处理。</span></span><br><span class="line">        app = self.application</span><br><span class="line">        handlers = app._get_host_handlers(self.request)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> handlers:</span><br><span class="line">            self.handler_class = RedirectHandler</span><br><span class="line">            self.handler_kwargs = dict(url=<span class="string">"http://"</span> + app.default_host + <span class="string">"/"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> spec <span class="keyword">in</span> handlers:</span><br><span class="line">            match = spec.regex.match(self.request.path)</span><br><span class="line">            <span class="keyword">if</span> match:</span><br><span class="line">                self.handler_class = spec.handler_class</span><br><span class="line">                self.handler_kwargs = spec.kwargs</span><br><span class="line">                <span class="keyword">if</span> spec.regex.groups:</span><br><span class="line">                    <span class="comment"># Pass matched groups to the handler.  Since</span></span><br><span class="line">                    <span class="comment"># match.groups() includes both named and</span></span><br><span class="line">                    <span class="comment"># unnamed groups, we want to use either groups</span></span><br><span class="line">                    <span class="comment"># or groupdict but not both.</span></span><br><span class="line">                    <span class="keyword">if</span> spec.regex.groupindex:</span><br><span class="line">                        self.path_kwargs = dict(</span><br><span class="line">                            (str(k), _unquote_or_none(v))</span><br><span class="line">                            <span class="keyword">for</span> (k, v) <span class="keyword">in</span> match.groupdict().items())</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        self.path_args = [_unquote_or_none(s)</span><br><span class="line">                                          <span class="keyword">for</span> s <span class="keyword">in</span> match.groups()]</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> app.settings.get(<span class="string">'default_handler_class'</span>):</span><br><span class="line">            self.handler_class = app.settings[<span class="string">'default_handler_class'</span>]</span><br><span class="line">            self.handler_kwargs = app.settings.get(</span><br><span class="line">                <span class="string">'default_handler_args'</span>, &#123;&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.handler_class = ErrorHandler</span><br><span class="line">            self.handler_kwargs = dict(status_code=<span class="number">404</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data_received</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stream_request_body:</span><br><span class="line">            <span class="comment"># streaming body 模式，由 handler 来自行处理 body stream data</span></span><br><span class="line">            <span class="keyword">return</span> self.handler.data_received(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.chunks.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stream_request_body:</span><br><span class="line">            self.request.body.set_result(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.request.body = <span class="string">b''</span>.join(self.chunks)</span><br><span class="line">            self.request._parse_body()</span><br><span class="line">            self.execute()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connection_close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stream_request_body:</span><br><span class="line">            self.handler.on_connection_close()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.chunks = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># If template cache is disabled (usually in the debug mode),</span></span><br><span class="line">        <span class="comment"># re-compile templates and reload static files on every</span></span><br><span class="line">        <span class="comment"># request so you don't need to restart to see changes</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.application.settings.get(<span class="string">"compiled_template_cache"</span>, <span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">with</span> RequestHandler._template_loader_lock:</span><br><span class="line">                <span class="keyword">for</span> loader <span class="keyword">in</span> RequestHandler._template_loaders.values():</span><br><span class="line">                    loader.reset()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.application.settings.get(<span class="string">'static_hash_cache'</span>, <span class="literal">True</span>):</span><br><span class="line">            StaticFileHandler.reset()</span><br><span class="line"></span><br><span class="line">        self.handler = self.handler_class(self.application, self.request,</span><br><span class="line">                                          **self.handler_kwargs)</span><br><span class="line">        transforms = [t(self.request) <span class="keyword">for</span> t <span class="keyword">in</span> self.application.transforms]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.stream_request_body:</span><br><span class="line">            self.handler._prepared_future = Future()</span><br><span class="line">        <span class="comment"># Note that if an exception escapes handler._execute it will be</span></span><br><span class="line">        <span class="comment"># trapped in the Future it returns (which we are ignoring here).</span></span><br><span class="line">        <span class="comment"># However, that shouldn't happen because _execute has a blanket</span></span><br><span class="line">        <span class="comment"># except handler, and we cannot easily access the IOLoop here to</span></span><br><span class="line">        <span class="comment"># call add_future.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># handler._execute 返回的是一个 Future 对象，但这里不关心 Future 的结果。</span></span><br><span class="line">        <span class="comment"># 一方面是由于 handler._execute 内部包含在一个异常捕获块中，所以实际上不必担心</span></span><br><span class="line">        <span class="comment"># 其会抛出异常；另一方面在这里不太方便访问 IOLoop 以调用 add_future 获取结果。</span></span><br><span class="line">        self.handler._execute(transforms, *self.path_args, **self.path_kwargs)</span><br><span class="line">        <span class="comment"># If we are streaming the request body, then execute() is finished</span></span><br><span class="line">        <span class="comment"># when the handler has prepared to receive the body.  If not,</span></span><br><span class="line">        <span class="comment"># it doesn't matter when execute() finishes (so we return None)</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># streaming 模式时 handler._prepared_future 将在 handler 准备好接收 body 数据时完成。</span></span><br><span class="line">        <span class="keyword">return</span> self.handler._prepared_future</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在前面 Tornado 的分析文章中已经详细介绍了 HttpServer 接收处理客户端 Http 连接请求，并将请求委托给请求回调（即 HttpServer.request_callback 字段，由 HttpServer 的构造参数来完成初始化）处理的流程。基于 HttpServer 的支持，tornado.web 模块为我们提供了一个简单的 Web 框架，该框架支持路由请求到对应的（自定义/默认）请求处理器（RequestHandler）并自带一个简易的 HTML 模板引擎。在分析 tornado.web 模块的设计之前，先通过一张图来回顾一下 HttpServer 的处理流程，看看 web.tornado 提供的框架是如何获得支持的。&lt;/p&gt;
&lt;img src=&quot;/2016/01/19/tornado.web/tornado.httpserver.jpg&quot;&gt;
&lt;p&gt;由上图可知：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;httpsever.HttpServer&lt;/code&gt; 继承自 &lt;code&gt;tcpserver.TCPServer&lt;/code&gt; 并覆写了 &lt;code&gt;handle_stream(stream, address)&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;httpsever.HttpServer.handle_stream(stream, address)&lt;/code&gt; 方法中将请求相关的 IOStream、地址和协议描述（http/https）保证成 &lt;code&gt;httpsever._HTTPRequestContext&lt;/code&gt; 实例以构建 &lt;code&gt;http1connection.HTTP1ServerConnection&lt;/code&gt; 实例，并调用 &lt;code&gt;Http1ServerConnection.start_serving&lt;/code&gt; 方法启动请求处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;http1connection.HTTP1ServerConnection&lt;/code&gt; 是一个支持 Http/1.x 的服务端抽象连接类型，也就是说能支持 Http/1.1 的长连接。在该连接实例服务周期中（实现在其 &lt;code&gt;_server_request_loop&lt;/code&gt; 方法的 while 循环），其内部对于每一次 Http 请求会生成一个 &lt;code&gt;http1connection.HTTP1Connection&lt;/code&gt; 实例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;http1connection.Http1ServerConnection.start_serving(delegate:httputil.HTTPServerConnectionDelegate)&lt;/code&gt; 方法要求接收一个 &lt;code&gt;httputil.HTTPServerConnectionDelegate&lt;/code&gt; 实例，该实例的 &lt;code&gt;start_request(server_conn, request_conn:HTTP1Connection)&lt;/code&gt; 方法返回一个 &lt;code&gt;httputil.HTTPMessageDelegate&lt;/code&gt; 实例，该实例将与 &lt;code&gt;http1connection.HTTP1Connection&lt;/code&gt; 实例配合处理 Http 请求的各个阶段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;http1connection.HTTP1Connection&lt;/code&gt; 是 &lt;code&gt;httputil.HTTPConnection&lt;/code&gt; 的 Http/1.x 子类实现，是每次 Http 连接请求的抽象，提供了读取请求和数据和发送响应数据的接口。&lt;code&gt;http1connection.HTTP1ServerConnection&lt;/code&gt; 抽象了一个服务端的物理连接，&lt;code&gt;http1connection.HTTP1Connection&lt;/code&gt; 则抽象了每次 Http 请求的连接，这样一来前者就可以基于同一个物理连接处理多个 Http 请求，也就是支持了 Http 协议要求的长连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;httpsever.HttpServer&lt;/code&gt; 同时继承自 &lt;code&gt;httputil.HTTPServerConnectionDelegate&lt;/code&gt;，所以它能作为 &lt;code&gt;http1connection.HTTP1ServerConnection.start_serving()&lt;/code&gt; 方法的参数为其提供实际的请求处理。对请求的处理工作 &lt;code&gt;httpsever.HttpServer&lt;/code&gt; 实际上是委托给其内部的 &lt;code&gt;request_callback&lt;/code&gt; 字段来进行，该字段在 &lt;code&gt;httpsever.HttpServer&lt;/code&gt; 构造时初始化。在 Tornado v4.0 之前的版本中，&lt;code&gt;request_callback&lt;/code&gt; 是一个以 &lt;code&gt;httputil.HTTPServerRequest&lt;/code&gt; 作为参数的回调对象，v4.0 之后引入 &lt;code&gt;httputil.HTTPMessageDelegate&lt;/code&gt; 类型，随之 &lt;code&gt;request_callback&lt;/code&gt; 改为支持 &lt;code&gt;httputil.HTTPMessageDelegate&lt;/code&gt; 实例。为了向后兼容，&lt;code&gt;httpsever.HttpServer.start_request&lt;/code&gt; 方法返回一个 &lt;code&gt;httpserver._ServerRequestAdapter&lt;/code&gt; 类型实例。&lt;code&gt;httpserver._ServerRequestAdapter&lt;/code&gt; 是一个对象适配器，它负责将之前的回调对象（适配者）适配到 &lt;code&gt;httputil.HTTPMessageDelegate&lt;/code&gt; 类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;web.Application&lt;/code&gt; 继承自 &lt;code&gt;httputil.HTTPServerConnectionDelegate&lt;/code&gt;，可作为请求连接处理回调对象传递给 &lt;code&gt;httpsever.HttpServer&lt;/code&gt;， 作为其 &lt;code&gt;request_callback&lt;/code&gt; 字段负责处理请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到这里，&lt;code&gt;httpsever.HttpServer&lt;/code&gt; 的整个处理过程基本回顾了一遍，后面处理将转到 &lt;code&gt;web.Application&lt;/code&gt; ，开始进入 Tornado Web Framework 的处理流程。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="HTTPServer" scheme="http://yoursite.com/tags/HTTPServer/"/>
    
      <category term="HTTPServerConnectionDelegate" scheme="http://yoursite.com/tags/HTTPServerConnectionDelegate/"/>
    
      <category term="HTTPMessageDelegate" scheme="http://yoursite.com/tags/HTTPMessageDelegate/"/>
    
      <category term="HTTPConnection" scheme="http://yoursite.com/tags/HTTPConnection/"/>
    
      <category term="HTTP1ServerConnection" scheme="http://yoursite.com/tags/HTTP1ServerConnection/"/>
    
      <category term="HTTP1Connection" scheme="http://yoursite.com/tags/HTTP1Connection/"/>
    
      <category term="Application" scheme="http://yoursite.com/tags/Application/"/>
    
      <category term="RequestHandler" scheme="http://yoursite.com/tags/RequestHandler/"/>
    
  </entry>
  
  <entry>
    <title>Linux 守护进程</title>
    <link href="http://yoursite.com/2016/01/14/Linux%20Daemon%20Processes/"/>
    <id>http://yoursite.com/2016/01/14/Linux Daemon Processes/</id>
    <published>2016-01-14T07:00:00.000Z</published>
    <updated>2019-10-22T15:53:03.322Z</updated>
    
    <content type="html"><![CDATA[<h4 id="守护进程介绍"><a href="#守护进程介绍" class="headerlink" title="守护进程介绍"></a>守护进程介绍</h4><p><strong><em>本笔记内容主要参考自：《Advanced Programming in The Unix Environment 3rd edition》 第 13 章第 3 小节。</em></strong></p><p>守护进程是一类长时间运行的进程，一般随操作系统启动运行直到系统关闭而停止（也可以由 crond 启动，或者由用户终端 Shell 启动）。因为没有关联的控制终端，所以我们称其在后台运行，这也是守护进程最重要的特性。另一个重要的特性是守护进程必须与其运行前的环境隔离开。参考 《Advanced Programming in The Unix Environment》 第 13 章内容，编程实现守护进程有一些通用的设计规范。</p><h4 id="守护进程编码设计规范"><a href="#守护进程编码设计规范" class="headerlink" title="守护进程编码设计规范"></a>守护进程编码设计规范</h4><p>这里将介绍一些编码规范，这些规范将阻止守护进程与其运行前环境产生一些不必要的交互。</p><ol><li><p>Call umask to set the file mode creation mask to a known value, usually 0. The inherited file mode creation mask could be set to deny certain permissions. If the daemon process creates files, it may want to set specific permissions. For example, if it creates files with group-read and group-write enabled, a file mode creation mask that turns off either of these permissions would undo its efforts. On the other hand, if the daemon calls library functions that result in files being created, then it might make sense to set the file mode create mask to a more restrictive value (such as 007), since the library functions might not allow the caller to specify the permissions through an explicit argument.</p><p> 调用 umask 将文件创建掩码设置为一个值，通常是 0 。因为守护进程从父进程继承而来的 “文件创建掩码” 可能会屏蔽某些特定的文件操作权限。如果守护进程想要创建文件，那么便需要设置特定的文件操作权限。例如，守护进程想要创建允许用户组读和写权限的文件，继承而来的 “文件创建掩码” 屏蔽了这个权限，则创建操作不会成功。另一方面，如果后台进程调用的库函数会创建文件，但是库函数又不允许调用者通过一个明确的参数来指定文件的权限，为了安全起见将 “文件创建掩码” 设置为一个更严格的值（比如 007 ）是非常有意义和必要的。(<strong>注：默认情况下的 umask 值是 022 (可以用 umask 命令查看），此时你建立的文件默认权限是 644 (6-0,6-2,6-2)，建立的目录的默认权限是 755 (7-0,7-2,7-2)。使用 umask(0) 修改 “文件创建掩码” ，保证进程拥有文件的读写权限，这个操作很危险将导致新建的文件权限为 0666/world-writable 。这个操作通常用于文件创建者和修改者不是同一个用户的场景，比如：你需要创建一个文件，该文件后续会被 Web Server 修改，而 Web Server 使用的是另外一个用户运行。这种情况下为 Web Server 写文件的目录 Set Group ID（） 是个不错的选择。</strong>)</p></li><li><p>Call fork and have the parent exit. This does several things. First, if the daemon was started as a simple shell command, having the parent terminate makes the shell think that the command is done. Second, the child inherits the process group ID of the parent but gets a new process ID, so we’re guaranteed that the child is not a process group leader. This is a prerequisite for the call to setsid that is done next.</p><p> 调用 fork 创建子进程并使父进程退出，将守护进程放入后台运行。这个操作主要有两个目的。首先，如果守护进程是通过一个简单的 Shell 命令创建的，那么父进程结束时便会让 Shell 一并将守护进程也结束（<strong>注：在终端中 ctrl+c/delete 会向前台进程组所有进程发送中断信号，若父进程退出那么子进程便会被 init 进程接管进入后台运行。</strong>）；其次，子进程继承得到父进程的 “进程组ID” 同时也获得了一个新的进程号，这样便能保证子进程不是 “进程组组长” ，这是下一步 setsid 操作的前提（<strong>注：只有当前进程不是进程组组长时，才能调用 setsid 创建新会话。</strong>）。</p></li><li><p>Call setsid to create a new session. The three steps listed in Section 9.5 occur.The process (a) becomes the leader of a new session, (b) becomes the leader of a new process group, and (c) is disassociated from its controlling terminal.</p><p> 调用 setsid 创建一个新会话，这个调用实际会执行 3 个操作：(a) 使当前进程称为新会话的 “会话首进程”；(b) 使当前进程称为新 “进程组组长”；(c) 使当前进程脱离控制终端。（<strong>注：第 2 个操作使当前进程进入后台运行，这个操作接着使进程脱离原来的进程组、控制终端和会话。</strong>）</p><p> 在基于 System V 的系统中，有人建议再一次调用 fork 并使父进程退出，而新产生的进程将会成为真正的守护进程。这一步骤将保证守护进程不是一个 “会话首进程” ，进而阻止它重新申请获取一个控制终端。另外一种阻止守护进程重新申请获取控制终端的方法是任意时刻打开一个终端设备的时候明确指定 O_NOCTTY 标识（<strong>注：调用 open() 函数打开文件时，若文件是一个终端，指定 O_NOCTTY 标识后便不会让此终端成为该进程的控制终端。 </strong>） 。</p></li><li><p>Change the current working directory to the root directory. The current working directory inherited from the parent could be on a mounted file system. Since daemons normally exist until the system is rebooted, if the daemon stays on a mounted file system, that file system cannot be unmounted.</p><p> Alternatively, some daemons might change the current working directory to a specific location where they will do all their work. For example, a line printer spooling daemon might change its working directory to its spool directory.</p><p> 将当前工作目录切换到系统目录下。这是因为继承自父进程的当前工作目录可能是一个挂载的文件系统，而守护进程通常会一直运行到系统重启。如果守护进程工作在一个挂载的文件系统上，那么这个文件系统便不能被卸载。</p><p> 另外，有些守护进程会把当前工作目录切换到特定的路径下，并在这些路径下完成它们的工作。例如，行式打印机守护进程通常会将当前工作目录切换到 spool 目录。</p></li><li><p>Unneeded file descriptors should be closed. This prevents the daemon from holding open any descriptors that it may have inherited from its parent (which could be a shell or some other process). We can use our open_max function (Figure 2.17) or the getrlimit function (Section 7.11) to determine the highest descriptor and close all descriptors up to that value.</p><p> 关闭不必要的文件描述符。这将阻止守护进程保持任何从父进程（Shell 或者其他进程）进程而来的文件描述符。我们可以使用 open_max 或 getrlimit 函数来查找当前优先级最高的文件描述符并关闭此描述符之下的所有其他描述符。（<strong>注：保持打开的文件描述符将会占用系统资源并使某系文件不能被卸载。</strong>）</p></li><li><p>Some daemons open file descriptors 0, 1, and 2 to /dev/null so that any library routines that try to read from standard input or write to standard output or standard error will have no effect. Since the daemon is not associated with a terminal device, there is nowhere for output to be displayed, nor is there anywhere to receive input from an interactive user. Even if the daemon was started from an interactive session, the daemon runs in the background, and the login session can terminate without affecting the daemon. If other users log in on the same terminal device, we wouldn’t want output from the daemon showing up on the terminal, and the users wouldn’t expect their input to be read by the daemon.</p><p> 有些守护进程会将标准输入、标准输出、标准错误描述符重定向到 /dev/null，这样一来任何尝试从标准输入、标准输出或者标准错误读取守护进程信息的操作都会失败。因为守护进程不与任何终端设备关联，便没有地方显示输出或者接受用户输入。即使守护进程是由一个交互式会话创建，但由于其在后台运行，便不会受登录会话结束的影响；如果有其他用户通过当前终端登录，我们也不希望守护进程的输出出现在终端上，并且该用户的任何输入也不会被守护进程接收。</p></li><li><p>（<strong>注：引用自 <a href="http://www.cnblogs.com/mickole/p/3188321.html" target="_blank" rel="noopener">《linux系统编程之进程（八）：守护进程详解及创建，daemon()使用》</a></strong>）处理 SIGCHLD 信号。这不是一个必须的操作，但对于某些进程，特别是服务器进程（守护进程）往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie ）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在 Linux 下可以简单地将SIGCHLD 信号的操作设为 SIG_IGN： <code>signal(SIGCHLD,SIG_IGN)</code>。这样，内核在子进程结束时不会产生僵尸进程。这一点与 BSD4 不同，BSD4 下必须显式等待子进程结束才能释放僵尸进程。</p></li></ol><a id="more"></a><h4 id="使用-Python-实现守护进程"><a href="#使用-Python-实现守护进程" class="headerlink" title="使用 Python 实现守护进程"></a>使用 Python 实现守护进程</h4><p>以下 Python2.x 代码引用自 <a href="http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/" target="_blank" rel="noopener">《A simple unix/linux daemon in Python》</a> ，作者文章中有兼容 Python 3 的代码下载。下面代码实现了一个守护进程基类，子类可以简单地继承并实现 <code>run()</code> 方法来在守护进程中工作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os, time, atexit</span><br><span class="line"><span class="keyword">from</span> signal <span class="keyword">import</span> SIGTERM</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daemon</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A generic daemon class.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage: subclass the Daemon class and override the run() method</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pidfile, stdin=<span class="string">'/dev/null'</span>, stdout=<span class="string">'/dev/null'</span>, stderr=<span class="string">'/dev/null'</span>)</span>:</span></span><br><span class="line">self.stdin = stdin</span><br><span class="line">self.stdout = stdout</span><br><span class="line">self.stderr = stderr</span><br><span class="line">self.pidfile = pidfile</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">daemonize</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">do the UNIX double-fork magic, see Stevens' "Advanced</span></span><br><span class="line"><span class="string">Programming in the UNIX Environment" for details (ISBN 0201563177)</span></span><br><span class="line"><span class="string">http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid &gt; <span class="number">0</span>:</span><br><span class="line"><span class="comment"># exit first parent</span></span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> OSError, e:</span><br><span class="line">sys.stderr.write(<span class="string">"fork #1 failed: %d (%s)\n"</span> % (e.errno, e.strerror))</span><br><span class="line">sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># decouple from parent environment</span></span><br><span class="line">os.chdir(<span class="string">"/"</span>)</span><br><span class="line">os.setsid()</span><br><span class="line">os.umask(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># do second fork</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid &gt; <span class="number">0</span>:</span><br><span class="line"><span class="comment"># exit from second parent</span></span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> OSError, e:</span><br><span class="line">sys.stderr.write(<span class="string">"fork #2 failed: %d (%s)\n"</span> % (e.errno, e.strerror))</span><br><span class="line">sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># redirect standard file descriptors</span></span><br><span class="line">sys.stdout.flush()</span><br><span class="line">sys.stderr.flush()</span><br><span class="line">si = file(self.stdin, <span class="string">'r'</span>)</span><br><span class="line">so = file(self.stdout, <span class="string">'a+'</span>)</span><br><span class="line">se = file(self.stderr, <span class="string">'a+'</span>, <span class="number">0</span>)</span><br><span class="line">os.dup2(si.fileno(), sys.stdin.fileno())</span><br><span class="line">os.dup2(so.fileno(), sys.stdout.fileno())</span><br><span class="line">os.dup2(se.fileno(), sys.stderr.fileno())</span><br><span class="line"></span><br><span class="line"><span class="comment"># write pidfile</span></span><br><span class="line">atexit.register(self.delpid)</span><br><span class="line">pid = str(os.getpid())</span><br><span class="line">file(self.pidfile,<span class="string">'w+'</span>).write(<span class="string">"%s\n"</span> % pid)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delpid</span><span class="params">(self)</span>:</span></span><br><span class="line">os.remove(self.pidfile)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Start the daemon</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># Check for a pidfile to see if the daemon already runs</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">pf = file(self.pidfile,<span class="string">'r'</span>)</span><br><span class="line">pid = int(pf.read().strip())</span><br><span class="line">pf.close()</span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">pid = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pid:</span><br><span class="line">message = <span class="string">"pidfile %s already exist. Daemon already running?\n"</span></span><br><span class="line">sys.stderr.write(message % self.pidfile)</span><br><span class="line">sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the daemon</span></span><br><span class="line">self.daemonize()</span><br><span class="line">self.run()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Stop the daemon</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># Get the pid from the pidfile</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">pf = file(self.pidfile,<span class="string">'r'</span>)</span><br><span class="line">pid = int(pf.read().strip())</span><br><span class="line">pf.close()</span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">pid = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> pid:</span><br><span class="line">message = <span class="string">"pidfile %s does not exist. Daemon not running?\n"</span></span><br><span class="line">sys.stderr.write(message % self.pidfile)</span><br><span class="line"><span class="keyword">return</span> <span class="comment"># not an error in a restart</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Try killing the daemon process</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">os.kill(pid, SIGTERM)</span><br><span class="line">time.sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">except</span> OSError, err:</span><br><span class="line">err = str(err)</span><br><span class="line"><span class="keyword">if</span> err.find(<span class="string">"No such process"</span>) &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> os.path.exists(self.pidfile):</span><br><span class="line">os.remove(self.pidfile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">print</span> str(err)</span><br><span class="line">sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restart</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Restart the daemon</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">self.stop()</span><br><span class="line">self.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">You should override this method when you subclass Daemon. It will be called after the process has been</span></span><br><span class="line"><span class="string">daemonized by start() or restart().</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>子类实现 <code>run()</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"><span class="keyword">from</span> daemon <span class="keyword">import</span> Daemon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDaemon</span><span class="params">(Daemon)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">daemon = MyDaemon(<span class="string">'/tmp/daemon-example.pid'</span>)</span><br><span class="line"><span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="string">'start'</span> == sys.argv[<span class="number">1</span>]:</span><br><span class="line">daemon.start()</span><br><span class="line"><span class="keyword">elif</span> <span class="string">'stop'</span> == sys.argv[<span class="number">1</span>]:</span><br><span class="line">daemon.stop()</span><br><span class="line"><span class="keyword">elif</span> <span class="string">'restart'</span> == sys.argv[<span class="number">1</span>]:</span><br><span class="line">daemon.restart()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Unknown command"</span></span><br><span class="line">sys.exit(<span class="number">2</span>)</span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"usage: %s start|stop|restart"</span> % sys.argv[<span class="number">0</span>]</span><br><span class="line">sys.exit(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;守护进程介绍&quot;&gt;&lt;a href=&quot;#守护进程介绍&quot; class=&quot;headerlink&quot; title=&quot;守护进程介绍&quot;&gt;&lt;/a&gt;守护进程介绍&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;本笔记内容主要参考自：《Advanced Programming in The Unix Environment 3rd edition》 第 13 章第 3 小节。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;守护进程是一类长时间运行的进程，一般随操作系统启动运行直到系统关闭而停止（也可以由 crond 启动，或者由用户终端 Shell 启动）。因为没有关联的控制终端，所以我们称其在后台运行，这也是守护进程最重要的特性。另一个重要的特性是守护进程必须与其运行前的环境隔离开。参考 《Advanced Programming in The Unix Environment》 第 13 章内容，编程实现守护进程有一些通用的设计规范。&lt;/p&gt;
&lt;h4 id=&quot;守护进程编码设计规范&quot;&gt;&lt;a href=&quot;#守护进程编码设计规范&quot; class=&quot;headerlink&quot; title=&quot;守护进程编码设计规范&quot;&gt;&lt;/a&gt;守护进程编码设计规范&lt;/h4&gt;&lt;p&gt;这里将介绍一些编码规范，这些规范将阻止守护进程与其运行前环境产生一些不必要的交互。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Call umask to set the file mode creation mask to a known value, usually 0. The inherited file mode creation mask could be set to deny certain permissions. If the daemon process creates files, it may want to set specific permissions. For example, if it creates files with group-read and group-write enabled, a file mode creation mask that turns off either of these permissions would undo its efforts. On the other hand, if the daemon calls library functions that result in files being created, then it might make sense to set the file mode create mask to a more restrictive value (such as 007), since the library functions might not allow the caller to specify the permissions through an explicit argument.&lt;/p&gt;
&lt;p&gt; 调用 umask 将文件创建掩码设置为一个值，通常是 0 。因为守护进程从父进程继承而来的 “文件创建掩码” 可能会屏蔽某些特定的文件操作权限。如果守护进程想要创建文件，那么便需要设置特定的文件操作权限。例如，守护进程想要创建允许用户组读和写权限的文件，继承而来的 “文件创建掩码” 屏蔽了这个权限，则创建操作不会成功。另一方面，如果后台进程调用的库函数会创建文件，但是库函数又不允许调用者通过一个明确的参数来指定文件的权限，为了安全起见将 “文件创建掩码” 设置为一个更严格的值（比如 007 ）是非常有意义和必要的。(&lt;strong&gt;注：默认情况下的 umask 值是 022 (可以用 umask 命令查看），此时你建立的文件默认权限是 644 (6-0,6-2,6-2)，建立的目录的默认权限是 755 (7-0,7-2,7-2)。使用 umask(0) 修改 “文件创建掩码” ，保证进程拥有文件的读写权限，这个操作很危险将导致新建的文件权限为 0666/world-writable 。这个操作通常用于文件创建者和修改者不是同一个用户的场景，比如：你需要创建一个文件，该文件后续会被 Web Server 修改，而 Web Server 使用的是另外一个用户运行。这种情况下为 Web Server 写文件的目录 Set Group ID（） 是个不错的选择。&lt;/strong&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Call fork and have the parent exit. This does several things. First, if the daemon was started as a simple shell command, having the parent terminate makes the shell think that the command is done. Second, the child inherits the process group ID of the parent but gets a new process ID, so we’re guaranteed that the child is not a process group leader. This is a prerequisite for the call to setsid that is done next.&lt;/p&gt;
&lt;p&gt; 调用 fork 创建子进程并使父进程退出，将守护进程放入后台运行。这个操作主要有两个目的。首先，如果守护进程是通过一个简单的 Shell 命令创建的，那么父进程结束时便会让 Shell 一并将守护进程也结束（&lt;strong&gt;注：在终端中 ctrl+c/delete 会向前台进程组所有进程发送中断信号，若父进程退出那么子进程便会被 init 进程接管进入后台运行。&lt;/strong&gt;）；其次，子进程继承得到父进程的 “进程组ID” 同时也获得了一个新的进程号，这样便能保证子进程不是 “进程组组长” ，这是下一步 setsid 操作的前提（&lt;strong&gt;注：只有当前进程不是进程组组长时，才能调用 setsid 创建新会话。&lt;/strong&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Call setsid to create a new session. The three steps listed in Section 9.5 occur.The process (a) becomes the leader of a new session, (b) becomes the leader of a new process group, and (c) is disassociated from its controlling terminal.&lt;/p&gt;
&lt;p&gt; 调用 setsid 创建一个新会话，这个调用实际会执行 3 个操作：(a) 使当前进程称为新会话的 “会话首进程”；(b) 使当前进程称为新 “进程组组长”；(c) 使当前进程脱离控制终端。（&lt;strong&gt;注：第 2 个操作使当前进程进入后台运行，这个操作接着使进程脱离原来的进程组、控制终端和会话。&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt; 在基于 System V 的系统中，有人建议再一次调用 fork 并使父进程退出，而新产生的进程将会成为真正的守护进程。这一步骤将保证守护进程不是一个 “会话首进程” ，进而阻止它重新申请获取一个控制终端。另外一种阻止守护进程重新申请获取控制终端的方法是任意时刻打开一个终端设备的时候明确指定 O_NOCTTY 标识（&lt;strong&gt;注：调用 open() 函数打开文件时，若文件是一个终端，指定 O_NOCTTY 标识后便不会让此终端成为该进程的控制终端。 &lt;/strong&gt;） 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Change the current working directory to the root directory. The current working directory inherited from the parent could be on a mounted file system. Since daemons normally exist until the system is rebooted, if the daemon stays on a mounted file system, that file system cannot be unmounted.&lt;/p&gt;
&lt;p&gt; Alternatively, some daemons might change the current working directory to a specific location where they will do all their work. For example, a line printer spooling daemon might change its working directory to its spool directory.&lt;/p&gt;
&lt;p&gt; 将当前工作目录切换到系统目录下。这是因为继承自父进程的当前工作目录可能是一个挂载的文件系统，而守护进程通常会一直运行到系统重启。如果守护进程工作在一个挂载的文件系统上，那么这个文件系统便不能被卸载。&lt;/p&gt;
&lt;p&gt; 另外，有些守护进程会把当前工作目录切换到特定的路径下，并在这些路径下完成它们的工作。例如，行式打印机守护进程通常会将当前工作目录切换到 spool 目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unneeded file descriptors should be closed. This prevents the daemon from holding open any descriptors that it may have inherited from its parent (which could be a shell or some other process). We can use our open_max function (Figure 2.17) or the getrlimit function (Section 7.11) to determine the highest descriptor and close all descriptors up to that value.&lt;/p&gt;
&lt;p&gt; 关闭不必要的文件描述符。这将阻止守护进程保持任何从父进程（Shell 或者其他进程）进程而来的文件描述符。我们可以使用 open_max 或 getrlimit 函数来查找当前优先级最高的文件描述符并关闭此描述符之下的所有其他描述符。（&lt;strong&gt;注：保持打开的文件描述符将会占用系统资源并使某系文件不能被卸载。&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Some daemons open file descriptors 0, 1, and 2 to /dev/null so that any library routines that try to read from standard input or write to standard output or standard error will have no effect. Since the daemon is not associated with a terminal device, there is nowhere for output to be displayed, nor is there anywhere to receive input from an interactive user. Even if the daemon was started from an interactive session, the daemon runs in the background, and the login session can terminate without affecting the daemon. If other users log in on the same terminal device, we wouldn’t want output from the daemon showing up on the terminal, and the users wouldn’t expect their input to be read by the daemon.&lt;/p&gt;
&lt;p&gt; 有些守护进程会将标准输入、标准输出、标准错误描述符重定向到 /dev/null，这样一来任何尝试从标准输入、标准输出或者标准错误读取守护进程信息的操作都会失败。因为守护进程不与任何终端设备关联，便没有地方显示输出或者接受用户输入。即使守护进程是由一个交互式会话创建，但由于其在后台运行，便不会受登录会话结束的影响；如果有其他用户通过当前终端登录，我们也不希望守护进程的输出出现在终端上，并且该用户的任何输入也不会被守护进程接收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（&lt;strong&gt;注：引用自 &lt;a href=&quot;http://www.cnblogs.com/mickole/p/3188321.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《linux系统编程之进程（八）：守护进程详解及创建，daemon()使用》&lt;/a&gt;&lt;/strong&gt;）处理 SIGCHLD 信号。这不是一个必须的操作，但对于某些进程，特别是服务器进程（守护进程）往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie ）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在 Linux 下可以简单地将SIGCHLD 信号的操作设为 SIG_IGN： &lt;code&gt;signal(SIGCHLD,SIG_IGN)&lt;/code&gt;。这样，内核在子进程结束时不会产生僵尸进程。这一点与 BSD4 不同，BSD4 下必须显式等待子进程结束才能释放僵尸进程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="服务端基础" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Deamon" scheme="http://yoursite.com/tags/Deamon/"/>
    
      <category term="守护进程" scheme="http://yoursite.com/tags/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="fork" scheme="http://yoursite.com/tags/fork/"/>
    
      <category term="umask" scheme="http://yoursite.com/tags/umask/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ProcessPoolExecutor In Tornado</title>
    <link href="http://yoursite.com/2015/12/10/ProcessPoolExecutor_In_Tornado/"/>
    <id>http://yoursite.com/2015/12/10/ProcessPoolExecutor_In_Tornado/</id>
    <published>2015-12-10T06:58:01.000Z</published>
    <updated>2019-10-22T15:53:03.324Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>编程时遇到的阻塞任务一般有两类：</p><ol><li>等待 I/O 就绪（I/O 密集型）；</li><li>耗时的计算工作（CPU 密集型）。</li></ol><p>遇到这类任务，通常首选考虑是否可以优化操作（主要是针对第 2 种情况），将阻塞限制在可以接受的范围内，若不行则考虑使用多线程或多进程，将阻塞操作交由其他线程（例如 .NET APM，.NET 异步编程模型使用线程池来异步执行任务）或进程（fork/exec、任务队列，或者异步委托第三方服务 API）去异步处理，然后在操作结束后取回结果。对于第 1 种情况，使用操作系统支持的非阻塞 I/O 来提供异步支持是最理想的方式， 这也是 Tornado 的核心工作原理。</p><p>由于 Tornado 工作模型的原因，通过异步库（指由系统级非阻塞 I/O 来提供支持的库）来处理 I/O 密集型操作才是 Tornado 的正确工作方式，否则一个任务出现阻塞（或者执行时间过长）就会导致其他请求不能被及时处理。遇上没有异步库支持的 I/O 操作（比如磁盘 I/O 操作，Linux 不能很好地提供异步支持）以及 CPU 密集型操作，在 Tornado 中一般我们可以简单地用下面两种方式进行处理：</p><ol><li>将阻塞操作委托给 futures 模块的 ThreadPoolExecutor/ProcessPoolExecutor 去执行；</li><li>使用 tornado + celery（RabbitMQ 或 Redis 做 Broker，<a href="https://pypi.python.org/pypi/totoro" target="_blank" rel="noopener">totoro</a>我个人弄的一个 tornado+celery 适配库，支持 RabbitMQ 和 Redis），将阻塞操作委托给 celery 执行。</li></ol><p>NOTE：python2 需要单独安装 futures 模块（pip install futures），python3 自带不需要单独安装。</p><p>这篇笔记主要是记录在使用 ProcessPoolExecutor 去执行时遇到的一些问题和最终解决方法。</p><h3 id="ThreadPoolExecutor-ProcessPoolExecutor"><a href="#ThreadPoolExecutor-ProcessPoolExecutor" class="headerlink" title="ThreadPoolExecutor/ProcessPoolExecutor"></a>ThreadPoolExecutor/ProcessPoolExecutor</h3><h4 id="如何选择-ThreadPoolExecutor-和-ProcessPoolExecutor"><a href="#如何选择-ThreadPoolExecutor-和-ProcessPoolExecutor" class="headerlink" title="如何选择 ThreadPoolExecutor 和 ProcessPoolExecutor"></a>如何选择 ThreadPoolExecutor 和 ProcessPoolExecutor</h4><p>由于 Python GIL 的原因，利用多线程（“单进程，多线程”） 去处理 CPU 密集型任务并不能有效地利用多核，提高性能。在处理 I/O 密集型任务时，由于遇到 I/O 阻塞时线程会主动释放 GIL，多线程才能明显提高性能。</p><p>基于上述原因，在 Tornado 中区分一个任务是 CPU 密集型还是 I/O 密集型很重要，前者选择 ProcessPoolExecutor，后者选择 ThreadPoolExecutor 理论上是正确的。</p><a id="more"></a><h4 id="使用-ThreadPoolExecutor"><a href="#使用-ThreadPoolExecutor" class="headerlink" title="使用 ThreadPoolExecutor"></a>使用 ThreadPoolExecutor</h4><p>下面代码使用 ThreadPoolExecutor 来执行一个阻塞操作 <code>sleep()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, division, print_function, with_statement</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockSyncOptHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">executor = ThreadPoolExecutor(<span class="number">2</span>)</span><br><span class="line">    io_loop = tornado.ioloop.IOLoop.current()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @tornado.gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">    sec = <span class="keyword">yield</span> self.sleep()</span><br><span class="line">        self.write(<span class="string">"sleep %s s"</span> % sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @run_on_executor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># mock blocking operation</span></span><br><span class="line">        sec = <span class="number">10</span></span><br><span class="line">        time.sleep(sec)</span><br><span class="line">        <span class="keyword">return</span> sec</span><br></pre></td></tr></table></figure><p>方法 <code>sleep()</code> 模拟一个阻塞 10 秒的操作，通过 <code>@run_on_executor</code> 装饰后便将方法将委托给 <code>executor</code> 执行，在执行完成后通过 <code>io_loop</code> 回调获取结果。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_on_executor</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="string">"""Decorator to run a synchronous method asynchronously on an executor.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The decorated method may be called with a ``callback`` keyword</span></span><br><span class="line"><span class="string">    argument and returns a future.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This decorator should be used only on methods of objects with attributes</span></span><br><span class="line"><span class="string">    ``executor`` and ``io_loop``.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="meta">    @functools.wraps(fn)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        callback = kwargs.pop(<span class="string">"callback"</span>, <span class="literal">None</span>)</span><br><span class="line">        future = self.executor.submit(fn, self, *args, **kwargs)</span><br><span class="line">        <span class="keyword">if</span> callback:</span><br><span class="line">            self.io_loop.add_future(future,</span><br><span class="line">                                    <span class="keyword">lambda</span> future: callback(future.result()))</span><br><span class="line">        <span class="keyword">return</span> future</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p><code>@run_on_executor</code> 提供了一种兼容 coroutine  和 callback 的模式，从这个角度来讲，我个人不是很推崇。在使用 coroutine 编程的情况，直接使用 <code>executor</code> 更直观，约束也更少（要求对象 <code>executor</code> 和 <code>io_loop</code> 属性）。如下代码所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, division, print_function, with_statement</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockSyncOptHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">executor = ThreadPoolExecutor(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @tornado.gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">    sec = <span class="keyword">yield</span> executor.executor.submit(self.sleep)</span><br><span class="line">        self.write(<span class="string">"sleep %s s"</span> % sec)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># mock blocking operation</span></span><br><span class="line">        sec = <span class="number">10</span></span><br><span class="line">        time.sleep(sec)</span><br><span class="line">        <span class="keyword">return</span> sec</span><br></pre></td></tr></table></figure><h4 id="使用-ProcessPoolExecutor"><a href="#使用-ProcessPoolExecutor" class="headerlink" title="使用 ProcessPoolExecutor"></a>使用 ProcessPoolExecutor</h4><p>因为之前都是使用 <code>ThreadPoolExecutor</code> ，在项目中没有使用过 <code>ProcessPoolExecutor</code> ，想当然的就以为前面代码将 <code>ThreadPoolExecutor</code> 改为 <code>ProcessPoolExecutor</code> 就行。结果实践时便发生了一些问题，还由于混杂着其他问题，导致定位问题花费了我不少时间。过程就略过不提，直接说问题：</p><ol><li>发生 PicklingError 异常；</li><li><code>ProcessPoolExecutor</code> 启动的子进程在 Tornado 重启时成了 “孤儿进程”。</li></ol><p>先说第一个问题，进程之间通信时，对象（数据）的传输需要序列化，在 Python 中对象序列化常用的方式是 Pickle。<code>ProcessPoolExecutor</code> 内部使用 multiprocessing 模块来提供多进程支持，与 <code>ThreadPoolExecutor</code> 相比便要求执行的函数及其参数能够 Pickable。参考 Pickle 模块的文档，在 python 中能够可 Pickable 的类型为：</p><ol><li>None, True, and False</li><li>integers, long integers, floating point numbers, complex numbers</li><li>normal and Unicode strings</li><li>tuples, lists, sets, and dictionaries containing only picklable objects</li><li>functions defined at the top level of a module</li><li>built-in functions defined at the top level of a module</li><li>classes that are defined at the top level of a module</li><li>instances of such classes whose <strong>dict</strong> or the result of calling <strong>getstate</strong>() is picklable (see section The pickle protocol for details)</li></ol><p>简单来说就是基本类型和模块级的函数及类，很显然不支持 bound 和 unbound method（<a href="http://bugs.python.org/issue9276）。这个问题在" target="_blank" rel="noopener">http://bugs.python.org/issue9276）。这个问题在</a> python3 中已经得到解决：PEP-3154。<br><img src="/2015/12/10/ProcessPoolExecutor_In_Tornado/pep_3154.png"><br>在 stackoverflow 有一些讨论可供参考：<br><a href="http://stackoverflow.com/questions/1816958/cant-pickle-type-instancemethod-when-using-pythons-multiprocessing-pool-ma" target="_blank" rel="noopener">http://stackoverflow.com/questions/1816958/cant-pickle-type-instancemethod-when-using-pythons-multiprocessing-pool-ma</a><br><a href="http://stackoverflow.com/questions/7016567/picklingerror-when-using-multiprocessing" target="_blank" rel="noopener">http://stackoverflow.com/questions/7016567/picklingerror-when-using-multiprocessing</a></p><p>有了上面的解释便很容易理解第一个问题发生的原因：<code>self.sleep()</code> 是一个 bound method ，是不能被 Pickle 的，所以不能使用 <code>ProcessPoolExecutor</code> 去执行。若要使用 <code>ProcessPoolExecutor</code> ，可以将其改为模块级函数。</p><p>对于第二个问题，产生 “孤儿进程” 有几种情况：</p><ol><li><p>在 debug=True 模式下，Tornado 默认会启用 autoreload 机制，该机制会在应用程序的 Python 代码发生变化时自动通过 exec 重新加载代码。此时，由于 <code>ProcessPoolExecutor</code> 的子进程是 fork 出来的（可简单理解为父进程的拷贝），主进程通过 exec 重新加载代码时会遇到端口被（子进程）占用而无法重启并异常退出，导致这些子进程被 init 接管成为 “孤儿进程”。</p></li><li><p>另一种情况下，通过 supervisor 来管理 Tornado 进程，没有设置 stopasgroup=true/killasgroup=true，导致通过 supervisor 来停止应用时只有主进程能收到停止信号而退出，子进程便成了 “孤儿进程”。</p></li><li><p>还有一种情况是主进程注册了停止信号处理函数，fork 的子进程会默认继承父进程的信号处理函数。若停止信号处理函数没有考虑到这个问题，导致主进程能正常退出，子进程却忽略停止信号。比如我个人项目中为了尽可能不影响请求处理过程会为 Tornado 主进程注册停止信号处理函数，该函数首先停止接受新的请求，然后在一段时间内循环检测 IOLoop 中是否还有未处理的回调（包括定时回调），没有就主动退出，否则等待该段时间后强制退出。这个检测过程本身又是依赖 IOLoop 的定时回调。这样的逻辑在主进程中没有问题，但是子进程中由于 COW 的 IOLoop 是个拷贝，本身没有运行，故导致子进程无法像主进程一样循环检测并退出。单进程运行 Tornado 时没有问题，一旦使用了子进程便出现 “孤儿进程” 的问题。</p></li></ol><p>NOTE: 一些关于进程退出的知识点：</p><ol><li><p>在 Linux 中守护进程（无关联控制终端，既是会话首进程又是进程组组长）被 kill 时会向该组每个进程发送 SIGHUP ，导致组中进程被中止。</p></li><li><p>普通会话首进程被 kill 时向前台进程组所有进程发送 SIGHUP 信号，导致前台进程组进程终止，但后台进程组不受影响；在终端中 ctrl+c/delete 会前台进程组所有进程发送中断信号。</p></li><li><p>一般进程（包括进程组组长）被 kill 时不影响所属进程组的其他进程，若是进程组组长进程被 kill，则子进程由 init 接管。</p></li><li><p>更多关于进程的退出的信息，请通过 Linux 进程组、会话、终端等相关知识来了解。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;编程时遇到的阻塞任务一般有两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;等待 I/O 就绪（I/O 密集型）；&lt;/li&gt;
&lt;li&gt;耗时的计算工作（CPU 密集型）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;遇到这类任务，通常首选考虑是否可以优化操作（主要是针对第 2 种情况），将阻塞限制在可以接受的范围内，若不行则考虑使用多线程或多进程，将阻塞操作交由其他线程（例如 .NET APM，.NET 异步编程模型使用线程池来异步执行任务）或进程（fork/exec、任务队列，或者异步委托第三方服务 API）去异步处理，然后在操作结束后取回结果。对于第 1 种情况，使用操作系统支持的非阻塞 I/O 来提供异步支持是最理想的方式， 这也是 Tornado 的核心工作原理。&lt;/p&gt;
&lt;p&gt;由于 Tornado 工作模型的原因，通过异步库（指由系统级非阻塞 I/O 来提供支持的库）来处理 I/O 密集型操作才是 Tornado 的正确工作方式，否则一个任务出现阻塞（或者执行时间过长）就会导致其他请求不能被及时处理。遇上没有异步库支持的 I/O 操作（比如磁盘 I/O 操作，Linux 不能很好地提供异步支持）以及 CPU 密集型操作，在 Tornado 中一般我们可以简单地用下面两种方式进行处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将阻塞操作委托给 futures 模块的 ThreadPoolExecutor/ProcessPoolExecutor 去执行；&lt;/li&gt;
&lt;li&gt;使用 tornado + celery（RabbitMQ 或 Redis 做 Broker，&lt;a href=&quot;https://pypi.python.org/pypi/totoro&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;totoro&lt;/a&gt;我个人弄的一个 tornado+celery 适配库，支持 RabbitMQ 和 Redis），将阻塞操作委托给 celery 执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;NOTE：python2 需要单独安装 futures 模块（pip install futures），python3 自带不需要单独安装。&lt;/p&gt;
&lt;p&gt;这篇笔记主要是记录在使用 ProcessPoolExecutor 去执行时遇到的一些问题和最终解决方法。&lt;/p&gt;
&lt;h3 id=&quot;ThreadPoolExecutor-ProcessPoolExecutor&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor-ProcessPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor/ProcessPoolExecutor&quot;&gt;&lt;/a&gt;ThreadPoolExecutor/ProcessPoolExecutor&lt;/h3&gt;&lt;h4 id=&quot;如何选择-ThreadPoolExecutor-和-ProcessPoolExecutor&quot;&gt;&lt;a href=&quot;#如何选择-ThreadPoolExecutor-和-ProcessPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;如何选择 ThreadPoolExecutor 和 ProcessPoolExecutor&quot;&gt;&lt;/a&gt;如何选择 ThreadPoolExecutor 和 ProcessPoolExecutor&lt;/h4&gt;&lt;p&gt;由于 Python GIL 的原因，利用多线程（“单进程，多线程”） 去处理 CPU 密集型任务并不能有效地利用多核，提高性能。在处理 I/O 密集型任务时，由于遇到 I/O 阻塞时线程会主动释放 GIL，多线程才能明显提高性能。&lt;/p&gt;
&lt;p&gt;基于上述原因，在 Tornado 中区分一个任务是 CPU 密集型还是 I/O 密集型很重要，前者选择 ProcessPoolExecutor，后者选择 ThreadPoolExecutor 理论上是正确的。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
      <category term="ioloop" scheme="http://yoursite.com/tags/ioloop/"/>
    
      <category term="futures" scheme="http://yoursite.com/tags/futures/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://yoursite.com/tags/ThreadPoolExecutor/"/>
    
      <category term="ProcessPoolExecutor" scheme="http://yoursite.com/tags/ProcessPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>tornado.http1connection.HTTP1Connection 消息解析实现</title>
    <link href="http://yoursite.com/2015/11/02/tornado.http1connection.HTTP1Connection/"/>
    <id>http://yoursite.com/2015/11/02/tornado.http1connection.HTTP1Connection/</id>
    <published>2015-11-02T03:45:01.000Z</published>
    <updated>2019-10-22T15:53:03.340Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><code>HTTP1Connection</code> 是 HTTP/1.x 连接的抽象，可作为 client 发起请求和解析响应，也可作为 server 接收请求和回应响应。这里主要分析 <code>HTTP1Connection</code> 中怎样实现对请求和响应数据的解析的。关于请求的发起和回应响应，涉及到如何写的实现，将在后续文章中分析。</p><p>在具体分析代码实现之前，先介绍一下 HTTP/1.x 相关的内容以方便后面对代码的理解。</p><h3 id="HTTP-1-x-简介"><a href="#HTTP-1-x-简介" class="headerlink" title="HTTP/1.x 简介"></a>HTTP/1.x 简介</h3><p>HTTP 协议是一个应用层协议，协议本身并没有规定使用它或它支持的层。事实上，HTTP 可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。在TCP/IP 协议族上使用 TCP 作为其传输层。</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>HTTP 协议有多个版本 HTTP/1.x 和 HTTP/2.0。目前使用最广泛的是 HTTP/1.x，包括 HTTP/1.0 和 HTTP/1.1 两个版本，后者是对前者的升级改进，最大的不同有两点：</p><ol><li>默认支持持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</li><li>支持 Host 请求头字段，使得 Web 服务器可以在同一个 IP 和 Port 上使用不同的 HostName 来创建多个虚拟 Web 站点。</li></ol><h4 id="请求（Request）"><a href="#请求（Request）" class="headerlink" title="请求（Request）"></a>请求（Request）</h4><h5 id="请求消息（Request-Message）"><a href="#请求消息（Request-Message）" class="headerlink" title="请求消息（Request Message）"></a>请求消息（Request Message）</h5><p>请求由客户端向服务器端发出，请求消息由下面 4 部分组成（<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1" target="_blank" rel="noopener">RFC 2616 Request</a>）：</p><ol><li>Request-Line，请求行，格式为：Method SP Request-URI SP HTTP-Version CRLF， eg. “GET /foo HTTP/1.1”。</li><li>Request Header Fields，请求头，*(( general-header | request-header | entity-header ) CRLF)，在 HTTP/1.1 中除了 Host 外其他请求头都是可选的。</li><li>空行，CRLF。</li><li>消息体，[ message-body ]</li></ol><p>每个头字段由一个字段名称（name） + 冒号（:） + 字段值(value), 三部分组成，name 是大小写无关的，value 前可以添加任何数量的空格符，头字段可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p><h5 id="请求方法（Method）"><a href="#请求方法（Method）" class="headerlink" title="请求方法（Method）"></a>请求方法（Method）</h5><p>HTTP/1.x 中定义了 8 中请求方法来以不同的方式操作指定的资源：OPTIONS/GET/HEAD/POST/PUT/DELETE/TRACE/CONNECT/PATCH，方法名称是区分大小写的，具体的定义请参考 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1" target="_blank" rel="noopener">RFC 2616 Request Method</a>。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码 405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码 501（Not Implemented）。</p><p><strong> HTTP 服务器至少应该实现 GET 和 HEAD 方法，其他方法都是可选的。 </strong> GET 和 HEAD 方法，除了进行获取资源信息外，不具有其他意义，理论上是”安全的“（实际上其结果取决于服务器的实现）。<br><a id="more"></a></p><h4 id="响应（Response）"><a href="#响应（Response）" class="headerlink" title="响应（Response）"></a>响应（Response）</h4><h5 id="响应消息（Response-Message）"><a href="#响应消息（Response-Message）" class="headerlink" title="响应消息（Response Message）"></a>响应消息（Response Message）</h5><p>服务器端接收处理了客户端请求后，向客户端回应一个响应消息，消息由下面 4 部分组成（<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6" target="_blank" rel="noopener">RFC 2616 Response</a>）：</p><ol><li>Status-Line，响应状态行，格式为：HTTP-Version SP Status-Code SP Reason-Phrase CRLF，eg. “HTTP/1.1 200 OK”。</li><li>Response Header Fields，响应头， *(( general-header | response-header | entity-header ) CRLF)。</li><li>空行，CRLF。</li><li>消息体，[ message-body ]</li></ol><h5 id="状态码（Status-Code）"><a href="#状态码（Status-Code）" class="headerlink" title="状态码（Status Code）"></a>状态码（Status Code）</h5><p>HTTP 响应的第一行都是状态行（Status Line），依次是当前 HTTP 版本号，3 位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p><p>状态代码的第一个数字代表当前响应的类型，目前有 5 种状态：</p><ol><li>1xx 消息——请求已被服务器接收，继续处理</li><li>2xx 成功——请求已成功被服务器接收、理解、并接受</li><li>3xx 重定向——需要后续操作才能完成这一请求</li><li>4xx 请求错误——请求含有词法错误或者无法被执行</li><li>5xx 服务器错误——服务器在处理某个正确请求时发生错误</li></ol><p>虽然 <a href="http://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">RFC 2616</a> 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是 WEB 服务器开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。</p><h4 id="Keep-Alive-持久连接"><a href="#Keep-Alive-持久连接" class="headerlink" title="Keep-Alive 持久连接"></a>Keep-Alive 持久连接</h4><p>持久连接是从 HTTP/1.1 开始引入的，对于 HTTP/1.0 可以通过在请求中增加请求头 <code>Connection: keep-alive</code> 来告诉服务器使用持久连接。而 HTTP/1.1 中持久连接是默认必须的，除非显示在请求时增加请求头 <code>Connection: close</code>。</p><p>由于多个 HTTP 连接要复用同一个 TCP 连接，并且支持在应答到达前继续发送请求的 ”流线化“（stream） 方式。为了区分单个请求或者响应的边界， HTTP/1.1 引入实体头（entity-header） <code>Content-Length</code> 。<code>Content-Length</code> 指出 Meesage Body 的长度，通过这个头字段的值便可以准确判断请求或者响应的边界。</p><p><code>Content-Length</code> 实体头的引入表明了在发送请求/响应前发送端必须提前知道整个消息数据的长度（称为 buffer 模式），对于客户端请求这不是问题，但是对于服务器在实际使用中有时候就不会那么容易获取数据长度了。例如，数据来自文件或者动态生成，要知道数据长度就得在内存中开足够大的 buffer，等内容全部生成好再计算。这样很显然会增加开销和延迟。为了解决这个问题， HTTP/1.1 引入了 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6" target="_blank" rel="noopener">分块传输编码</a>，增加了一个通用头(general-header) <code>Transfer-Encoding:chunked</code> 来支持启用这个功能。</p><h5 id="分块传输编码（Transfer-Encoding-chunked）"><a href="#分块传输编码（Transfer-Encoding-chunked）" class="headerlink" title="分块传输编码（Transfer-Encoding:chunked）"></a>分块传输编码（Transfer-Encoding:chunked）</h5><p>分块传输编码允许服务器不需要预先知道发送数据的大小，而把数据分解成一系列数据块，并以一次一个或者多个块发送。<strong>通常数据块的大小是一致的，但也不总是这种情况</strong> **。</p><p>一个 HTTP 消息（请求消息或应答消息）的 Transfer-Encoding 消息头的值为 chunked，那么，消息体由数量未定的块组成，并以最后一个大小为  0的块为结束。</p><ol><li>每一个非空的块都以该块包含数据的字节数（十六进制表示）开始，跟随一个 CRLF，然后是数据本身，最后跟 CRLF 结束。在一些实现中，块大小和 CRLF 之间填充有白空格（0x20）。</li><li>最后一块由块大小（0），一些可选的填充白空格，以及 CRLF。最后一块不包含任何数据，但是可以发送包含消息头字段的可选尾部，最后以 CRLF 结尾。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*******************************************************</span><br><span class="line"> HTTP/1.1 200 OK</span><br><span class="line"> Content-Type: text/plain</span><br><span class="line"> Transfer-Encoding: chunked</span><br><span class="line"> (空行)</span><br><span class="line"> 25</span><br><span class="line"> This is the data in the first chunk</span><br><span class="line"> 1C</span><br><span class="line"> and this is the second one</span><br><span class="line"> 3</span><br><span class="line"> con</span><br><span class="line"> 8</span><br><span class="line"> sequence</span><br><span class="line"> 0</span><br><span class="line"> (空行)</span><br><span class="line">********************************************************</span><br></pre></td></tr></table></figure><p>HTTP 1.1引入分块传输编码提供了以下几点好处：</p><ol><li><p>HTTP 分块传输编码允许服务器为动态生成的内容维持 HTTP 持久链接。通常，持久链接需要服务器在开始发送消息体前发送 Content-Length 消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。</p></li><li><p>分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过 HTTP 消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。</p></li><li><p>HTTP 服务器有时使用压缩 （gzip 或 deflate）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。</p></li></ol><p>参考文档:<br><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">分块传输编码</a></p><h4 id="HTTP-消息压缩"><a href="#HTTP-消息压缩" class="headerlink" title="HTTP 消息压缩"></a>HTTP 消息压缩</h4><p><strong><em> HTTP 支持对消息体进行压缩传输（不支持对 HTTP 头部进行压缩） </em></strong>，以减少网络传输的数据量增加传输效率。这是通过 HTTP 内容编码头字段来支持的，实际上 HTTP 消息压缩在协议上是 HTTP 内容编码的一种。</p><p>对于客户端，请求时通过发送请求头 <code>Accept-Encoding</code> 来向服务器表明客户端是否支持压缩，以及支持的压缩格式。例如， ”Accept-Encoding: gzip, deflate, sdch“  表明客户端支持 gzip, deflate, sdch 压缩格式。</p><p>对于服务器端，响应时通过发送响应头 <code>Content-Encoding</code> 来向客户端说明响应数据是否压缩，以及压缩的格式。例如，”Content-Encoding:gzip“ 表示使用的是 gzip 压缩格式。如果没有 ”Content-Encoding“ 头或者 ”Content-Encoding:identity“ 则表明消息没有被编码，也就没有被压缩。</p><p>很显然，服务端响应消息使用的编码方式（压缩格式）必须是客户端所能支持的（由请求的 <code>Accept-Encoding</code>  值来声明）。</p><p><strong> 注：</strong>常见的压缩的方式 gzip, deflate 的关系。<strong>在 HTTP 内容编码中，deflate 表示的是 zlib。gzip 和 zlib 是两种不同的封装格式，其数据压缩都是使用的 deflate 算法，只是数据封装时使用的头部和尾部不同（头部和尾部主要是为了保存文件属性和校验信息）。所以通用的开源压缩库 ”zlib“ 同时支持 gzip，zlib 格式。</strong></p><h3 id="HTTP1Connection"><a href="#HTTP1Connection" class="headerlink" title="HTTP1Connection"></a>HTTP1Connection</h3><p><code>read_response</code> 方法是 HTTP 消息解析的入口，从方法名称看这个方法仅仅针对响应，由前面 HTTP/1.x 请求和响应数据格式可以看到二者的数据格式上是一致的，所以 <code>read_response</code> 实现上同时支持对请求和响应的数据解析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_response</span><span class="params">(self, delegate)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.params.decompress:</span><br><span class="line">        delegate = _GzipMessageDelegate(delegate, self.params.chunk_size)</span><br><span class="line">    <span class="keyword">return</span> self._read_message(delegate)</span><br></pre></td></tr></table></figure><p><code>delegate</code> 是一个 <code>HTTPMessageDelegate</code> 类型，如果支持 HTTP gzip 压缩则需要被 <code>_GzipMessageDelegate</code> 再次包装一下。 <code>_GzipMessageDelegate</code> 类型之前已经有介绍，其实现内部负责解压的是 <code>GzipDecompressor</code> 和 <code>zlib</code> 模块。python 的 <code>zlib</code> 模块同时支持 <code>gzip</code> 和 <code>zlib</code>，但其 API 有些隐晦，针对 <code>gzip</code> 需要这样初始化 <code>decompressor</code> 实例（<a href="http://stackoverflow.com/questions/1838699/how-can-i-decompress-a-gzip-stream-with-zlib" target="_blank" rel="noopener">how-can-i-decompress-a-gzip-stream-with-zlib</a>）: <code>zlib.decompressobj(16 + zlib.MAX_WBITS)</code>。</p><p>HTTP 消息解析的逻辑都被封装在 <code>_read_message</code> 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_read_message</span><span class="params">(self, delegate)</span>:</span></span><br><span class="line">    need_delegate_close = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 消息头与消息体之间由一个空行分开</span></span><br><span class="line">        header_future = self.stream.read_until_regex(</span><br><span class="line">            <span class="string">b"\r?\n\r?\n"</span>,</span><br><span class="line">            max_bytes=self.params.max_header_size)</span><br><span class="line">        <span class="keyword">if</span> self.params.header_timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            header_data = <span class="keyword">yield</span> header_future</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                header_data = <span class="keyword">yield</span> gen.with_timeout(</span><br><span class="line">                    self.stream.io_loop.time() + self.params.header_timeout,</span><br><span class="line">                    header_future,</span><br><span class="line">                    io_loop=self.stream.io_loop)</span><br><span class="line">            <span class="keyword">except</span> gen.TimeoutError:</span><br><span class="line">                self.close()</span><br><span class="line">                <span class="keyword">raise</span> gen.Return(<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 解析消息头，分离头字段和首行（request-line/status-line）</span></span><br><span class="line">        start_line, headers = self._parse_headers(header_data)</span><br><span class="line">        <span class="comment"># 作为 client 解析的是 server 的 response，作为 server 解析的是 client 的 request。</span></span><br><span class="line">        <span class="comment"># response 与 request 的 start_line(status-line/request-line) 的字段内容不同：</span></span><br><span class="line">        <span class="comment"># 1. response's status-line: HTTP-Version SP Status-Code SP Reason-Phrase CRLF</span></span><br><span class="line">        <span class="comment"># 2. request's request-line：Method SP Request-URI SP HTTP-Version CRLF</span></span><br><span class="line">        <span class="comment"># start_line 的值是一个 namedtuple。</span></span><br><span class="line">        <span class="keyword">if</span> self.is_client:</span><br><span class="line">            start_line = httputil.parse_response_start_line(start_line)</span><br><span class="line">            self._response_start_line = start_line</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start_line = httputil.parse_request_start_line(start_line)</span><br><span class="line">            self._request_start_line = start_line</span><br><span class="line">            self._request_headers = headers</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 非 keep-alive 的请求或响应处理完成后要关闭连接。</span></span><br><span class="line">        self._disconnect_on_finish = <span class="keyword">not</span> self._can_keep_alive(</span><br><span class="line">            start_line, headers)</span><br><span class="line">        need_delegate_close = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">with</span> _ExceptionLoggingContext(app_log):</span><br><span class="line">            header_future = delegate.headers_received(start_line, headers)</span><br><span class="line">            <span class="keyword">if</span> header_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 如果 header_future 是一个 `Future` 实例，则要等到完成才读取 body。</span></span><br><span class="line">                <span class="keyword">yield</span> header_future</span><br><span class="line">        <span class="comment"># websocket ？？？</span></span><br><span class="line">        <span class="keyword">if</span> self.stream <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># We've been detached.</span></span><br><span class="line">            need_delegate_close = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">raise</span> gen.Return(<span class="literal">False</span>)</span><br><span class="line">        skip_body = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self.is_client:</span><br><span class="line">            <span class="comment"># 作为 client 如果发起的是 HEAD 请求，那么 server response 应该无消息体</span></span><br><span class="line">            <span class="keyword">if</span> (self._request_start_line <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span></span><br><span class="line">                    self._request_start_line.method == <span class="string">'HEAD'</span>):</span><br><span class="line">                skip_body = <span class="literal">True</span></span><br><span class="line">            code = start_line.code</span><br><span class="line">            <span class="keyword">if</span> code == <span class="number">304</span>:</span><br><span class="line">                <span class="comment"># 304 responses may include the content-length header</span></span><br><span class="line">                <span class="comment"># but do not actually have a body.</span></span><br><span class="line">                <span class="comment"># http://tools.ietf.org/html/rfc7230#section-3.3</span></span><br><span class="line">                skip_body = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> code &gt;= <span class="number">100</span> <span class="keyword">and</span> code &lt; <span class="number">200</span>:</span><br><span class="line">                <span class="comment"># 1xx responses should never indicate the presence of</span></span><br><span class="line">                <span class="comment"># a body.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">'Content-Length'</span> <span class="keyword">in</span> headers <span class="keyword">or</span></span><br><span class="line">                    <span class="string">'Transfer-Encoding'</span> <span class="keyword">in</span> headers):</span><br><span class="line">                    <span class="keyword">raise</span> httputil.HTTPInputError(</span><br><span class="line">                        <span class="string">"Response code %d cannot have body"</span> % code)</span><br><span class="line">                <span class="comment"># <span class="doctag">TODO:</span> client delegates will get headers_received twice</span></span><br><span class="line">                <span class="comment"># in the case of a 100-continue.  Document or change?</span></span><br><span class="line">                <span class="keyword">yield</span> self._read_message(delegate)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 100-continue 这个状态码是在 HTTP/1.1 中为了提高传输效率而设置的。当</span></span><br><span class="line">            <span class="comment"># client 需要 POST 较大数据给 WebServer 时，可以在发送 HTTP 请求时带上</span></span><br><span class="line">            <span class="comment"># Expect: 100-continue，WebServer 如果接受这个请求则应答一个</span></span><br><span class="line">            <span class="comment"># ``HTTP/1.1 100 (Continue)``，那么 client 就继续传输 request body，</span></span><br><span class="line">            <span class="comment"># 否则应答 ``HTTP/1.1 417 Expectation Failed`` client 就放弃传输剩余</span></span><br><span class="line">            <span class="comment"># 的数据。（注：Expect 头部域，用于指出客户端要求的特殊服务器行为采用扩展语法</span></span><br><span class="line">            <span class="comment"># 定义，以方便扩展。）</span></span><br><span class="line">            <span class="keyword">if</span> (headers.get(<span class="string">"Expect"</span>) == <span class="string">"100-continue"</span> <span class="keyword">and</span></span><br><span class="line">                    <span class="keyword">not</span> self._write_finished):</span><br><span class="line">                self.stream.write(<span class="string">b"HTTP/1.1 100 (Continue)\r\n\r\n"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> skip_body:</span><br><span class="line">            body_future = self._read_body(</span><br><span class="line">                start_line.code <span class="keyword">if</span> self.is_client <span class="keyword">else</span> <span class="number">0</span>, headers, delegate)</span><br><span class="line">            <span class="keyword">if</span> body_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> self._body_timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">yield</span> body_future</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        <span class="keyword">yield</span> gen.with_timeout(</span><br><span class="line">                            self.stream.io_loop.time() + self._body_timeout,</span><br><span class="line">                            body_future, self.stream.io_loop)</span><br><span class="line">                    <span class="keyword">except</span> gen.TimeoutError:</span><br><span class="line">                        gen_log.info(<span class="string">"Timeout reading body from %s"</span>,</span><br><span class="line">                                     self.context)</span><br><span class="line">                        self.stream.close()</span><br><span class="line">                        <span class="keyword">raise</span> gen.Return(<span class="literal">False</span>)</span><br><span class="line">        self._read_finished = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 对 client mode ，response 解析完成就调用 HTTPMessageDelegate.finish() 方法是合适的；</span></span><br><span class="line">        <span class="comment"># 对 server mode ，_write_finished 表示 response 是否发送完成，未完成前调用</span></span><br><span class="line">        <span class="comment"># HTTPMessageDelegate.finish() 方法是合适的；</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._write_finished <span class="keyword">or</span> self.is_client:</span><br><span class="line">            need_delegate_close = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">with</span> _ExceptionLoggingContext(app_log):</span><br><span class="line">                delegate.finish()</span><br><span class="line">        <span class="comment"># If we're waiting for the application to produce an asynchronous</span></span><br><span class="line">        <span class="comment"># response, and we're not detached, register a close callback</span></span><br><span class="line">        <span class="comment"># on the stream (we didn't need one while we were reading)</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># <span class="doctag">NOTE:</span>_finish_future resolves when all data has been written and flushed</span></span><br><span class="line">        <span class="comment"># to the IOStream.</span></span><br><span class="line">        <span class="comment"># 等待异步响应完成，所有数据都写入 fd，才继续后续处理，详细见 _finish_request/finish 方法实现。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> self._finish_future.done() <span class="keyword">and</span></span><br><span class="line">                self.stream <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span></span><br><span class="line">                <span class="keyword">not</span> self.stream.closed()):</span><br><span class="line">            self.stream.set_close_callback(self._on_connection_close)</span><br><span class="line">            <span class="keyword">yield</span> self._finish_future</span><br><span class="line">        <span class="comment"># 对于 client mode，处理完响应后如果不是 keep-alive 就断开连接。</span></span><br><span class="line">        <span class="comment"># 对于 server mode，需要在 response 完成后才断开连接，详细见 _finish_request/finish 方法实现。</span></span><br><span class="line">        <span class="keyword">if</span> self.is_client <span class="keyword">and</span> self._disconnect_on_finish:</span><br><span class="line">            self.close()</span><br><span class="line">        <span class="keyword">if</span> self.stream <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> gen.Return(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">except</span> httputil.HTTPInputError <span class="keyword">as</span> e:</span><br><span class="line">        gen_log.info(<span class="string">"Malformed HTTP message from %s: %s"</span>,</span><br><span class="line">                     self.context, e)</span><br><span class="line">        self.close()</span><br><span class="line">        <span class="keyword">raise</span> gen.Return(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 连接 “关闭” 前还没能结束处理请求（call HTTPMessageDelegate.finish()），则</span></span><br><span class="line">        <span class="comment"># call  HTTPMessageDelegate.on_connection_close()</span></span><br><span class="line">        <span class="keyword">if</span> need_delegate_close:</span><br><span class="line">            <span class="keyword">with</span> _ExceptionLoggingContext(app_log):</span><br><span class="line">                delegate.on_connection_close()</span><br><span class="line">        self._clear_callbacks()</span><br><span class="line">    <span class="keyword">raise</span> gen.Return(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><code>_read_body</code> 方法负责负责读取 HTTP 消息的消息体，按照前面 HTTP 协议的定义，消息体的读取要分成 3 中情况：</p><ol><li><p>非持久连接方式，消息体的读取以连接关闭作为界限；</p></li><li><p>持久连接方式下，通过 <code>Content-Length</code> 指定消息体的长度；</p></li><li><p>持久连接下采用 <code>Transfer-Encoding:chunked</code> 分块传输消息体。</p></li></ol><p>上述 3 种情况对消息体的读取分别封装在方法 <code>language_read_body_until_close</code>、<code>_read_fixed_body</code>、<code>_read_chunked_body</code> 中。如下代码所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_read_body</span><span class="params">(self, code, headers, delegate)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">"Content-Length"</span> <span class="keyword">in</span> headers:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">","</span> <span class="keyword">in</span> headers[<span class="string">"Content-Length"</span>]:</span><br><span class="line">            <span class="comment"># Proxies sometimes cause Content-Length headers to get</span></span><br><span class="line">            <span class="comment"># duplicated.  If all the values are identical then we can</span></span><br><span class="line">            <span class="comment"># use them but if they differ it's an error.</span></span><br><span class="line">            pieces = re.split(<span class="string">r',\s*'</span>, headers[<span class="string">"Content-Length"</span>])</span><br><span class="line">            <span class="keyword">if</span> any(i != pieces[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> pieces):</span><br><span class="line">                <span class="keyword">raise</span> httputil.HTTPInputError(</span><br><span class="line">                    <span class="string">"Multiple unequal Content-Lengths: %r"</span> %</span><br><span class="line">                    headers[<span class="string">"Content-Length"</span>])</span><br><span class="line">            headers[<span class="string">"Content-Length"</span>] = pieces[<span class="number">0</span>]</span><br><span class="line">        content_length = int(headers[<span class="string">"Content-Length"</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> content_length &gt; self._max_body_size:</span><br><span class="line">            <span class="keyword">raise</span> httputil.HTTPInputError(<span class="string">"Content-Length too long"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        content_length = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 204 No Content，表示服务器已经完成了请求，但是返回的信息不包括 message-body，但是可以通过</span></span><br><span class="line">    <span class="comment"># header fields 返回一些用于更新的元数据。</span></span><br><span class="line">    <span class="keyword">if</span> code == <span class="number">204</span>:</span><br><span class="line">        <span class="comment"># This response code is not allowed to have a non-empty body,</span></span><br><span class="line">        <span class="comment"># and has an implicit length of zero instead of read-until-close.</span></span><br><span class="line">        <span class="comment"># http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Transfer-Encoding"</span> <span class="keyword">in</span> headers <span class="keyword">or</span></span><br><span class="line">                content_length <span class="keyword">not</span> <span class="keyword">in</span> (<span class="literal">None</span>, <span class="number">0</span>)):</span><br><span class="line">            <span class="keyword">raise</span> httputil.HTTPInputError(</span><br><span class="line">                <span class="string">"Response with code %d should not have body"</span> % code)</span><br><span class="line">        content_length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 持久连接： Content-Length or Transfer-Encoding</span></span><br><span class="line">    <span class="keyword">if</span> content_length <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self._read_fixed_body(content_length, delegate)</span><br><span class="line">    <span class="keyword">if</span> headers.get(<span class="string">"Transfer-Encoding"</span>) == <span class="string">"chunked"</span>:</span><br><span class="line">        <span class="keyword">return</span> self._read_chunked_body(delegate)</span><br><span class="line">    <span class="comment"># 非持久连接</span></span><br><span class="line">    <span class="keyword">if</span> self.is_client:</span><br><span class="line">        <span class="keyword">return</span> self._read_body_until_close(delegate)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>代码中对于特殊情况的下 <code>Content-Length</code> 进行了一些额外的处理：</p><ol><li><p>由于一些代理可能会导致 <code>Content-Length</code> 的值重复，需要判断这些值是否一致，不一致的情况要作为错误处理；</p></li><li><p>HTTP Status Code 是 204 的时候，消息不应该含有消息体，所以不能出现 <code>Transfer-Encoding</code> 头字段。</p></li></ol><p><code>language_read_body_until_close</code> 和 <code>_read_fixed_body</code> 方法实现都很简单，委托 stream 相关方法就好了。<code>_read_chunked_body</code> 方法需要按照前述的 <code>Transfer-Encoding:chuncked</code> 消息组成格式进行解析，相对复杂一点点，下面是其代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_read_chunked_body</span><span class="params">(self, delegate)</span>:</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> "chunk extensions" http://tools.ietf.org/html/rfc2616#section-3.6.1</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># *************************** chunk extensions *************************</span></span><br><span class="line">    <span class="comment"># 使用分块传输编码（chunked transfer encoding）时，消息体由数量未定的块组成，并以最</span></span><br><span class="line">    <span class="comment"># 后一个大小为 0 的块结束。</span></span><br><span class="line">    <span class="comment"># 1. 每一个非空的块都以该块包含数据的字节数（十六进制表示）开始，跟随一个 CRLF，然后是数</span></span><br><span class="line">    <span class="comment"># 据本身，最后跟 CRLF 结束。在一些实现中，块大小和 CRLF 之间填充有白空格（0x20）。</span></span><br><span class="line">    <span class="comment"># 2. 最后一块由块大小（0），一些可选的填充白空格，以及 CRLF。最后一块不包含任何数据，但</span></span><br><span class="line">    <span class="comment"># 是可以发送包含消息头字段的可选尾部（注：以下代码实现不支持可选尾部），最后以 CRLF 结尾。</span></span><br><span class="line">    <span class="comment"># ----------------------------eg. start--------------------------------</span></span><br><span class="line">    <span class="comment"># HTTP/1.1 200 OK\r\n</span></span><br><span class="line">    <span class="comment"># Content-Type: text/plain\r\n</span></span><br><span class="line">    <span class="comment"># Transfer-Encoding: chunked\r\n</span></span><br><span class="line">    <span class="comment"># \r\n</span></span><br><span class="line">    <span class="comment"># 25\r\n</span></span><br><span class="line">    <span class="comment"># This is the data in the first chunk\r\n</span></span><br><span class="line">    <span class="comment"># 1C\r\n</span></span><br><span class="line">    <span class="comment"># and this is the second one\r\n</span></span><br><span class="line">    <span class="comment"># 3\r\n</span></span><br><span class="line">    <span class="comment"># con\r\n</span></span><br><span class="line">    <span class="comment"># 8\r\n</span></span><br><span class="line">    <span class="comment"># sequence\r\n</span></span><br><span class="line">    <span class="comment"># 0\r\n</span></span><br><span class="line">    <span class="comment"># \r\n</span></span><br><span class="line">    <span class="comment"># ----------------------------eg. end--------------------------------</span></span><br><span class="line">    <span class="comment"># **********************************************************************</span></span><br><span class="line">    total_size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        chunk_len = <span class="keyword">yield</span> self.stream.read_until(<span class="string">b"\r\n"</span>, max_bytes=<span class="number">64</span>)</span><br><span class="line">        chunk_len = int(chunk_len.strip(), <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> chunk_len == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        total_size += chunk_len</span><br><span class="line">        <span class="keyword">if</span> total_size &gt; self._max_body_size:</span><br><span class="line">            <span class="keyword">raise</span> httputil.HTTPInputError(<span class="string">"chunked body too large"</span>)</span><br><span class="line">        bytes_to_read = chunk_len</span><br><span class="line">        <span class="keyword">while</span> bytes_to_read:</span><br><span class="line">            chunk = <span class="keyword">yield</span> self.stream.read_bytes(</span><br><span class="line">                min(bytes_to_read, self.params.chunk_size), partial=<span class="literal">True</span>)</span><br><span class="line">            bytes_to_read -= len(chunk)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._write_finished <span class="keyword">or</span> self.is_client:</span><br><span class="line">                <span class="keyword">with</span> _ExceptionLoggingContext(app_log):</span><br><span class="line">                    <span class="keyword">yield</span> gen.maybe_future(delegate.data_received(chunk))</span><br><span class="line">        <span class="comment"># chunk ends with \r\n</span></span><br><span class="line">        crlf = <span class="keyword">yield</span> self.stream.read_bytes(<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 如果最后一个 chunk 中包含了可选的尾部，断言会失败。可选尾部由 Trailer 头域支持，</span></span><br><span class="line">        <span class="comment"># 参考：http://tools.ietf.org/html/rfc2616#section-14.40。</span></span><br><span class="line">        <span class="comment"># 目前 tornado 中的实现不支持这个可选尾部，如果发生异常的话，可尝试判断是否是 last chunk，</span></span><br><span class="line">        <span class="comment"># 然后吞掉可选尾部。</span></span><br><span class="line">        <span class="comment"># eg.</span></span><br><span class="line">        <span class="comment"># if bytes_to_read == 0 and crlf != b"\r\n":</span></span><br><span class="line">        <span class="comment">#     yield self.stream.read_until(b"\r\n", max_bytes=self._max_body_size - total_size)</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     assert crlf == b"\r\n"</span></span><br><span class="line">        <span class="keyword">assert</span> crlf == <span class="string">b"\r\n"</span></span><br></pre></td></tr></table></figure><p>代码中已经对相应的代码做了详细注释，值得注意的是这里方法并不是完整支持 RFC 中的分块传输编码，不支持最后一块数据中包含可选尾部。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;HTTP1Connection&lt;/code&gt; 是 HTTP/1.x 连接的抽象，可作为 client 发起请求和解析响应，也可作为 server 接收请求和回应响应。这里主要分析 &lt;code&gt;HTTP1Connection&lt;/code&gt; 中怎样实现对请求和响应数据的解析的。关于请求的发起和回应响应，涉及到如何写的实现，将在后续文章中分析。&lt;/p&gt;
&lt;p&gt;在具体分析代码实现之前，先介绍一下 HTTP/1.x 相关的内容以方便后面对代码的理解。&lt;/p&gt;
&lt;h3 id=&quot;HTTP-1-x-简介&quot;&gt;&lt;a href=&quot;#HTTP-1-x-简介&quot; class=&quot;headerlink&quot; title=&quot;HTTP/1.x 简介&quot;&gt;&lt;/a&gt;HTTP/1.x 简介&lt;/h3&gt;&lt;p&gt;HTTP 协议是一个应用层协议，协议本身并没有规定使用它或它支持的层。事实上，HTTP 可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。在TCP/IP 协议族上使用 TCP 作为其传输层。&lt;/p&gt;
&lt;h4 id=&quot;版本&quot;&gt;&lt;a href=&quot;#版本&quot; class=&quot;headerlink&quot; title=&quot;版本&quot;&gt;&lt;/a&gt;版本&lt;/h4&gt;&lt;p&gt;HTTP 协议有多个版本 HTTP/1.x 和 HTTP/2.0。目前使用最广泛的是 HTTP/1.x，包括 HTTP/1.0 和 HTTP/1.1 两个版本，后者是对前者的升级改进，最大的不同有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认支持持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。&lt;/li&gt;
&lt;li&gt;支持 Host 请求头字段，使得 Web 服务器可以在同一个 IP 和 Port 上使用不同的 HostName 来创建多个虚拟 Web 站点。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;请求（Request）&quot;&gt;&lt;a href=&quot;#请求（Request）&quot; class=&quot;headerlink&quot; title=&quot;请求（Request）&quot;&gt;&lt;/a&gt;请求（Request）&lt;/h4&gt;&lt;h5 id=&quot;请求消息（Request-Message）&quot;&gt;&lt;a href=&quot;#请求消息（Request-Message）&quot; class=&quot;headerlink&quot; title=&quot;请求消息（Request Message）&quot;&gt;&lt;/a&gt;请求消息（Request Message）&lt;/h5&gt;&lt;p&gt;请求由客户端向服务器端发出，请求消息由下面 4 部分组成（&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC 2616 Request&lt;/a&gt;）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Request-Line，请求行，格式为：Method SP Request-URI SP HTTP-Version CRLF， eg. “GET /foo HTTP/1.1”。&lt;/li&gt;
&lt;li&gt;Request Header Fields，请求头，*(( general-header | request-header | entity-header ) CRLF)，在 HTTP/1.1 中除了 Host 外其他请求头都是可选的。&lt;/li&gt;
&lt;li&gt;空行，CRLF。&lt;/li&gt;
&lt;li&gt;消息体，[ message-body ]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个头字段由一个字段名称（name） + 冒号（:） + 字段值(value), 三部分组成，name 是大小写无关的，value 前可以添加任何数量的空格符，头字段可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。&lt;/p&gt;
&lt;h5 id=&quot;请求方法（Method）&quot;&gt;&lt;a href=&quot;#请求方法（Method）&quot; class=&quot;headerlink&quot; title=&quot;请求方法（Method）&quot;&gt;&lt;/a&gt;请求方法（Method）&lt;/h5&gt;&lt;p&gt;HTTP/1.x 中定义了 8 中请求方法来以不同的方式操作指定的资源：OPTIONS/GET/HEAD/POST/PUT/DELETE/TRACE/CONNECT/PATCH，方法名称是区分大小写的，具体的定义请参考 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC 2616 Request Method&lt;/a&gt;。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码 405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码 501（Not Implemented）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; HTTP 服务器至少应该实现 GET 和 HEAD 方法，其他方法都是可选的。 &lt;/strong&gt; GET 和 HEAD 方法，除了进行获取资源信息外，不具有其他意义，理论上是”安全的“（实际上其结果取决于服务器的实现）。&lt;br&gt;
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="HTTP1Connection" scheme="http://yoursite.com/tags/HTTP1Connection/"/>
    
      <category term="HTTP/1.x" scheme="http://yoursite.com/tags/HTTP-1-x/"/>
    
  </entry>
  
  <entry>
    <title>tornado.httpserver 模块解析</title>
    <link href="http://yoursite.com/2015/10/21/tornado.httpserver/"/>
    <id>http://yoursite.com/2015/10/21/tornado.httpserver/</id>
    <published>2015-10-21T09:25:01.000Z</published>
    <updated>2019-10-22T15:53:03.341Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><code>HTTPServer</code> 是 HTTP 协议的 <code>TCPServer</code> 子类实现，<code>HTTPServer</code> 覆写了 <code>handle_stream</code> 方法用于处理 HTTP 协议。与 <code>TCPServer</code> 一样，可以有三种使用模式，源码注释中写的很详细，在 <code>TCPServer</code> 源码解析的部分也已经详细讨论过，这里就不再赘述。</p><p>来看看一个简单的 <code>HTTPServer</code> 使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(request)</span>:</span></span><br><span class="line">   message = <span class="string">"You requested %s\n"</span> % request.uri</span><br><span class="line">   request.connection.write_headers(</span><br><span class="line">       httputil.ResponseStartLine(<span class="string">'HTTP/1.1'</span>, <span class="number">200</span>, <span class="string">'OK'</span>),</span><br><span class="line">       &#123;<span class="string">"Content-Length"</span>: str(len(message))&#125;)</span><br><span class="line">   request.connection.write(message)</span><br><span class="line">   request.connection.finish()</span><br><span class="line"></span><br><span class="line">http_server = tornado.httpserver.HTTPServer(handle_request)</span><br><span class="line">http_server.listen(<span class="number">8888</span>)</span><br><span class="line">tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><p>示例代码实现的是一个简单的 echo 服务器，<code>HTTPServer</code> 接受的是一个以 <code>HTTPServerRequest</code> 作为参数的函数 <code>handle_request</code>。</p><p><code>HTTPServerRequest</code> 的 <code>connection</code> 字段是一个 <code>HTTPConnection</code> 实例对象，应用代码通过使用 <code>HTTPConnection</code> 的方法响应客户端（write response ）。</p><p><code>HTTPServer</code> 支持 HTTP keep-alive 连接和 <code>X-Real-Ip</code>/<code>X-Forwarded-For</code> HTTP Heads。</p><p><strong><code>HTTPServer</code> 实际上还接受 <code>HTTPServerConnectionDelegate</code> 实例作为请求处理的委托对象</strong>。如下代码把对请求的处理委托给 <code>tornado.web.Application</code> 对象处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">application = web.Application([</span><br><span class="line">    (<span class="string">r"/"</span>, MainPageHandler),</span><br><span class="line">])</span><br><span class="line">http_server = httpserver.HTTPServer(application)</span><br><span class="line">http_server.listen(<span class="number">8080</span>)</span><br><span class="line">ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><p><code>Application</code> 和 <code>HTTPServer</code> 都是 <code>HTTPServerConnectionDelegate</code> 的子类，<code>HTTPServer</code> 会委托 <code>Application</code> 完成对请求的处理。<strong>这是大多数情况下我们使用 Tornado 的方式</strong>。<br><a id="more"></a></p><h3 id="HTTPServer"><a href="#HTTPServer" class="headerlink" title="HTTPServer"></a>HTTPServer</h3><p>Tornado 中与 HTTP 处理相关的功能被定义在 <code>tornado.httpserver</code>、<code>tornado.httputil</code>、<code>tornado.http1connection</code>。<code>tornado.httpserver</code> 主要定义的是 <code>HTTPServer</code> ，<code>tornado.httputil</code> 定义了通用的 HTTP 处理接口、功能类和函数，<code>tornado.http1connection</code> 是 针对 HTTP/1.x 的实现模块。</p><p>与 <code>HTTPServer</code> 实现紧密相关的接口和实现主要有下面这些：</p><ol><li><p><code>tornado.httputil.HTTPServerConnectionDelegate</code> 接口定义了 Web 服务器处理请求的接口，负责启动请求处理和处理完成后的清理工作。<code>tornado.httpserver.HTTPServer</code> 和 <code>tornado.web.Application</code> 是该接口的具体实现类型。<strong><em>通常情况下我们都是结合二者使用 Tornado, <code>HTTPServer</code> 将请求封装好后委托给 <code>Application</code>， <code>Application</code> 按照请求 path 分发请求到目标 Handler，然后由 Handler 负责响应请求</em></strong>。</p></li><li><p><code>tornado.httputil.HTTPMessageDelegate</code> 接口定义了具体的 HTTP 数据（作为服务端时的请求数据，或者作为客户端时的响应数据）处理接口，在对 HTTP 数据解析的一定阶段触发相应方法， 对解析过程进行拦截处理。<strong>从设计的角度来看，这个接口实际上就是分离了对 HTTP 协议的解析逻辑和其他逻辑（包括业务逻辑），所有与 HTTP 协议解析无关的逻辑都交由该接口处理（注：表达可能不够准确），比如提供 xheaders 支持（<code>tornado.httpserver._ServerRequestAdapter</code>），解压缩 Gzip 数据（<code>tornado.http1connection._GzipMessageDelegate</code>），分发请求给相应的 Handler（<code>tornado.web._RequestDispatcher</code>）。</strong></p></li><li><p><code>tornado.httputil.HTTPConnection</code> 接口定义了应用程序响应 HTTP 请求的接口，包括对 HTTP Header 和 Body 的 write。<code>tornado.http1connection.HTTP1Connection</code> 是该接口的实现类，同时也是整个 HTTP/1.x 数据解析的核心实现，<strong><em>封装了对 HTTP 请求(作为服务端)和响应(作为客户端)数据的解析，并在解析的相应阶段触发 <code>HTTPMessageDelegate</code> 对应的方法</em></strong>。</p></li></ol><h4 id="HTTPServerConnectionDelegate-与-HTTPServer"><a href="#HTTPServerConnectionDelegate-与-HTTPServer" class="headerlink" title="HTTPServerConnectionDelegate 与 HTTPServer"></a>HTTPServerConnectionDelegate 与 HTTPServer</h4><p><code>TCPServer</code> 负责监听端口，接收来自客户端的连接请求，并将请求关联的 socket 封装成 <code>IOStream</code> 传递给抽象方法 <code>handle_stream</code> 进行处理。<code>HTTPServer</code> 覆写了 <code>handle_stream</code> 方法，将 <code>IOStream</code> 封装成 HTTP 请求相关的对象，并委托 <code>HTTPServerConnectionDelegate</code> 实例对象进行处理。</p><p><code>HTTPServerConnectionDelegate</code> 定义了 <code>start_request</code> 和 <code>on_close</code> 两个方法作为 HTTP 请求的入口和出口，分别在开始处理 HTTP 请求和连接关闭时调用。接口定义和方法签名如下代码所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPServerConnectionDelegate</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Implement this interface to handle requests from `.HTTPServer`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionadded:: 4.0</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_request</span><span class="params">(self, server_conn, request_conn)</span>:</span></span><br><span class="line">        <span class="string">"""This method is called by the server when a new request has started.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :arg server_conn: is an opaque object representing the long-lived</span></span><br><span class="line"><span class="string">            (e.g. tcp-level) connection.</span></span><br><span class="line"><span class="string">        :arg request_conn: is a `.HTTPConnection` object for a single</span></span><br><span class="line"><span class="string">            request/response exchange.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method should return a `.HTTPMessageDelegate`.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(self, server_conn)</span>:</span></span><br><span class="line">        <span class="string">"""This method is called when a connection has been closed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :arg server_conn: is a server connection that has previously been</span></span><br><span class="line"><span class="string">            passed to ``start_request``.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>start_request(self, server_conn, request_conn)</code> 方法签名接收两个参数，<strong>server_conn</strong> 参数是一个不透明（注：我理解为在该接口定义时不确定该参数的类型，参数类型在具体实现时决定。有点类似标记接口 MarkInterface 的意思。）的持久化连接对象，<strong>request_conn</strong> 参数是一个用于一次 HTTP 请求/响应的 <code>HTTPConnection</code> 对象。该方法返回一个 <code>HTTPMessageDelegate</code> 接口实例对象，以便在后续供 <code>HTTP1Connection</code> 使用。</p><p><code>on_close(self, server_conn)</code> 方法的参数 <strong> server_conn </strong> 应与调用 <code>start_request</code> 方法时相同。</p><p><code>HTTPServer</code> 的代码很简单，基本上只是一些控制逻辑，具体的实现代码都委托给其他对象来处理了，下面是其完整的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPServer</span><span class="params">(TCPServer, httputil.HTTPServerConnectionDelegate)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, request_callback, no_keep_alive=False, io_loop=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 xheaders=False, ssl_options=None, protocol=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 decompress_request=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                 chunk_size=None, max_header_size=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 idle_connection_timeout=None, body_timeout=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 max_body_size=None, max_buffer_size=None)</span>:</span></span><br><span class="line">        self.request_callback = request_callback</span><br><span class="line">        self.no_keep_alive = no_keep_alive</span><br><span class="line">        self.xheaders = xheaders</span><br><span class="line">        self.protocol = protocol</span><br><span class="line">        self.conn_params = HTTP1ConnectionParameters(</span><br><span class="line">            decompress=decompress_request,</span><br><span class="line">            chunk_size=chunk_size,</span><br><span class="line">            max_header_size=max_header_size,</span><br><span class="line">            header_timeout=idle_connection_timeout <span class="keyword">or</span> <span class="number">3600</span>,</span><br><span class="line">            max_body_size=max_body_size,</span><br><span class="line">            body_timeout=body_timeout)</span><br><span class="line">        TCPServer.__init__(self, io_loop=io_loop, ssl_options=ssl_options,</span><br><span class="line">                           max_buffer_size=max_buffer_size,</span><br><span class="line">                           read_chunk_size=chunk_size)</span><br><span class="line">        self._connections = set()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_all_connections</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self._connections:</span><br><span class="line">            <span class="comment"># Peek at an arbitrary element of the set</span></span><br><span class="line">            conn = next(iter(self._connections))</span><br><span class="line">            <span class="keyword">yield</span> conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_stream</span><span class="params">(self, stream, address)</span>:</span></span><br><span class="line">        <span class="comment"># 请求的上下文，以属性字段的形式封装请求关联的数据</span></span><br><span class="line">        context = _HTTPRequestContext(stream, address,</span><br><span class="line">                                      self.protocol)</span><br><span class="line">        <span class="comment"># 支持 HTTP/1.x 的服务端持久化的连接对象， 作为 HTTPServerConnectionDelegate.start_request</span></span><br><span class="line">        <span class="comment"># 方法的 server_conn 实参。</span></span><br><span class="line">        conn = HTTP1ServerConnection(</span><br><span class="line">            stream, self.conn_params, context)</span><br><span class="line">        self._connections.add(conn)</span><br><span class="line">        conn.start_serving(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_request</span><span class="params">(self, server_conn, request_conn)</span>:</span></span><br><span class="line">        <span class="comment"># request_callback 可能是以 `HTTPServerRequest` 对象作为参数的函数，也</span></span><br><span class="line">        <span class="comment"># 可能是一个 `HTTPServerConnectionDelegate` 实例。`_ServerRequestAdapter` 需</span></span><br><span class="line">        <span class="comment"># 要正确处理这两种类型的对象，以适配 `HTTPServerConnectionDelegate`。</span></span><br><span class="line">        <span class="keyword">return</span> _ServerRequestAdapter(self, request_conn)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(self, server_conn)</span>:</span></span><br><span class="line">        self._connections.remove(server_conn)</span><br></pre></td></tr></table></figure><p>如上面 <code>handle_stream</code> 方法的所示，具体的 HTTP 请求处理交由 <code>_HTTPRequestContext</code>、 <code>HTTP1ServerConnection</code> 等来完成。但是 <code>HTTPServer</code> 实现了 <code>HTTPServerConnectionDelegate</code> 接口，同时也接受 <code>request_callback</code> 作为构造函数参数，所以其自身可以作为 <code>HTTPServerConnectionDelegate</code> 传递给 <code>HTTP1ServerConnection</code> 来处理请求。而委托给具体 <code>request_callback</code> 的逻辑则由 <code>_ServerRequestAdapter</code> 来完成。</p><h4 id="HTTPMessageDelegate-与-ServerRequestAdapter-GzipMessageDelegate-RequestDispatcher"><a href="#HTTPMessageDelegate-与-ServerRequestAdapter-GzipMessageDelegate-RequestDispatcher" class="headerlink" title="HTTPMessageDelegate 与 _ServerRequestAdapter/_GzipMessageDelegate/_RequestDispatcher"></a>HTTPMessageDelegate 与 _ServerRequestAdapter/_GzipMessageDelegate/_RequestDispatcher</h4><p><code>HTTPMessageDelegate</code> 通过定义请求处理流程各个阶段可调用的方法而分离了 HTTP 协议的解析逻辑和其他逻辑，这些方法包括：<code>headers_received</code>、<code>data_received</code>、<code>finish</code> 和 <code>on_connection_close</code>。从方法名称大体就能推测出调用阶段，具体的定义，这里就不介绍了，直接参考源码即可。</p><h5 id="ServerRequestAdapter"><a href="#ServerRequestAdapter" class="headerlink" title="_ServerRequestAdapter"></a>_ServerRequestAdapter</h5><p>由于 <code>HTTPServer.request_callback</code> 可能是以 <code>HTTPServerRequest</code> 对象作为参数的函数，也可能是一个 <code>HTTPServerConnectionDelegate</code> 实例。所以 <code>_ServerRequestAdapter</code> 需要正确处理这两种类型的对象以适配 <code>HTTPMessageDelegate</code>：</p><ol><li><p>若 <code>HTTPServer.request_callback</code> 是 <code>HTTPServerConnectionDelegate</code> 实例则将请求处理委托给该实例（调用 start_request 方法）返回的 <code>HTTPMessageDelegate</code> 对象；</p></li><li><p>若 <code>HTTPServer.request_callback</code> 是以<code>HTTPServerRequest</code> 对象为参数的函数，则 <code>_ServerRequestAdapter</code> 要负责处理请求数据，最终将请求数据封装成 <code>HTTPServerRequest</code> 对象交由 <code>HTTPServer.request_callback</code> 处理。</p></li></ol><p>顺便说一下， <code>_ServerRequestAdapter</code> 也负责在每次请求时提供对 <code>xheaders</code> 的支持。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ServerRequestAdapter</span><span class="params">(httputil.HTTPMessageDelegate)</span>:</span></span><br><span class="line">    <span class="string">"""Adapts the `HTTPMessageDelegate` interface to the interface expected</span></span><br><span class="line"><span class="string">    by our clients.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server, connection)</span>:</span></span><br><span class="line">        self.server = server</span><br><span class="line">        self.connection = connection</span><br><span class="line">        self.request = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 如果 server.request_callback 是一个 HTTPServerConnectionDelegate 实例，</span></span><br><span class="line">        <span class="comment"># 比如 tornado.web.Application 实例，那就委托给它处理请求，否则就自己处理。</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(server.request_callback,</span><br><span class="line">                      httputil.HTTPServerConnectionDelegate):</span><br><span class="line">            self.delegate = server.request_callback.start_request(connection)</span><br><span class="line">            self._chunks = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.delegate = <span class="literal">None</span></span><br><span class="line">            self._chunks = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">headers_received</span><span class="params">(self, start_line, headers)</span>:</span></span><br><span class="line">        <span class="comment"># 对这次请求应用 xheaders 支持</span></span><br><span class="line">        <span class="keyword">if</span> self.server.xheaders:</span><br><span class="line">            self.connection.context._apply_xheaders(headers)</span><br><span class="line">        <span class="keyword">if</span> self.delegate <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 初始化一个 HTTPServerRequest 实例，HTTP 数据解析完成后将为该对象的 body 字段赋值。</span></span><br><span class="line">            self.request = httputil.HTTPServerRequest(</span><br><span class="line">                connection=self.connection, start_line=start_line,</span><br><span class="line">                headers=headers)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.delegate.headers_received(start_line, headers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data_received</span><span class="params">(self, chunk)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.delegate <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._chunks.append(chunk)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.delegate.data_received(chunk)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.delegate <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 为 body 字段赋值，并解析成 key/value 的形式，对上传的文件也采用这种方式（value 的类型</span></span><br><span class="line">            <span class="comment"># 为 HTTPFile，由于有 max_body_size 和 max_buffer_szie 的限制，这里倒是不用担心文件</span></span><br><span class="line">            <span class="comment"># 过大的问题）。</span></span><br><span class="line">            self.request.body = <span class="string">b''</span>.join(self._chunks)</span><br><span class="line">            self.request._parse_body()</span><br><span class="line">            self.server.request_callback(self.request)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.delegate.finish()</span><br><span class="line">        self._cleanup()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connection_close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.delegate <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._chunks = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.delegate.on_connection_close()</span><br><span class="line">        self._cleanup()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_cleanup</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 请求处理正常结束或者连接关闭时进行一些清理工作，如有必要取消对 xheaders 的支持。</span></span><br><span class="line">        <span class="keyword">if</span> self.server.xheaders:</span><br><span class="line">            self.connection.context._unapply_xheaders()</span><br></pre></td></tr></table></figure><h5 id="GzipMessageDelegate"><a href="#GzipMessageDelegate" class="headerlink" title="_GzipMessageDelegate"></a>_GzipMessageDelegate</h5><p><code>_GzipMessageDelegate</code> 是一个典型的 Decorator Pattern 应用，专门用于支持 Content-Encoding: gzip。它装饰一个 <code>HTTPMessageDelegate</code> 实例对象，为其提供 gzip 的解压缩支持。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GzipMessageDelegate</span><span class="params">(httputil.HTTPMessageDelegate)</span>:</span></span><br><span class="line">    <span class="string">"""Wraps an `HTTPMessageDelegate` to decode ``Content-Encoding: gzip``.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, delegate, chunk_size)</span>:</span></span><br><span class="line">        self._delegate = delegate</span><br><span class="line">        self._chunk_size = chunk_size</span><br><span class="line">        self._decompressor = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">headers_received</span><span class="params">(self, start_line, headers)</span>:</span></span><br><span class="line">        <span class="comment"># 若是 gzip 数据，则提供 GzipDecompressor 实例用于 body 的解压缩。</span></span><br><span class="line">        <span class="comment"># 并删除 Content-Encoding 报文头，用 X-Consumed-Content-Encoding 来代替。</span></span><br><span class="line">        <span class="keyword">if</span> headers.get(<span class="string">"Content-Encoding"</span>) == <span class="string">"gzip"</span>:</span><br><span class="line">            self._decompressor = GzipDecompressor()</span><br><span class="line">            <span class="comment"># Downstream delegates will only see uncompressed data,</span></span><br><span class="line">            <span class="comment"># so rename the content-encoding header.</span></span><br><span class="line">            <span class="comment"># (but note that curl_httpclient doesn't do this).</span></span><br><span class="line">            headers.add(<span class="string">"X-Consumed-Content-Encoding"</span>,</span><br><span class="line">                        headers[<span class="string">"Content-Encoding"</span>])</span><br><span class="line">            <span class="keyword">del</span> headers[<span class="string">"Content-Encoding"</span>]</span><br><span class="line">        <span class="keyword">return</span> self._delegate.headers_received(start_line, headers)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data_received</span><span class="params">(self, chunk)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._decompressor:</span><br><span class="line">            compressed_data = chunk</span><br><span class="line">            <span class="keyword">while</span> compressed_data:</span><br><span class="line">                decompressed = self._decompressor.decompress(</span><br><span class="line">                    compressed_data, self._chunk_size)</span><br><span class="line">                <span class="keyword">if</span> decompressed:</span><br><span class="line">                    <span class="keyword">yield</span> gen.maybe_future(</span><br><span class="line">                        self._delegate.data_received(decompressed))</span><br><span class="line">                compressed_data = self._decompressor.unconsumed_tail</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> gen.maybe_future(self._delegate.data_received(chunk))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._decompressor <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            tail = self._decompressor.flush()</span><br><span class="line">            <span class="keyword">if</span> tail:</span><br><span class="line">                <span class="comment"># I believe the tail will always be empty (i.e.</span></span><br><span class="line">                <span class="comment"># decompress will return all it can).  The purpose</span></span><br><span class="line">                <span class="comment"># of the flush call is to detect errors such</span></span><br><span class="line">                <span class="comment"># as truncated input.  But in case it ever returns</span></span><br><span class="line">                <span class="comment"># anything, treat it as an extra chunk</span></span><br><span class="line">                self._delegate.data_received(tail)</span><br><span class="line">        <span class="keyword">return</span> self._delegate.finish()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connection_close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._delegate.on_connection_close()</span><br></pre></td></tr></table></figure><p><code>_GzipMessageDelegate</code> 代码不复杂，解压缩的工作是由 <code>tonrado.util.GzipDecompressor</code> 委托 <code>zlib.decompressobj</code> 完成。</p><h5 id="RequestDispatcher"><a href="#RequestDispatcher" class="headerlink" title="_RequestDispatcher"></a>_RequestDispatcher</h5><p><code>_RequestDispatcher</code> 定义在 <code>tornado.web</code> 模块中，为 <code>Applioation</code> 适配 <code>HTTPServerConnectionDelegate</code> 接口，以完成根据请求的 path 分发请求到 handler。其实现并不复杂，后续会在分析 <code>Application</code> 时介绍详细的实现。</p><h4 id="HTTPConnection-与-HTTP1Connection-HTTP1ServerConnection"><a href="#HTTPConnection-与-HTTP1Connection-HTTP1ServerConnection" class="headerlink" title="HTTPConnection 与 HTTP1Connection/HTTP1ServerConnection[*]"></a>HTTPConnection 与 HTTP1Connection/HTTP1ServerConnection[*]</h4><p><code>HTTPConnection</code> 是 HTTP 响应的接口，应用通过该接口 write headers/body 信息。<code>HTTP1Connection</code> 是 HTTP/1.x 协议的 <code>HTTPConnection</code> 实现，提供了 HTTP 请求的解析和响应功能，可单独被客户端(比如 <code>tornado.simple_httpclient.SimpleAsyncHTTPClient</code>)使用，也可通过 <code>HTTP1ServerConnection</code> 被服务器(比如 <code>HTTPServer</code>)使用。</p><p>由于 <code>HTTP1Connection</code> 是对 HTTP/1.x 协议的实现，其代码涉及大量的协议数据格式解析，对深入理解 HTTP 非常有价值，这里主要是分析 Tornado 处理 HTTP 请求的流程，对协议的关注将放到相关的文章中详细介绍。</p><p><code>HTTP1ServerConnection</code> 支持持久连接，在同一个连接上处理多个 HTTP 请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTP1ServerConnection</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""An HTTP/1.x server."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, stream, params=None, context=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :arg stream: an `.IOStream`</span></span><br><span class="line"><span class="string">        :arg params: a `.HTTP1ConnectionParameters` or None</span></span><br><span class="line"><span class="string">        :arg context: an opaque application-defined object that is accessible</span></span><br><span class="line"><span class="string">            as ``connection.context``</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stream = stream</span><br><span class="line">        <span class="keyword">if</span> params <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            params = HTTP1ConnectionParameters()</span><br><span class="line">        self.params = params</span><br><span class="line">        self.context = context</span><br><span class="line">        self._serving_future = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Closes the connection.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns a `.Future` that resolves after the serving loop has exited.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stream.close()</span><br><span class="line">        <span class="comment"># Block until the serving loop is done, but ignore any exceptions</span></span><br><span class="line">        <span class="comment"># (start_serving is already responsible for logging them).</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">yield</span> self._serving_future</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_serving</span><span class="params">(self, delegate)</span>:</span></span><br><span class="line">        <span class="string">"""Starts serving requests on this connection.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :arg delegate: a `.HTTPServerConnectionDelegate`</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">assert</span> isinstance(delegate, httputil.HTTPServerConnectionDelegate)</span><br><span class="line">        self._serving_future = self._server_request_loop(delegate)</span><br><span class="line">        <span class="comment"># Register the future on the IOLoop so its errors get logged.</span></span><br><span class="line">        self.stream.io_loop.add_future(self._serving_future,</span><br><span class="line">                                       <span class="keyword">lambda</span> f: f.result())</span><br><span class="line"></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_server_request_loop</span><span class="params">(self, delegate)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                conn = HTTP1Connection(self.stream, <span class="literal">False</span>,</span><br><span class="line">                                       self.params, self.context)</span><br><span class="line">                request_delegate = delegate.start_request(self, conn)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># 解析 HTTP 数据，解析的结果交由 request_delegate 处理。通常 request_delegate</span></span><br><span class="line">                    <span class="comment"># 会将解析结果保存到 HTTPServerRequest 中，参见 _ServerRequestAdapter 实现。</span></span><br><span class="line">                    ret = <span class="keyword">yield</span> conn.read_response(request_delegate)</span><br><span class="line">                <span class="keyword">except</span> (iostream.StreamClosedError,</span><br><span class="line">                        iostream.UnsatisfiableReadError):</span><br><span class="line">                    <span class="comment"># 这两种异常由底层 IOStream 引发，发生时 IOStream 会自动关闭（包括关联的 fd） 并 logged。</span></span><br><span class="line">                    <span class="comment"># 若是其他异常，则需要调用 conn.close() 以关闭 IOStream。</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">except</span> _QuietException:</span><br><span class="line">                    <span class="comment"># This exception was already logged.</span></span><br><span class="line">                    <span class="comment">#</span></span><br><span class="line">                    <span class="comment"># HTTP1Connection 中发生异常时由 _ExceptionLoggingContext 捕获并 logged（详细异常），</span></span><br><span class="line">                    <span class="comment"># 然后 _ExceptionLoggingContext 抛出 _QuietException 异常。</span></span><br><span class="line">                    conn.close()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">except</span> Exception:</span><br><span class="line">                    gen_log.error(<span class="string">"Uncaught exception"</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">                    conn.close()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="comment"># read_response 方法返回 True 表示此次请求正常处理完成，继续处理下一个请求：</span></span><br><span class="line">                <span class="comment">#   1. keep-alive 时，等待下一次 read_response 完成；</span></span><br><span class="line">                <span class="comment">#   2. 非 keep-alive 时，会抛出 StreamClosedError 终止循环；</span></span><br><span class="line">                <span class="comment"># 返回 False 则表示处理请求时发生了异常无法再继续处理下一个请求，立即终止循环是最优的选择而不是通过下</span></span><br><span class="line">                <span class="comment"># 一次抛出异常来终止。</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">yield</span> gen.moment</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># HTTPServer.on_close 方法仅将当前 HTTP1ServerConnection 从其内部连接列表中移除。</span></span><br><span class="line">            delegate.on_close(self)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;HTTPServer&lt;/code&gt; 是 HTTP 协议的 &lt;code&gt;TCPServer&lt;/code&gt; 子类实现，&lt;code&gt;HTTPServer&lt;/code&gt; 覆写了 &lt;code&gt;handle_stream&lt;/code&gt; 方法用于处理 HTTP 协议。与 &lt;code&gt;TCPServer&lt;/code&gt; 一样，可以有三种使用模式，源码注释中写的很详细，在 &lt;code&gt;TCPServer&lt;/code&gt; 源码解析的部分也已经详细讨论过，这里就不再赘述。&lt;/p&gt;
&lt;p&gt;来看看一个简单的 &lt;code&gt;HTTPServer&lt;/code&gt; 使用示例：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; tornado.httpserver&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; tornado.ioloop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handle_request&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(request)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   message = &lt;span class=&quot;string&quot;&gt;&quot;You requested %s\n&quot;&lt;/span&gt; % request.uri&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   request.connection.write_headers(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       httputil.ResponseStartLine(&lt;span class=&quot;string&quot;&gt;&#39;HTTP/1.1&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;OK&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;Content-Length&quot;&lt;/span&gt;: str(len(message))&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   request.connection.write(message)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   request.connection.finish()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http_server = tornado.httpserver.HTTPServer(handle_request)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http_server.listen(&lt;span class=&quot;number&quot;&gt;8888&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tornado.ioloop.IOLoop.instance().start()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例代码实现的是一个简单的 echo 服务器，&lt;code&gt;HTTPServer&lt;/code&gt; 接受的是一个以 &lt;code&gt;HTTPServerRequest&lt;/code&gt; 作为参数的函数 &lt;code&gt;handle_request&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTTPServerRequest&lt;/code&gt; 的 &lt;code&gt;connection&lt;/code&gt; 字段是一个 &lt;code&gt;HTTPConnection&lt;/code&gt; 实例对象，应用代码通过使用 &lt;code&gt;HTTPConnection&lt;/code&gt; 的方法响应客户端（write response ）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTTPServer&lt;/code&gt; 支持 HTTP keep-alive 连接和 &lt;code&gt;X-Real-Ip&lt;/code&gt;/&lt;code&gt;X-Forwarded-For&lt;/code&gt; HTTP Heads。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;HTTPServer&lt;/code&gt; 实际上还接受 &lt;code&gt;HTTPServerConnectionDelegate&lt;/code&gt; 实例作为请求处理的委托对象&lt;/strong&gt;。如下代码把对请求的处理委托给 &lt;code&gt;tornado.web.Application&lt;/code&gt; 对象处理：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;application = web.Application([&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;string&quot;&gt;r&quot;/&quot;&lt;/span&gt;, MainPageHandler),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http_server = httpserver.HTTPServer(application)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http_server.listen(&lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ioloop.IOLoop.instance().start()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Application&lt;/code&gt; 和 &lt;code&gt;HTTPServer&lt;/code&gt; 都是 &lt;code&gt;HTTPServerConnectionDelegate&lt;/code&gt; 的子类，&lt;code&gt;HTTPServer&lt;/code&gt; 会委托 &lt;code&gt;Application&lt;/code&gt; 完成对请求的处理。&lt;strong&gt;这是大多数情况下我们使用 Tornado 的方式&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="HTTPServer" scheme="http://yoursite.com/tags/HTTPServer/"/>
    
      <category term="HTTPServerConnectionDelegate" scheme="http://yoursite.com/tags/HTTPServerConnectionDelegate/"/>
    
      <category term="HTTPMessageDelegate" scheme="http://yoursite.com/tags/HTTPMessageDelegate/"/>
    
      <category term="HTTPConnection" scheme="http://yoursite.com/tags/HTTPConnection/"/>
    
      <category term="HTTP1ServerConnection" scheme="http://yoursite.com/tags/HTTP1ServerConnection/"/>
    
      <category term="HTTP1Connection" scheme="http://yoursite.com/tags/HTTP1Connection/"/>
    
  </entry>
  
  <entry>
    <title>tornado.tcpserver 模块解析</title>
    <link href="http://yoursite.com/2015/10/14/tornado.tcpserver/"/>
    <id>http://yoursite.com/2015/10/14/tornado.tcpserver/</id>
    <published>2015-10-14T09:25:01.000Z</published>
    <updated>2019-10-22T15:53:03.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>有了 <code>tornado.ioloop</code> 和 <code>tornado.iostream</code> 这两个模块的帮助，在 tornado 中要实现一个异步 Web 服务器就变得容易了。</p><p><code>tornado.httpserver</code> 模块是 tornado 的 Web 服务器模块, 该模块中实现了 <code>HTTPServer</code> —— 一个单线程 HTTP 服务器，其实现是基于 <code>tornado.tcpserver</code> 模块的 <code>TCPServer</code>，<code>TCPServer</code> 是一个非阻塞单线程的 TCP 服务器，它负责处理 TCP 协议部分的内容，并预留接口（<code>handle_stream</code> 抽象方法）以便针对相应的应用层协议编写服务器。所以在分析 tornado HTTP 服务器实现之前，我们先来看看 <code>tornado.tcpserver.TCPServer</code> 的实现。</p><h3 id="TCPServer"><a href="#TCPServer" class="headerlink" title="TCPServer"></a>TCPServer</h3><p><code>tornado.tcpserver</code> 模块中只定义了一个 <code>TCPServer</code> 类，由于其实现不涉及到具体的应用层协议（例如Http协议），加上有 <code>IOLoop</code> 和 <code>IOStream</code> 的支持，其实现比较简单。</p><p><code>TCPServer</code> 是一个非阻塞的单线程 TCP Server，它提供了一个抽象接口方法 <code>handle_stream</code> 供具体的子类去实现，同时支持多进程的运行方式。按照源码注释，通过调用不同的方法我们有 3 中方式使用一个  TCP Server。</p><h4 id="三种使用模式"><a href="#三种使用模式" class="headerlink" title="三种使用模式"></a>三种使用模式</h4><h5 id="使用-listen-的单进程模式"><a href="#使用-listen-的单进程模式" class="headerlink" title="使用 listen 的单进程模式"></a>使用 listen 的单进程模式</h5><p>通过 <code>TCPServer</code> 的 <code>listen</code> 方法以单进程的方式运行服务器实例。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server = TCPServer()</span><br><span class="line">server.listen(<span class="number">8888</span>)</span><br><span class="line">IOLoop.instance().start()</span><br></pre></td></tr></table></figure><p><code>TCPServer</code> 提供的 <code>listen</code> 方法可以立即启动在指定的端口进行监听，并将相应的 socket 加入到 IOLoop 中。该方法可以多次调用，同时监听多个端口。由于需要 IOLoop 来驱动，所以必须确保相应的 IOLoop 实例已经启动（上述示例代码实例化 server 用的是默认 IOLoop 实例，所以通过 IOLoop.instance().start() 启动）。</p><a id="more"></a><h5 id="使用-bind-start-的多进程模式"><a href="#使用-bind-start-的多进程模式" class="headerlink" title="使用 bind/start 的多进程模式"></a>使用 bind/start 的多进程模式</h5><p>通过 <code>TCPServer</code> 的 <code>bind</code>/<code>start</code> 方法可以以多进程的方式运行服务器实例。示例代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server = TCPServer()</span><br><span class="line">server.bind(<span class="number">8888</span>)</span><br><span class="line">server.start(<span class="number">0</span>)  <span class="comment"># Forks multiple sub-processes</span></span><br><span class="line">IOLoop.instance().start()</span><br></pre></td></tr></table></figure><p><code>bind</code> 方法可以将服务器绑定到指定的地址，并通过 <code>start</code> 方法启动多个子进程，以达到多进程运行的模式。<code>start</code> 方法通过参数 <code>num_processes</code> 指定以单进程或者多进程方式运行服务器，<code>num_processes</code> 参数默认为 1，以单进程方式运行；当为 None 或者 &lt;= 0 时，将尝试使用与 cpu 核数相当的子进程运行（如上述示例代码所示）；当 &gt; 1，将以该值指定的子进程数运行。</p><p>不过，如果是以单进程方式运行服务器的话，一般使用 <code>listen</code> 的方式。</p><h5 id="更高级的多进程模式"><a href="#更高级的多进程模式" class="headerlink" title="更高级的多进程模式"></a>更高级的多进程模式</h5><p><code>TCPServer</code> 的 <code>bind</code>/<code>start</code> 方法内部实际封装的就是绑定监听端口和启动子进程的功能，我们可以不使用这两个方法，而是执行调用绑定函数和 fork 进程来达到多进程运行服务器实例的目的。示例代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sockets = bind_sockets(<span class="number">8888</span>)</span><br><span class="line">tornado.process.fork_processes(<span class="number">0</span>)</span><br><span class="line">server = TCPServer()</span><br><span class="line">server.add_sockets(sockets)</span><br><span class="line">IOLoop.instance().start()</span><br></pre></td></tr></table></figure><p><code>bind_sockets</code> 函数定义在 <code>tornado.netutil</code> 模块中。<code>fork_processes</code> 函数定义在 <code>tornado.process</code> 模块中。</p><p>通过调用 <code>bind_sockets</code> 函数可以创建一个或者多个(一个 hostname 可能绑定到多个 IP 地址)监听指定端口的 socket。调用 <code>fork_processes</code> 方法可以 fork 出多个子进程，<strong><em>其中主进程调用负责监听子进程的状态而不会返回，子进程接着执行后续代码</em></strong>。</p><p>实际上 <code>TCPServer</code> 的 <code>bind</code>/<code>start</code> 方法内部也是调用的 <code>bind_sockets</code> 与 <code>fork_processes</code>  函数。</p><h6 id="bind-sockets-函数"><a href="#bind-sockets-函数" class="headerlink" title="bind_sockets 函数"></a>bind_sockets 函数</h6><p><code>bind_sockets</code> 函数的代码不多，比较简单，作者的注释也非常的详细。函数同时支持 ipv6 和 ipv4 ，能够监听的连接数队列默认最大是 128（<code>_DEFAULT_BACKLOG=128</code>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bind_sockets</span><span class="params">(port, address=None, family=socket.AF_UNSPEC,</span></span></span><br><span class="line"><span class="function"><span class="params">                 backlog=_DEFAULT_BACKLOG, flags=None)</span>:</span></span><br><span class="line">    <span class="string">"""Creates listening sockets bound to the given port and address.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns a list of socket objects (multiple sockets are returned if</span></span><br><span class="line"><span class="string">    the given address maps to multiple IP addresses, which is most common</span></span><br><span class="line"><span class="string">    for mixed IPv4 and IPv6 use).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Address may be either an IP address or hostname.  If it's a hostname,</span></span><br><span class="line"><span class="string">    the server will listen on all IP addresses associated with the</span></span><br><span class="line"><span class="string">    name.  Address may be an empty string or None to listen on all</span></span><br><span class="line"><span class="string">    available interfaces.  Family may be set to either `socket.AF_INET`</span></span><br><span class="line"><span class="string">    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise</span></span><br><span class="line"><span class="string">    both will be used if available.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The ``backlog`` argument has the same meaning as for</span></span><br><span class="line"><span class="string">    `socket.listen() &lt;socket.socket.listen&gt;`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like</span></span><br><span class="line"><span class="string">    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    sockets = []</span><br><span class="line">    <span class="keyword">if</span> address == <span class="string">""</span>:</span><br><span class="line">        address = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> socket.has_ipv6 <span class="keyword">and</span> family == socket.AF_UNSPEC:</span><br><span class="line">        <span class="comment"># Python can be compiled with --disable-ipv6, which causes</span></span><br><span class="line">        <span class="comment"># operations on AF_INET6 sockets to fail, but does not</span></span><br><span class="line">        <span class="comment"># automatically exclude those results from getaddrinfo</span></span><br><span class="line">        <span class="comment"># results.</span></span><br><span class="line">        <span class="comment"># http://bugs.python.org/issue16208</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># 由于可以通过指定编译选项来编译出仅支持 ipv4 的 python 版本，为了保证</span></span><br><span class="line">        <span class="comment"># getaddrinfo 也只返回 ipv4 的地址，所以这里指定 socket.AF_INET</span></span><br><span class="line">        family = socket.AF_INET</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 函数注释中已经有说明了，flag 是一个传递给 getaddrinfo 函数的 AI_* 掩码。常用的如</span></span><br><span class="line">    <span class="comment"># ``socket.AI_PASSIVE | socket.AI_CANNONAME | socket.AI_NUMERICHOST``。</span></span><br><span class="line">    <span class="comment"># ``socket.AI_PASSIVE``: 指示函数返回的地址将用于 bind() 函数调用，否则用于 connect() 函数调用；</span></span><br><span class="line">    <span class="comment"># ``socket.AI_CANNONAME``: 指示函数返回的地址需要一个规范名(而不是别名)。</span></span><br><span class="line">    <span class="comment"># ``socket.AI_NUMERICHOST``: 指示函数返回数字格式的地址。</span></span><br><span class="line">    <span class="keyword">if</span> flags <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        flags = socket.AI_PASSIVE</span><br><span class="line">    bound_port = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># socket.getaddrinfo(host, port[, family[, socktype[, proto[, flags]]]])</span></span><br><span class="line">    <span class="comment"># family: 协议簇，常用的协议包括 AF_UNIX(1，本机通信)/AF_INET(2，IPV4)/AF_INET6(10，IPV6)。</span></span><br><span class="line">    <span class="comment"># socktype：socket 的类型，常见的socket类型包括SOCK_STREAM(TCP流)/SOCK_DGRAM(UDP数据报)/SOCK_RAW(原始套接字)。</span></span><br><span class="line">    <span class="comment">#           其中，SOCK_STREAM=1，SOCK_DGRAM=2，SOCK_RAW=3。</span></span><br><span class="line">    <span class="comment"># proto：协议，套接口所用的协议。如调用者不想指定，可用0。常用的协议有，IPPROTO_TCP(=6) 和</span></span><br><span class="line">    <span class="comment">#        IPPTOTO_UDP(=17)，它们分别对应 TCP 传输协议、UDP 传输协议。与 IP 数据包的 ``8位协议字段`` 对应。</span></span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> set(socket.getaddrinfo(address, port, family, socket.SOCK_STREAM,</span><br><span class="line">                                      <span class="number">0</span>, flags)):</span><br><span class="line">        af, socktype, proto, canonname, sockaddr = res</span><br><span class="line">        <span class="keyword">if</span> (platform.system() == <span class="string">'Darwin'</span> <span class="keyword">and</span> address == <span class="string">'localhost'</span> <span class="keyword">and</span></span><br><span class="line">                af == socket.AF_INET6 <span class="keyword">and</span> sockaddr[<span class="number">3</span>] != <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># Mac OS X includes a link-local address fe80::1%lo0 in the</span></span><br><span class="line">            <span class="comment"># getaddrinfo results for 'localhost'.  However, the firewall</span></span><br><span class="line">            <span class="comment"># doesn't understand that this is a local address and will</span></span><br><span class="line">            <span class="comment"># prompt for access (often repeatedly, due to an apparent</span></span><br><span class="line">            <span class="comment"># bug in its ability to remember granting access to an</span></span><br><span class="line">            <span class="comment"># application). Skip these addresses.</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># address = 'localhost' 时 Mac OS X 可能会返回一个 ipv6 地址 fe80::1%lo0，</span></span><br><span class="line">            <span class="comment"># 而防火墙不能识别出这是一个本地地址而尝试访问会导致 bug ，所以这里忽略这个地址。</span></span><br><span class="line">            <span class="comment"># ipv6  二进制 128 位，以 16 位为一组，每组以 `:` 分开，`::` 表示一组0或者多组连续的0，</span></span><br><span class="line">            <span class="comment"># 但是只能出现 1 次。</span></span><br><span class="line">            <span class="comment"># sockaddr is a tuple describing a socket address, whose format</span></span><br><span class="line">            <span class="comment"># depends on the returned family (a (address, port) 2-tuple for</span></span><br><span class="line">            <span class="comment"># AF_INET, a (address, port, flow info, scope id) 4-tuple for AF_INET6)</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sock = socket.socket(af, socktype, proto)</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> errno_from_exception(e) == errno.EAFNOSUPPORT:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="comment"># 为 fd 设置 FD_CLOEXEC 标识</span></span><br><span class="line">        set_close_exec(sock.fileno())</span><br><span class="line">        <span class="keyword">if</span> os.name != <span class="string">'nt'</span>:</span><br><span class="line">            <span class="comment"># 避免在服务器重启的时候发生“该地址以被使用”这种错误。</span></span><br><span class="line">            <span class="comment"># socket.SOL_SOCKET 指定在套接字级别设置 `可选项`。</span></span><br><span class="line">            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> af == socket.AF_INET6:</span><br><span class="line">            <span class="comment"># On linux, ipv6 sockets accept ipv4 too by default,</span></span><br><span class="line">            <span class="comment"># but this makes it impossible to bind to both</span></span><br><span class="line">            <span class="comment"># 0.0.0.0 in ipv4 and :: in ipv6.  On other systems,</span></span><br><span class="line">            <span class="comment"># separate sockets *must* be used to listen for both ipv4</span></span><br><span class="line">            <span class="comment"># and ipv6.  For consistency, always disable ipv4 on our</span></span><br><span class="line">            <span class="comment"># ipv6 sockets and use a separate ipv4 socket when needed.</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># Python 2.x on windows doesn't have IPPROTO_IPV6.</span></span><br><span class="line">            <span class="keyword">if</span> hasattr(socket, <span class="string">"IPPROTO_IPV6"</span>):</span><br><span class="line">                sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># automatic port allocation with port=None</span></span><br><span class="line">        <span class="comment"># should bind on the same port on IPv4 and IPv6</span></span><br><span class="line">        host, requested_port = sockaddr[:<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> requested_port == <span class="number">0</span> <span class="keyword">and</span> bound_port <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            sockaddr = tuple([host, bound_port] + list(sockaddr[<span class="number">2</span>:]))</span><br><span class="line"></span><br><span class="line">        sock.setblocking(<span class="number">0</span>)</span><br><span class="line">        sock.bind(sockaddr)</span><br><span class="line">        bound_port = sock.getsockname()[<span class="number">1</span>]</span><br><span class="line">        sock.listen(backlog)</span><br><span class="line">        sockets.append(sock)</span><br><span class="line">    <span class="keyword">return</span> sockets</span><br></pre></td></tr></table></figure><h6 id="fork-processes-函数"><a href="#fork-processes-函数" class="headerlink" title="fork_processes 函数"></a>fork_processes 函数</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fork_processes</span><span class="params">(num_processes, max_restarts=<span class="number">100</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Starts multiple worker processes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If ``num_processes`` is None or &lt;= 0, we detect the number of cores</span></span><br><span class="line"><span class="string">    available on this machine and fork that number of child</span></span><br><span class="line"><span class="string">    processes. If ``num_processes`` is given and &gt; 0, we fork that</span></span><br><span class="line"><span class="string">    specific number of sub-processes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Since we use processes and not threads, there is no shared memory</span></span><br><span class="line"><span class="string">    between any server code.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note that multiple processes are not compatible with the autoreload</span></span><br><span class="line"><span class="string">    module (or the ``autoreload=True`` option to `tornado.web.Application`</span></span><br><span class="line"><span class="string">    which defaults to True when ``debug=True``).</span></span><br><span class="line"><span class="string">    When using multiple processes, no IOLoops can be created or</span></span><br><span class="line"><span class="string">    referenced until after the call to ``fork_processes``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    In each child process, ``fork_processes`` returns its *task id*, a</span></span><br><span class="line"><span class="string">    number between 0 and ``num_processes``.  Processes that exit</span></span><br><span class="line"><span class="string">    abnormally (due to a signal or non-zero exit status) are restarted</span></span><br><span class="line"><span class="string">    with the same id (up to ``max_restarts`` times).  In the parent</span></span><br><span class="line"><span class="string">    process, ``fork_processes`` returns None if all child processes</span></span><br><span class="line"><span class="string">    have exited normally, but will otherwise only exit by throwing an</span></span><br><span class="line"><span class="string">    exception.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">global</span> _task_id</span><br><span class="line">    <span class="keyword">assert</span> _task_id <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># num_processes 为 None 或者 &lt;=0,则使用 cpu 核数。</span></span><br><span class="line">    <span class="keyword">if</span> num_processes <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> num_processes &lt;= <span class="number">0</span>:</span><br><span class="line">        num_processes = cpu_count()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ioloop.IOLoop.initialized():</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"Cannot run in multiple processes: IOLoop instance "</span></span><br><span class="line">                           <span class="string">"has already been initialized. You cannot call "</span></span><br><span class="line">                           <span class="string">"IOLoop.instance() before calling start_processes()"</span>)</span><br><span class="line">    gen_log.info(<span class="string">"Starting %d processes"</span>, num_processes)</span><br><span class="line">    children = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_child</span><span class="params">(i)</span>:</span></span><br><span class="line">        pid = os.fork()</span><br><span class="line">        <span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># child process</span></span><br><span class="line">            _reseed_random()</span><br><span class="line">            <span class="keyword">global</span> _task_id</span><br><span class="line">            _task_id = i</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            children[pid] = i</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_processes):</span><br><span class="line">        id = start_child(i)</span><br><span class="line">        <span class="keyword">if</span> id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> id</span><br><span class="line"></span><br><span class="line">    <span class="comment"># master 进程负责监控子进程，若子进程异常结束(due to a signal or non-zero exit status)，</span></span><br><span class="line">    <span class="comment"># 则负责重启子进程。`num_restarts` 变量记录了累计重启的子进程数量，若该值大于 `max_restarts`,</span></span><br><span class="line">    <span class="comment"># 则抛出运行时异常。</span></span><br><span class="line">    num_restarts = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> children:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pid, status = os.wait()</span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> errno_from_exception(e) == errno.EINTR:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">if</span> pid <span class="keyword">not</span> <span class="keyword">in</span> children:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        id = children.pop(pid)</span><br><span class="line">        <span class="keyword">if</span> os.WIFSIGNALED(status):</span><br><span class="line">            gen_log.warning(<span class="string">"child %d (pid %d) killed by signal %d, restarting"</span>,</span><br><span class="line">                            id, pid, os.WTERMSIG(status))</span><br><span class="line">        <span class="keyword">elif</span> os.WEXITSTATUS(status) != <span class="number">0</span>:</span><br><span class="line">            gen_log.warning(<span class="string">"child %d (pid %d) exited with status %d, restarting"</span>,</span><br><span class="line">                            id, pid, os.WEXITSTATUS(status))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gen_log.info(<span class="string">"child %d (pid %d) exited normally"</span>, id, pid)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        num_restarts += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> num_restarts &gt; max_restarts:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">"Too many child restarts, giving up"</span>)</span><br><span class="line">        new_id = start_child(id)</span><br><span class="line">        <span class="keyword">if</span> new_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> new_id</span><br><span class="line">    <span class="comment"># All child processes exited cleanly, so exit the master process</span></span><br><span class="line">    <span class="comment"># instead of just returning to right after the call to</span></span><br><span class="line">    <span class="comment"># fork_processes (which will probably just start up another IOLoop</span></span><br><span class="line">    <span class="comment"># unless the caller checks the return value).</span></span><br><span class="line">    sys.exit(<span class="number">0</span>)TLS</span><br></pre></td></tr></table></figure><p><code>TCPServer</code> 的实现代码比较简单，重要的设计在前述内容中基本上都提到了。至于涉及到 SSL/TLS 部分TLS的知识，就需要另外查询相关资料了，这方面我目前也不懂。但是这个不影响对 tornado 的学习。额外补充两点内容：</p><ol><li><p><code>TCPServer</code> 的构造函数中会对非 None 的 ssl_options 参数进行检查，要求必须包含 <strong>‘certfile’</strong> 和 <strong>‘keyfile’</strong> 选项并且选项指定的文件存在，但不会检查文件的内容。对文件内容的检查将推迟到客户端连接建立时。ssl_options 是一个 dictionary， 在 python 3.2+ 还可以用 <code>ssl.SSLContext</code> 实例来代替。</p></li><li><p>SSL Wrap 相关的函数被定义在 <code>tornado.netutil</code> 模块中，有效的 ssl_options 选项名称被定义在模块变量 <code>_SSL_CONTEXT_KEYWORDS</code> 中，包括 [‘ssl_version’, ‘certfile’, ‘keyfile’, ‘cert_reqs’, ‘ca_certs’, ‘ciphers’]。</p></li></ol><h6 id="add-accept-handler-函数"><a href="#add-accept-handler-函数" class="headerlink" title="add_accept_handler 函数"></a>add_accept_handler 函数</h6><p><code>TCPServer.add_sockets</code> 方法内部使用 <code>tornado.netutil.add_accept_handler</code> 函数完成将监听 socket 注册到 IOLoop event handlers 中，当 accept 客户端连接时回调。<code>add_accept_handler</code> 函数源码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_accept_handler</span><span class="params">(sock, callback, io_loop=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> io_loop <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        io_loop = IOLoop.current()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept_handler</span><span class="params">(fd, events)</span>:</span></span><br><span class="line">        <span class="comment"># More connections may come in while we're handling callbacks;</span></span><br><span class="line">        <span class="comment"># to prevent starvation of other tasks we must limit the number</span></span><br><span class="line">        <span class="comment"># of connections we accept at a time.  Ideally we would accept</span></span><br><span class="line">        <span class="comment"># up to the number of connections that were waiting when we</span></span><br><span class="line">        <span class="comment"># entered this method, but this information is not available</span></span><br><span class="line">        <span class="comment"># (and rearranging this method to call accept() as many times</span></span><br><span class="line">        <span class="comment"># as possible before running any callbacks would have adverse</span></span><br><span class="line">        <span class="comment"># effects on load balancing in multiprocess configurations).</span></span><br><span class="line">        <span class="comment"># Instead, we use the (default) listen backlog as a rough</span></span><br><span class="line">        <span class="comment"># heuristic for the number of connections we can reasonably</span></span><br><span class="line">        <span class="comment"># accept at once.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(_DEFAULT_BACKLOG):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                connection, address = sock.accept()</span><br><span class="line">            <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">                <span class="comment"># _ERRNO_WOULDBLOCK indicate we have accepted every</span></span><br><span class="line">                <span class="comment"># connection that is available.</span></span><br><span class="line">                <span class="keyword">if</span> errno_from_exception(e) <span class="keyword">in</span> _ERRNO_WOULDBLOCK:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="comment"># ECONNABORTED indicates that there was a connection</span></span><br><span class="line">                <span class="comment"># but it was closed while still in the accept queue.</span></span><br><span class="line">                <span class="comment"># (observed on FreeBSD).</span></span><br><span class="line">                <span class="keyword">if</span> errno_from_exception(e) == errno.ECONNABORTED:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            callback(connection, address)</span><br><span class="line">    io_loop.add_handler(sock, accept_handler, IOLoop.READ)</span><br></pre></td></tr></table></figure><p>如代码注释所描述，<code>accept_handler</code> 函数在一次迭代中最多处理的 <code>_DEFAULT_BACKLOG</code> 指定数量的连接，也就是限制每次处理的连接数，以避免饿死其他的异步任务，同时有利于多进程时的负载均衡。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;有了 &lt;code&gt;tornado.ioloop&lt;/code&gt; 和 &lt;code&gt;tornado.iostream&lt;/code&gt; 这两个模块的帮助，在 tornado 中要实现一个异步 Web 服务器就变得容易了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tornado.httpserver&lt;/code&gt; 模块是 tornado 的 Web 服务器模块, 该模块中实现了 &lt;code&gt;HTTPServer&lt;/code&gt; —— 一个单线程 HTTP 服务器，其实现是基于 &lt;code&gt;tornado.tcpserver&lt;/code&gt; 模块的 &lt;code&gt;TCPServer&lt;/code&gt;，&lt;code&gt;TCPServer&lt;/code&gt; 是一个非阻塞单线程的 TCP 服务器，它负责处理 TCP 协议部分的内容，并预留接口（&lt;code&gt;handle_stream&lt;/code&gt; 抽象方法）以便针对相应的应用层协议编写服务器。所以在分析 tornado HTTP 服务器实现之前，我们先来看看 &lt;code&gt;tornado.tcpserver.TCPServer&lt;/code&gt; 的实现。&lt;/p&gt;
&lt;h3 id=&quot;TCPServer&quot;&gt;&lt;a href=&quot;#TCPServer&quot; class=&quot;headerlink&quot; title=&quot;TCPServer&quot;&gt;&lt;/a&gt;TCPServer&lt;/h3&gt;&lt;p&gt;&lt;code&gt;tornado.tcpserver&lt;/code&gt; 模块中只定义了一个 &lt;code&gt;TCPServer&lt;/code&gt; 类，由于其实现不涉及到具体的应用层协议（例如Http协议），加上有 &lt;code&gt;IOLoop&lt;/code&gt; 和 &lt;code&gt;IOStream&lt;/code&gt; 的支持，其实现比较简单。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TCPServer&lt;/code&gt; 是一个非阻塞的单线程 TCP Server，它提供了一个抽象接口方法 &lt;code&gt;handle_stream&lt;/code&gt; 供具体的子类去实现，同时支持多进程的运行方式。按照源码注释，通过调用不同的方法我们有 3 中方式使用一个  TCP Server。&lt;/p&gt;
&lt;h4 id=&quot;三种使用模式&quot;&gt;&lt;a href=&quot;#三种使用模式&quot; class=&quot;headerlink&quot; title=&quot;三种使用模式&quot;&gt;&lt;/a&gt;三种使用模式&lt;/h4&gt;&lt;h5 id=&quot;使用-listen-的单进程模式&quot;&gt;&lt;a href=&quot;#使用-listen-的单进程模式&quot; class=&quot;headerlink&quot; title=&quot;使用 listen 的单进程模式&quot;&gt;&lt;/a&gt;使用 listen 的单进程模式&lt;/h5&gt;&lt;p&gt;通过 &lt;code&gt;TCPServer&lt;/code&gt; 的 &lt;code&gt;listen&lt;/code&gt; 方法以单进程的方式运行服务器实例。示例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;server = TCPServer()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server.listen(&lt;span class=&quot;number&quot;&gt;8888&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IOLoop.instance().start()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;TCPServer&lt;/code&gt; 提供的 &lt;code&gt;listen&lt;/code&gt; 方法可以立即启动在指定的端口进行监听，并将相应的 socket 加入到 IOLoop 中。该方法可以多次调用，同时监听多个端口。由于需要 IOLoop 来驱动，所以必须确保相应的 IOLoop 实例已经启动（上述示例代码实例化 server 用的是默认 IOLoop 实例，所以通过 IOLoop.instance().start() 启动）。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="TCPServer" scheme="http://yoursite.com/tags/TCPServer/"/>
    
      <category term="non-blocking" scheme="http://yoursite.com/tags/non-blocking/"/>
    
      <category term="single-process" scheme="http://yoursite.com/tags/single-process/"/>
    
      <category term="multi-process" scheme="http://yoursite.com/tags/multi-process/"/>
    
  </entry>
  
  <entry>
    <title>tornado.util.Configurable</title>
    <link href="http://yoursite.com/2015/10/12/tornado.util.Configurable/"/>
    <id>http://yoursite.com/2015/10/12/tornado.util.Configurable/</id>
    <published>2015-10-12T07:25:01.000Z</published>
    <updated>2019-10-22T15:53:03.346Z</updated>
    
    <content type="html"><![CDATA[<p>tornado.util 模块中的 <code>Configurable</code> 是一个抽象类，该类通过继承机制为实现它的类型提供了一个简单工厂的功能。具体来说就是 <code>Configurable</code> 通过重写 <code>__new__</code> 方法来自定义类的创建，把类的构造函数变成了一个简单工厂，只要一个类继承了 <code>Configurable</code>，那么这个类在实例化时，构造函数就能像简单工厂一样选择这个类的一个子类来实例化。</p><p>一般在其他 OO 语言中我们都是通过提供静态工厂方法来实现该功能，有赖于 python 的实例化机制，这里通过重写 <code>__new__</code> 方法而把类的构造函数变成了简单工厂，使用时更直观一些，通过调用类型的构造函数就完成了选择实例化。</p><p><code>Configurable</code> 类有两个抽象方法：<code>configurable_base(cls)</code> 和 <code>configurable_default(cls)</code>，前者通常返回直接继承自 <code>Configurable</code> 的基类类型，后者返回实例化时默认使用的子类型。</p><p>目前在 tornado 中直接继承自 <code>Configurable</code> 的基类类型是 <code>AsyncHttpClient</code>, <code>IOLoop</code> 和 <code>Resolve</code>。也就是说我们可以通过 <code>AsyncHTTPClient()</code>, <code>IOLoop()</code>，<code>Resolver()</code> 直接完成从这些基类类型的子类型中选择一个配置好的类型来实例化。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configurable</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    __impl_class = <span class="literal">None</span></span><br><span class="line">    __impl_kwargs = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, **kwargs)</span>:</span></span><br><span class="line">        base = cls.configurable_base()</span><br><span class="line">        args = &#123;&#125;</span><br><span class="line">        <span class="comment"># 做一个类型判断，以便不影响直接实例化具体子类</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> base:</span><br><span class="line">            impl = cls.configured_class()</span><br><span class="line">            <span class="keyword">if</span> base.__impl_kwargs:</span><br><span class="line">                args.update(base.__impl_kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            impl = cls</span><br><span class="line">        args.update(kwargs)</span><br><span class="line">        instance = super(Configurable, cls).__new__(impl)</span><br><span class="line">        <span class="comment"># initialize vs __init__ chosen for compatiblity with AsyncHTTPClient</span></span><br><span class="line">        <span class="comment"># singleton magic.  If we get rid of that we can switch to __init__</span></span><br><span class="line">        <span class="comment"># here too.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># AsyncHTTPClient 中默认为每一个 IOLoop 实例对应一个 AsyncHTTPClient 实例。</span></span><br><span class="line">        <span class="comment"># 其重写了 __new__ 方法指定了两个命名参数：io_loop，force_instance，为了兼容</span></span><br><span class="line">        <span class="comment"># 这个初始化过程，这里选择使用 initialize 而不是 __init__ 来初始Configurable</span></span><br><span class="line">        <span class="comment"># 实例。如果能摆脱这个约束的话，我们便可以在这里使用 __init__ 方法。</span></span><br><span class="line">        instance.initialize(**args)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">configurable_base</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="string">"""返回直接继承自 configurable 类的基类类型。</span></span><br><span class="line"><span class="string">        一般情况下，返回定义（实现）这个方法的类型，但是这个不是必须的。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">configurable_default</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="string">"""返回该类型实例化时默认(__impl_class = None时)的子类类型。"""</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""初始化 `Configurable` 子类实例。</span></span><br><span class="line"><span class="string">        注意一下，初始化 Configurable 类型需要使用 `initialize` 代替 ``__init__``。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">configure</span><span class="params">(cls, impl, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""设置实例化基类类型时使用的子类类型。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        关键字参数会保存在类字段中，在实例化类型时传递给类型的构造函数。这样便可以为该类型</span></span><br><span class="line"><span class="string">        的实例设置一些全局的初始化参数。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        base = cls.configurable_base()</span><br><span class="line">        <span class="keyword">if</span> isinstance(impl, (unicode_type, bytes_type)):</span><br><span class="line">            impl = import_object(impl)</span><br><span class="line">        <span class="keyword">if</span> impl <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> issubclass(impl, cls):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Invalid subclass of %s"</span> % cls)</span><br><span class="line">        base.__impl_class = impl</span><br><span class="line">        base.__impl_kwargs = kwargs</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">configured_class</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="string">"""返回当前配置的子类类型，如果有通过 configure 方法配置则返回对应配置的类型，</span></span><br><span class="line"><span class="string">        则返回默认的子类类型。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        该方法在 __new__ 方法中有调用，用于确定类型需要实例化的具体子类类型。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        base = cls.configurable_base()</span><br><span class="line">        <span class="keyword">if</span> cls.__impl_class <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            base.__impl_class = cls.configurable_default()</span><br><span class="line">        <span class="keyword">return</span> base.__impl_class</span><br></pre></td></tr></table></figure><p>综上所述，我们通过 <code>tornado.ioloop.IOLoop.instance()</code> 便可以根据不同的平台获取 <code>IOLoop</code> 的子类实例。在 《tornado：IOLoop模块解析》 中已经有过分析，这里我们再来结合 <code>Configurable</code> 看看其代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasattr(IOLoop, <span class="string">"_instance"</span>):</span><br><span class="line">        <span class="keyword">with</span> IOLoop._instance_lock:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> hasattr(IOLoop, <span class="string">"_instance"</span>):</span><br><span class="line">                <span class="comment"># New instance after double check</span></span><br><span class="line">                <span class="comment"># 实例化一个 IOLoop 类型，由于这里构造函数实际是工厂，所以实例化的是</span></span><br><span class="line">                <span class="comment"># IOLoop 某个平台的具体类型。</span></span><br><span class="line">                IOLoop._instance = IOLoop()</span><br><span class="line">    <span class="keyword">return</span> IOLoop._instance</span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configurable_base</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> IOLoop</span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configurable_default</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="string">"""根据不同平台类选择具体的 IOLoop 类型。"""</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(select, <span class="string">"epoll"</span>):</span><br><span class="line">        <span class="keyword">from</span> tornado.platform.epoll <span class="keyword">import</span> EPollIOLoop</span><br><span class="line">        <span class="keyword">return</span> EPollIOLoop</span><br><span class="line">    <span class="keyword">if</span> hasattr(select, <span class="string">"kqueue"</span>):</span><br><span class="line">        <span class="comment"># Python 2.6+ on BSD or Mac</span></span><br><span class="line">        <span class="keyword">from</span> tornado.platform.kqueue <span class="keyword">import</span> KQueueIOLoop</span><br><span class="line">        <span class="keyword">return</span> KQueueIOLoop</span><br><span class="line">    <span class="keyword">from</span> tornado.platform.select <span class="keyword">import</span> SelectIOLoop</span><br><span class="line">    <span class="keyword">return</span> SelectIOLoop</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tornado.util 模块中的 &lt;code&gt;Configurable&lt;/code&gt; 是一个抽象类，该类通过继承机制为实现它的类型提供了一个简单工厂的功能。具体来说就是 &lt;code&gt;Configurable&lt;/code&gt; 通过重写 &lt;code&gt;__new__&lt;/code&gt; 方法来自定义类的创建，把类的构造函数变成了一个简单工厂，只要一个类继承了 &lt;code&gt;Configurable&lt;/code&gt;，那么这个类在实例化时，构造函数就能像简单工厂一样选择这个类的一个子类来实例化。&lt;/p&gt;
&lt;p&gt;一般在其他 OO 语言中我们都是通过提供静态工厂方法来实现该功能，有赖于 python 的实例化机制，这里通过重写 &lt;code&gt;__new__&lt;/code&gt; 方法而把类的构造函数变成了简单工厂，使用时更直观一些，通过调用类型的构造函数就完成了选择实例化。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Configurable&lt;/code&gt; 类有两个抽象方法：&lt;code&gt;configurable_base(cls)&lt;/code&gt; 和 &lt;code&gt;configurable_default(cls)&lt;/code&gt;，前者通常返回直接继承自 &lt;code&gt;Configurable&lt;/code&gt; 的基类类型，后者返回实例化时默认使用的子类型。&lt;/p&gt;
&lt;p&gt;目前在 tornado 中直接继承自 &lt;code&gt;Configurable&lt;/code&gt; 的基类类型是 &lt;code&gt;AsyncHttpClient&lt;/code&gt;, &lt;code&gt;IOLoop&lt;/code&gt; 和 &lt;code&gt;Resolve&lt;/code&gt;。也就是说我们可以通过 &lt;code&gt;AsyncHTTPClient()&lt;/code&gt;, &lt;code&gt;IOLoop()&lt;/code&gt;，&lt;code&gt;Resolver()&lt;/code&gt; 直接完成从这些基类类型的子类型中选择一个配置好的类型来实例化。&lt;/p&gt;
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="Configurable" scheme="http://yoursite.com/tags/Configurable/"/>
    
      <category term="AsyncHTTPClient" scheme="http://yoursite.com/tags/AsyncHTTPClient/"/>
    
      <category term="IOLoop" scheme="http://yoursite.com/tags/IOLoop/"/>
    
      <category term="Resolver" scheme="http://yoursite.com/tags/Resolver/"/>
    
  </entry>
  
  <entry>
    <title>计算掉落概率</title>
    <link href="http://yoursite.com/2015/09/28/two_algorithms_for_drop_probability/"/>
    <id>http://yoursite.com/2015/09/28/two_algorithms_for_drop_probability/</id>
    <published>2015-09-28T10:00:21.000Z</published>
    <updated>2019-10-22T15:53:03.350Z</updated>
    
    <content type="html"><![CDATA[<h4 id="计算掉落概率"><a href="#计算掉落概率" class="headerlink" title="计算掉落概率"></a>计算掉落概率</h4><p>在游戏中经常遇到按一定的掉落概率来随机掉落指定物品的情况，例如按照：钻石10%，金币20%，银币50%，饰品10%，装备10% 来计算掉落物品的类型。</p><p>通常的做法是将物品掉落概率（或者权重）变成一个离散的列表，随后产生一个随机数，再在列表中找到第一个大于该随机数的数，这个数对应的下标也就是对应的物品类型。</p><p>对应前面的例子，第一步会构建一个列表 [0.1, 0.3, 0.8, 0.9, 1.0] ；第二步生成一个随机数 0.56（假设）；第三步在列表中查找到第一个大于 0.56 的数是 0.8，下标为 2，此时掉落物品应该为银币。</p><p>这种算法比较直观，理解和实现起来也比较容易。很多时候甚至都不需要预先构建列表，而是每次累加概率直到找打大于随机数的那个数的下标。但是运用这个算法的时候，第三步我们往往使用的是顺序查找，这在掉落类型较多的时候确实不怎么好。当然大多数情况类型的种类并不是一个很大的数，所以其实也没有影响。（后面实现时候采用二分查找）</p><p>在上周的技术交流会时，同事提到了一个掉落概率算法 Alias Method，这个算法比较有意思，实现的很巧妙。算法的论文在这里：<a href="http://www.keithschwarz.com/darts-dice-coins/" target="_blank" rel="noopener">《Darts, Dice, and Coins: Sampling from a Discrete Distribution》</a></p><p>(<strong>以下引用自 <a href="http://www.cnblogs.com/younggun/p/3249772.html" target="_blank" rel="noopener">《抽奖概率-三种算法》</a></strong>)<br>Alias Method 算法大概是这么做的：把 N 种可能性拼装成一个方形（整体），分成 N 列，每列高度为 1 且最多 2 种可能性。可能性抽象为某种颜色，即每列最多有 2 种颜色，且第 n 列中必有第 n 种可能性，这里将第 n 种可能性称为原色。 想象抛出一个硬币，会落在其中一列，并且是落在列上的一种颜色。这样就得到两个数组：一个记录落在原色的概率是多少，记为 Prob 数组，另一个记录列上非原色的颜色名称，记为 Alias 数组，若该列只有原色则记为 null。</p><p>为了直接用网上的图片，我把前面例子的掉落概率依次改为 1/4, 1/5, 1/10, 1/20, 2/5。</p><img src="/2015/09/28/two_algorithms_for_drop_probability/alias.jpg"><p>由上图方形可得到两个数组： Prob: [3/4, 1/4, 1/2, 1/4, 1] Alias: [4, 4, 0, 1, null] (记录非原色的下标)。之后就根据 Prob 和 Alias 获取其中一个物品，随机产生一列 C，再随机产生一个数 R，通过与Prob[C] 比较，R 较大则返回 C，反之返回 Alias[C]。</p><h4 id="Alias-Method-算法"><a href="#Alias-Method-算法" class="headerlink" title="Alias Method 算法"></a>Alias Method 算法</h4><p>算法论文中已经有了一个 <a href="http://www.keithschwarz.com/interesting/code/?dir=alias-method" target="_blank" rel="noopener">java 的版本</a>，这里我就按照作者 java 实现 “翻译” 了 python 和 C# 版本。<br><a id="more"></a></p><h5 id="python-版本"><a href="#python-版本" class="headerlink" title="python 版本"></a>python 版本</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AliasMethod4Sample</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, probabilities_or_weights)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> probabilities_or_weights <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">assert</span> isinstance(probabilities_or_weights, (list, tuple))</span><br><span class="line"></span><br><span class="line">        self._probabilities_or_weights = probabilities_or_weights</span><br><span class="line">        self._alias = [<span class="literal">None</span>] * len(probabilities_or_weights)</span><br><span class="line"></span><br><span class="line">        total = sum(probabilities_or_weights)</span><br><span class="line">        self._probabilities = map(<span class="keyword">lambda</span> x: x/total, probabilities_or_weights)</span><br><span class="line"></span><br><span class="line">        self.__preprocess()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">probabilities_or_weights</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self._probabilities_or_weights)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">probabilities</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self._probabilities)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alias</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self._alias)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__preprocess</span><span class="params">(self)</span>:</span></span><br><span class="line">        average = <span class="number">1.0</span> / len(self._probabilities)</span><br><span class="line">        small = []</span><br><span class="line">        large = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index, val <span class="keyword">in</span> enumerate(self._probabilities):</span><br><span class="line">            <span class="keyword">if</span> val &gt;= average:</span><br><span class="line">                large.append(index)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                small.append(index)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> small <span class="keyword">and</span> large:</span><br><span class="line">            less = small.pop()</span><br><span class="line">            more = large.pop()</span><br><span class="line"></span><br><span class="line">            self._probabilities[more] = self._probabilities[more] + self._probabilities[less] - average</span><br><span class="line">            <span class="comment"># 为已经预处理好的颜色设置 `原色` 的概率和对应的 `非原色`</span></span><br><span class="line">            self._probabilities[less] = self._probabilities[less] * len(self._probabilities)</span><br><span class="line">            self._alias[less] = more</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self._probabilities[more] &gt;= average:</span><br><span class="line">                large.append(more)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                small.append(more)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> small:</span><br><span class="line">            self._probabilities[small.pop()] = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> large:</span><br><span class="line">            self._probabilities[large.pop()] = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        current_index = random.randint(<span class="number">0</span>, len(self._probabilities) - <span class="number">1</span>)</span><br><span class="line">        current_number = random.random()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current_number &lt; self._probabilities[current_index]:</span><br><span class="line">            <span class="keyword">return</span> current_index</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self._alias[current_index]</span><br></pre></td></tr></table></figure><h5 id="C-版本"><a href="#C-版本" class="headerlink" title="C# 版本"></a>C# 版本</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AliasMethod4Sample</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Random _random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Double[] ProbabilitiesOrWeights &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Int32[] Alias &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Double[] Probabilities &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AliasMethod4Sample</span>(<span class="params">ICollection&lt;Double&gt; probabilitiesOrWeights</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (probabilitiesOrWeights == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">"probabilitiesOrWeights"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (probabilitiesOrWeights.Count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"probabilitiesOrWeights is empty."</span>, <span class="string">"probabilitiesOrWeights"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ProbabilitiesOrWeights = probabilitiesOrWeights.ToArray();</span><br><span class="line">            Alias = <span class="keyword">new</span> Int32[ProbabilitiesOrWeights.Length];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> sum = ProbabilitiesOrWeights.Sum();</span><br><span class="line">            Probabilities = ProbabilitiesOrWeights.Select(x =&gt; x/sum).ToArray();</span><br><span class="line"></span><br><span class="line">            Init();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Int32 <span class="title">Next</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> index = _random.Next(<span class="number">0</span>, Probabilities.Length);</span><br><span class="line">            <span class="keyword">var</span> val = _random.NextDouble();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> val &lt; Probabilities[index] ? index : Alias[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> average = <span class="number">1.0</span>/Probabilities.Length;</span><br><span class="line">            <span class="keyword">var</span> small = <span class="keyword">new</span> Queue&lt;Int32&gt;();</span><br><span class="line">            <span class="keyword">var</span> large = <span class="keyword">new</span> Queue&lt;Int32&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; Probabilities.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Probabilities[i] &gt;= average)</span><br><span class="line">                &#123;</span><br><span class="line">                    large.Enqueue(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    small.Enqueue(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (small.Count &gt; <span class="number">0</span> &amp;&amp; large.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> less = small.Dequeue();</span><br><span class="line">                <span class="keyword">var</span> more = large.Dequeue();</span><br><span class="line"></span><br><span class="line">                Probabilities[more] = Probabilities[more] + Probabilities[less] - average;</span><br><span class="line">                Probabilities[less] = Probabilities[less]*Probabilities.Length;</span><br><span class="line">                Alias[less] = more;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Probabilities[more] &gt;= average)</span><br><span class="line">                &#123;</span><br><span class="line">                    large.Enqueue(more);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    small.Enqueue(more);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (large.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Probabilities[large.Dequeue()] = <span class="number">1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (small.Count&gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Probabilities[small.Dequeue()] = <span class="number">1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="常用的离散算法"><a href="#常用的离散算法" class="headerlink" title="常用的离散算法"></a>常用的离散算法</h4><p>常用的离散算法，第三步改为二分查找。</p><h5 id="python-版本-1"><a href="#python-版本-1" class="headerlink" title="python 版本"></a>python 版本</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiscreteMethod4Sample</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, probabilities_or_weights)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> probabilities_or_weights <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">assert</span> isinstance(probabilities_or_weights, (list, tuple))</span><br><span class="line"></span><br><span class="line">        total = sum(probabilities_or_weights)</span><br><span class="line">        discrete_table = []</span><br><span class="line">        <span class="keyword">for</span> pw <span class="keyword">in</span> probabilities_or_weights:</span><br><span class="line">            <span class="keyword">if</span> discrete_table:</span><br><span class="line">                discrete_table.append((discrete_table[<span class="number">-1</span>] + pw)/total) </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                discrete_table.append(pw/total)</span><br><span class="line"></span><br><span class="line">        self._discrete_table = discrete_table</span><br><span class="line">        self._probabilities_or_weights = probabilities_or_weights</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discrete_table</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self._discrete_table)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">probabilities_or_weights</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self._probabilities_or_weights)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        current_probability = random.random()</span><br><span class="line">        <span class="keyword">return</span> bisect.bisect_right(self._discrete_table, current_probability)</span><br></pre></td></tr></table></figure><h5 id="C-版本-1"><a href="#C-版本-1" class="headerlink" title="C# 版本"></a>C# 版本</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiscreteMethod4Sample</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Random _random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;Double&gt; _discreteTable;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Double[] ProbabilitiesOrWeights &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Double[] DiscreteTable</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _discreteTable.ToArray();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscreteMethod4Sample</span>(<span class="params">ICollection&lt;Double&gt; probabilitiesOrWeights</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (probabilitiesOrWeights == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">"probabilitiesOrWeights"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (probabilitiesOrWeights.Count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"probabilitiesOrWeights is empty."</span>, <span class="string">"probabilitiesOrWeights"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> rawProbabilitiesOrWeights = probabilitiesOrWeights.ToArray();</span><br><span class="line">            <span class="keyword">var</span> discreteTable = <span class="keyword">new</span> Double[probabilitiesOrWeights.Count];</span><br><span class="line"></span><br><span class="line">            discreteTable[<span class="number">0</span>] = rawProbabilitiesOrWeights[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; rawProbabilitiesOrWeights.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                discreteTable[i] = discreteTable[i - <span class="number">1</span>] + rawProbabilitiesOrWeights[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> total = rawProbabilitiesOrWeights.Sum();</span><br><span class="line">            ProbabilitiesOrWeights = rawProbabilitiesOrWeights;</span><br><span class="line">            _discreteTable = discreteTable.Select(x =&gt; x/total).ToList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Int32 <span class="title">Next</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> index = _discreteTable.BinarySearch(_random.NextDouble());</span><br><span class="line">            <span class="keyword">return</span> index &lt; <span class="number">0</span> ? ~index : index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;计算掉落概率&quot;&gt;&lt;a href=&quot;#计算掉落概率&quot; class=&quot;headerlink&quot; title=&quot;计算掉落概率&quot;&gt;&lt;/a&gt;计算掉落概率&lt;/h4&gt;&lt;p&gt;在游戏中经常遇到按一定的掉落概率来随机掉落指定物品的情况，例如按照：钻石10%，金币20%，银币50%，饰品10%，装备10% 来计算掉落物品的类型。&lt;/p&gt;
&lt;p&gt;通常的做法是将物品掉落概率（或者权重）变成一个离散的列表，随后产生一个随机数，再在列表中找到第一个大于该随机数的数，这个数对应的下标也就是对应的物品类型。&lt;/p&gt;
&lt;p&gt;对应前面的例子，第一步会构建一个列表 [0.1, 0.3, 0.8, 0.9, 1.0] ；第二步生成一个随机数 0.56（假设）；第三步在列表中查找到第一个大于 0.56 的数是 0.8，下标为 2，此时掉落物品应该为银币。&lt;/p&gt;
&lt;p&gt;这种算法比较直观，理解和实现起来也比较容易。很多时候甚至都不需要预先构建列表，而是每次累加概率直到找打大于随机数的那个数的下标。但是运用这个算法的时候，第三步我们往往使用的是顺序查找，这在掉落类型较多的时候确实不怎么好。当然大多数情况类型的种类并不是一个很大的数，所以其实也没有影响。（后面实现时候采用二分查找）&lt;/p&gt;
&lt;p&gt;在上周的技术交流会时，同事提到了一个掉落概率算法 Alias Method，这个算法比较有意思，实现的很巧妙。算法的论文在这里：&lt;a href=&quot;http://www.keithschwarz.com/darts-dice-coins/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Darts, Dice, and Coins: Sampling from a Discrete Distribution》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(&lt;strong&gt;以下引用自 &lt;a href=&quot;http://www.cnblogs.com/younggun/p/3249772.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《抽奖概率-三种算法》&lt;/a&gt;&lt;/strong&gt;)&lt;br&gt;Alias Method 算法大概是这么做的：把 N 种可能性拼装成一个方形（整体），分成 N 列，每列高度为 1 且最多 2 种可能性。可能性抽象为某种颜色，即每列最多有 2 种颜色，且第 n 列中必有第 n 种可能性，这里将第 n 种可能性称为原色。 想象抛出一个硬币，会落在其中一列，并且是落在列上的一种颜色。这样就得到两个数组：一个记录落在原色的概率是多少，记为 Prob 数组，另一个记录列上非原色的颜色名称，记为 Alias 数组，若该列只有原色则记为 null。&lt;/p&gt;
&lt;p&gt;为了直接用网上的图片，我把前面例子的掉落概率依次改为 1/4, 1/5, 1/10, 1/20, 2/5。&lt;/p&gt;
&lt;img src=&quot;/2015/09/28/two_algorithms_for_drop_probability/alias.jpg&quot;&gt;
&lt;p&gt;由上图方形可得到两个数组： Prob: [3/4, 1/4, 1/2, 1/4, 1] Alias: [4, 4, 0, 1, null] (记录非原色的下标)。之后就根据 Prob 和 Alias 获取其中一个物品，随机产生一列 C，再随机产生一个数 R，通过与Prob[C] 比较，R 较大则返回 C，反之返回 Alias[C]。&lt;/p&gt;
&lt;h4 id=&quot;Alias-Method-算法&quot;&gt;&lt;a href=&quot;#Alias-Method-算法&quot; class=&quot;headerlink&quot; title=&quot;Alias Method 算法&quot;&gt;&lt;/a&gt;Alias Method 算法&lt;/h4&gt;&lt;p&gt;算法论文中已经有了一个 &lt;a href=&quot;http://www.keithschwarz.com/interesting/code/?dir=alias-method&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java 的版本&lt;/a&gt;，这里我就按照作者 java 实现 “翻译” 了 python 和 C# 版本。&lt;br&gt;
    
    </summary>
    
      <category term="编程基础" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="掉落概率" scheme="http://yoursite.com/tags/%E6%8E%89%E8%90%BD%E6%A6%82%E7%8E%87/"/>
    
      <category term="Alias Method" scheme="http://yoursite.com/tags/Alias-Method/"/>
    
  </entry>
  
  <entry>
    <title>tornado.iostream 模块解析</title>
    <link href="http://yoursite.com/2015/09/27/tornado.iostream/"/>
    <id>http://yoursite.com/2015/09/27/tornado.iostream/</id>
    <published>2015-09-27T05:25:01.000Z</published>
    <updated>2019-10-22T15:53:03.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从-Files-Sockets-到-Stream"><a href="#从-Files-Sockets-到-Stream" class="headerlink" title="从 Files/Sockets 到 Stream"></a>从 Files/Sockets 到 Stream</h3><p><code>tornado.iostream</code> 模块为 Tornado 提供了一系列读写非阻塞 files/sockets 的工具类。该模块主要包括以下 4 个主要的工具类：</p><ul><li><code>BaseIOStream</code>: 基础流读写接口，作为特定流的父类；</li><li><code>IOStream</code>: 针对非阻塞 sockets 的流实现；</li><li><code>SSLIOStream</code>: SSL-aware版本的 <code>IOStream</code> 实现；</li><li><code>PipeIOStream</code>: 针对管道(Pipe)的流实现；</li></ul><p><code>BaseIOStream</code> 作为基础流读写接口，实现了大部分的功能封装。后面的源代码分析中，主要就是基于该类并结合其非阻塞 socket 版本的 <code>IOStream</code> 来讨论。</p><p>查看该模块的时候，我们会发现两个模块内函数 <code>_double_prefix(deque)</code> 与 <code>_merge_prefix(deque, size)</code>。这两个工具函数的实现都很简单，但是为流的读写提供通用的操作数据块(chunk)的功能：</p><ul><li><code>_double_prefix(deque)</code>: 该函数提供了将 buffer 的第 1 个 chunk 增大至少 1 倍的功能，该功能现在用在按条件在流的 buffer 中搜索匹配字符串时逐渐扩大搜索的数据块大小。</li><li><code>_merge_prefix(deque, size)</code>: 该函数提供了将 buffer 的第 1 个 chunk 调整到指定 size 大小。这在读写流时非常有用， <code>_double_prefix(deque)</code> 就是通过该函数来调整 chunk 大小的。在将流的 write_buffer 写入 fd 时，通过该函数适当调整第 1 个 chunk 的大小，我们就可以直接操作 buffer 的第 1 个 chunk 来达到操作整个 buffer 的目的，简化了实现的难度。详细可见 <code>BaseStream._handle_writ</code> 函数实现代码。</li></ul><h3 id="IOStream"><a href="#IOStream" class="headerlink" title="IOStream"></a>IOStream</h3><h4 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h4><p>在源码的开始部分，作者写了一大段介绍 recv/send 与 read/write 函数的区别，以及各平台的操作非阻塞 I/O 时返回的错误码。recv/send 与 read/write 函数的区别大体上就是说，前者是特化的函数，提供了一些额外的选项来控制 fd 的读写操作，针对具体的 fd 实例你可以设置选项忽略 SIGPIPE 信号或者让 socket 发送带外数据等等， 后者只是提供了通用的 fd 读写操作。对于操作非阻塞 fd 返回的错误码，如下模块的静态变量对应的注释所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非阻塞操作时，缓冲区满（无法写）时或者缓冲区空（读不到数据）时返回 EAGAIN， BSD 下使用 EWOULDBLOCK， Windows下使用 WSAEWOULDBLOCK</span></span><br><span class="line">_ERRNO_WOULDBLOCK = (errno.EWOULDBLOCK, errno.EAGAIN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For windows</span></span><br><span class="line"><span class="keyword">if</span> hasattr(errno, <span class="string">"WSAEWOULDBLOCK"</span>):</span><br><span class="line">    _ERRNO_WOULDBLOCK += (errno.WSAEWOULDBLOCK,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># These errnos indicate that a connection has been abruptly terminated.</span></span><br><span class="line"><span class="comment"># They should be caught and handled less noisily than other errors.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># `ECONNRESET`: 该异常一般发生在连接的一端（A）进程较另一端（B)提前终止时。A 进程终止时会向 B 发送 FIN 后进入</span></span><br><span class="line"><span class="comment"># FIN_WAIT1 状态，B 回应 ACK，A 收到 FIN 的 ACK 进入 FIN_WAIT2 状态。B 收到 FIN 时，会向应用程序交付 EOF，</span></span><br><span class="line"><span class="comment"># 进入 CLOSE_WAIT 状态。若此时 B 进程没有正常处理 FIN（例如被阻塞）而再次向处于 FIN_WAIT2 的 A 发送数据，将会</span></span><br><span class="line"><span class="comment"># 收到 RST，引发该错误。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># `ECONNABORTED`: 软件引起的连接中止，当服务端和客户端完成三次握手后，服务端正在等待服务进程调用 accept 时候却收到客户端</span></span><br><span class="line"><span class="comment"># 发来一个 RST 分节，引发该错误。POSIX 规定此时的 errno 值必须 ECONNABORTED。源自 Berkeley 的实现完全在内核中处理中</span></span><br><span class="line"><span class="comment"># 止的连接，服务进程将永远不知道该中止的发生。服务器进程一般可以忽略该错误，直接再次调用 accept。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># `EPIPE`: 错误被描述为 "broken pipe" ，即 "管道破裂"，这种情况一般发生在客户进程不理会（或未及时处理）socket 错误，</span></span><br><span class="line"><span class="comment"># 而继续向 socket 写入更多数据时，内核将向客户进程发送 SIGPIPE 信号，该信号默认会使进程终止（此时该前台进程未进行 core dump）。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># `ETIMEDOUT`: 连接超时， 这种错误一般发生在服务器端崩溃而不响应客户端 ACK 时，客户端最终放弃尝试连接时引发该错误。</span></span><br><span class="line">_ERRNO_CONNRESET = (errno.ECONNRESET, errno.ECONNABORTED, errno.EPIPE,</span><br><span class="line">                    errno.ETIMEDOUT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For windows</span></span><br><span class="line"><span class="keyword">if</span> hasattr(errno, <span class="string">"WSAECONNRESET"</span>):</span><br><span class="line">    _ERRNO_CONNRESET += (errno.WSAECONNRESET, errno.WSAECONNABORTED, errno.WSAETIMEDOUT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># More non-portable errnos:</span></span><br><span class="line"><span class="comment"># 在以非阻塞方式 connect() 时，返回的结果如果是 -1 ，并且错误号为 EINPROGRESS ，那么表示</span></span><br><span class="line"><span class="comment"># 连接还在进行并处理中(IN PROGRESS)，而不是真的发生了错误。</span></span><br><span class="line">_ERRNO_INPROGRESS = (errno.EINPROGRESS,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For windows</span></span><br><span class="line"><span class="keyword">if</span> hasattr(errno, <span class="string">"WSAEINPROGRESS"</span>):</span><br><span class="line">    _ERRNO_INPROGRESS += (errno.WSAEINPROGRESS,)</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="流的读写实现"><a href="#流的读写实现" class="headerlink" title="流的读写实现"></a>流的读写实现</h4><p><code>BaseIOStream</code> 提供了一个对非阻塞 I/O 读写的抽象，它主要提供了 5 个读写方法：</p><ol><li><p><code>read_until_regex</code>: 从流中读取数据直到遇上与指定正则表达式（由 regex 参数指定）匹配的字符串。在底层 fd 关闭或者读取指定的最大字节数据（由 max_bytes 参数指定）后还没有匹配上则抛出 UnsatisfiableReadError 异常。</p></li><li><p><code>read_until</code>: 从流中读取数据直到遇到指定的分隔符（有 delimiter 参数指定）为止。在底层的 fd 关闭或者读取指定的最大字节数据后还没有遇到分隔符则抛出 UnsatisfiableReadError异常。该方法实际上为读取 Http Header 遇到空行分隔符自动停止提供了方便。</p></li><li><p><code>read_bytes</code>: 从流中读取指定大小的字节数据。这实际上为根据 “Content-Length” 读取 Http Body 提供了方便。需要注意的时，如果底层 fd 关闭时也没有读取到指定大小的字节数据（由num_bytes 参数指定），callback 不会被调用。</p></li><li><p><code>read_until_close</code>: 从流中读取数据直到底层 fd 关闭为止。与通过无限大的 num_bytes 调用 <code>read_bytes</code> 方法类似，但是 callback 始终会被调用。</p></li><li><p><code>write</code>: 将指定的数据写入流的 write buffer，并持续监测底层 fd 的写事件知道将 write buffer 全部写入 fd。</p></li></ol><p>上述方法都提供了 <code>callback</code> 参数作为异步操作完成后的回调函数，当该参数不为 None 时读取的数据将会作为 <code>callback</code> 的参数回调；为 None 时，方法将返回一个 <code>.Future</code> 实例，数据将作为 <code>.Future</code> 的 result 返回。<strong>这里稍微提一下，<code>read_bytes</code> 与 <code>read_until_close</code> 允许分多次返回读取的数据而不必等待所有数据都到了才返回，所以提供了一个额外的参数 <code>streaming_callback</code>，当该参数不为 None 时，一旦流的 read buffer 中有数据可用便立即将数据作为 <code>streaming_callback</code> 的参数回调， <code>callback</code> 的回调参数为空（b””）</strong>。</p><p>对于具体类型 fd 的操作， <code>BaseIOStream</code> 提供了相关的抽象方法由具体的流实现类来实现，这些方法诸如：<code>write_to_fd</code>、<code>read_from_fd</code>、<code>close_fd</code>、<code>get_fd_error</code> 等等。</p><p><code>BaseIOStream</code> 提供的读写方法基本上实现了流读取的逻辑，接下来将就各个方法的实现代码进行分析。</p><h5 id="深入-read-until-regex-与-read-until-方法"><a href="#深入-read-until-regex-与-read-until-方法" class="headerlink" title="深入 read_until_regex 与 read_until 方法"></a>深入 read_until_regex 与 read_until 方法</h5><p>这两个方法比较相似，都是提供匹配特定字符串的读，<code>read_until</code> 更像是 <code>read_until_regex</code>  的特化版本，所以把二者放在一起分析。先来看看 <code>read_until_regex</code>  方法的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_until_regex</span><span class="params">(self, regex, callback=None, max_bytes=None)</span>:</span></span><br><span class="line">    <span class="string">"""Asynchronously read until we have matched the given regex.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The result includes the data that matches the regex and anything</span></span><br><span class="line"><span class="string">    that came before it.  If a callback is given, it will be run</span></span><br><span class="line"><span class="string">    with the data as an argument; if not, this method returns a</span></span><br><span class="line"><span class="string">    `.Future`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If ``max_bytes`` is not None, the connection will be closed</span></span><br><span class="line"><span class="string">    if more than ``max_bytes`` bytes have been read and the regex is</span></span><br><span class="line"><span class="string">    not satisfied.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionchanged:: 4.0</span></span><br><span class="line"><span class="string">        Added the ``max_bytes`` argument.  The ``callback`` argument is</span></span><br><span class="line"><span class="string">        now optional and a `.Future` will be returned if it is omitted.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    future = self._set_read_callback(callback)</span><br><span class="line">    <span class="comment"># 在 read_until 方法中分隔符是保存在另外一个实例字段中：</span></span><br><span class="line">    <span class="comment"># self._read_delimiter = delimiter</span></span><br><span class="line">    self._read_regex = re.compile(regex)</span><br><span class="line">    self._read_max_bytes = max_bytes</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self._try_inline_read()</span><br><span class="line">    <span class="keyword">except</span> UnsatisfiableReadError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># Handle this the same way as in _handle_events.</span></span><br><span class="line">        gen_log.info(<span class="string">"Unsatisfiable read, closing connection: %s"</span> % e)</span><br><span class="line">        self.close(exc_info=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> future</span><br><span class="line">    <span class="keyword">return</span> future</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_set_read_callback</span><span class="params">(self, callback)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> self._read_callback <span class="keyword">is</span> <span class="literal">None</span>, <span class="string">"Already reading"</span></span><br><span class="line">    <span class="keyword">assert</span> self._read_future <span class="keyword">is</span> <span class="literal">None</span>, <span class="string">"Already reading"</span></span><br><span class="line">    <span class="comment"># 按照异步设计，在 callback 指定的情况下，self._read_future = None，</span></span><br><span class="line">    <span class="comment"># 否则设置 self._read_future = TracebackFuture() 用于返回异步执</span></span><br><span class="line">    <span class="comment"># 行结果。</span></span><br><span class="line">    <span class="keyword">if</span> callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self._read_callback = stack_context.wrap(callback)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._read_future = TracebackFuture()</span><br><span class="line">    <span class="keyword">return</span> self._read_future</span><br></pre></td></tr></table></figure><p>在 <code>read_until</code> 方法中分隔符是保存在另外一个实例字段 <code>_read_delimiter</code> 中，以便在数据搜索匹配时使用（参见后面 <code>_find_read_pos()</code> 方法），除此之外两方法的实现是相同的。 <code>_set_read_callback</code> 方法负责设置异步读操作完成的回调， <code>_read_callback</code> 与 <code>_read_future</code> 二选一（常见后面 <code>_run_read_callback</code> 方法实现）。<code>_try_inline_read</code> 尝试先在流的 read buffer 中完成读操作以便在下一次 IOLoop 时将结果返回，否则就注册监听 fd 的读事件，代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_try_inline_read</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Attempt to complete the current read operation from buffered data.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the read can be completed without blocking, schedules the</span></span><br><span class="line"><span class="string">    read callback on the next IOLoop iteration; otherwise starts</span></span><br><span class="line"><span class="string">    listening for reads on the socket.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># See if we've already got the data from a previous read</span></span><br><span class="line">    <span class="comment"># 目前实际上仅在通过 read_bytes/read_until_close 方法调用时有意义，read_until_regex/read_until</span></span><br><span class="line">    <span class="comment"># 方法是没有 streaming_callback 参数的，当然也就不存在 run streaming callback。在这里调用</span></span><br><span class="line">    <span class="comment"># self._run_streaming_callback() 只是为了一般性而已。</span></span><br><span class="line">    self._run_streaming_callback()</span><br><span class="line">    <span class="comment"># pos 若不为 None，则表示数据读取完成（读取到足够大小的数据、正则表达式匹配成功或者遇到指定的分隔符）。对于</span></span><br><span class="line">    <span class="comment"># read_until_close 方法调用始终返回 None</span></span><br><span class="line">    pos = self._find_read_pos()</span><br><span class="line">    <span class="keyword">if</span> pos <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 重置读取状态，获取数据，将读操作回调(_read_callback 或者 _read_future )加入 IOLoop，在下一次</span></span><br><span class="line">        <span class="comment"># IOLoop 时将数据返回。</span></span><br><span class="line">        self._read_from_buffer(pos)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 检测底层 fd 是否已经关闭，如果关闭则抛出 StreamClosedError 异常</span></span><br><span class="line">    self._check_closed()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 因为前面尝试从 read buffer 中读取数据完成操作失败了，所以这里再尝试从底层的 fd 中读取（可读）数据来完成此次读操作。</span></span><br><span class="line">        <span class="comment"># 其内部实现也就是从 fd 中把数据读到 read buffer 再重复前面的 self._run_streaming_callback() 和</span></span><br><span class="line">        <span class="comment"># self._find_read_pos() 操作，然后把 self._find_read_pos() 的结果返回。</span></span><br><span class="line">        pos = self._read_to_buffer_loop()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="comment"># If there was an in _read_to_buffer, we called close() already,</span></span><br><span class="line">        <span class="comment"># but couldn't run the close callback because of _pending_callbacks.</span></span><br><span class="line">        <span class="comment"># Before we escape from this function, run the close callback if</span></span><br><span class="line">        <span class="comment"># applicable.</span></span><br><span class="line">        self._maybe_run_close_callback()</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">if</span> pos <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self._read_from_buffer(pos)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># We couldn't satisfy the read inline, so either close the stream</span></span><br><span class="line">    <span class="comment"># or listen for new data.</span></span><br><span class="line">    <span class="keyword">if</span> self.closed():</span><br><span class="line">        self._maybe_run_close_callback()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果经过上述尝试都还无法完成此次读操作，则注册监听 fd 的读事件直到读操作完成或者 fd 关闭。</span></span><br><span class="line">        <span class="comment"># _handle_events 方法会异步处理 fd 的事件，对应的 READ 事件会调用 _handle_read 方法，</span></span><br><span class="line">        <span class="comment"># 而 _handle_read 方法内部会调用 _read_to_buffer_loop 方法，然后执行和上述差不多的操作。</span></span><br><span class="line">        self._add_io_state(ioloop.IOLoop.READ)</span><br></pre></td></tr></table></figure><h6 id="run-streaming-callback-方法"><a href="#run-streaming-callback-方法" class="headerlink" title="_run_streaming_callback 方法"></a>_run_streaming_callback 方法</h6><p>上面代码中的 <code>_run_streaming_callback()</code> 方法顾名思义，是用于执行 <code>self._streaming_callback</code> 回调，代码很简单，在 read buffer 有数据可读时调用 streaming_callback，代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_streaming_callback</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._streaming_callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self._read_buffer_size:</span><br><span class="line">        bytes_to_consume = self._read_buffer_size</span><br><span class="line">        <span class="comment"># 读取不超过 buffer size 的数据</span></span><br><span class="line">        <span class="keyword">if</span> self._read_bytes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            bytes_to_consume = min(self._read_bytes, bytes_to_consume)</span><br><span class="line">            self._read_bytes -= bytes_to_consume</span><br><span class="line">        self._run_read_callback(bytes_to_consume, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>最终负责调用回调函数的方法是 <code>_run_read_callback</code>，该方法全权负责根据指定的参数调用 read 操作的回调。参数 <code>size</code> 指定要从 read buffer 中读取的数据大小，<code>streaming</code> 指定回调的是 <code>_streaming_callback</code> 还是最终的 <code>_read_callback</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_read_callback</span><span class="params">(self, size, streaming)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> streaming:</span><br><span class="line">        callback = self._streaming_callback</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        callback = self._read_callback</span><br><span class="line">        self._read_callback = self._streaming_callback = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 这里其实有一个 bug ，后面这个 if 的内容逻辑上讲应该在前一个else里面（与</span></span><br><span class="line">    <span class="comment"># callback = self._read_callback 处于同一作用域）。_read_callback 与 _read_future</span></span><br><span class="line">    <span class="comment"># 是读操作完成后的回调，二者是二选一。streaming 指定为 True 的时候是不需要调用 _read_future。</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 当指定 streaming_callback(is not None) 而不指定 callback(is None) 调用 read_bytes 或者</span></span><br><span class="line">    <span class="comment"># read_until_close 方法时，后面的断言就会失败。如果用 –O 或 –oo 选项运行 Python 而忽略掉断言的</span></span><br><span class="line">    <span class="comment"># 话，callback 是不会被调用的，读取的数据将直接作为 _read_future 的结果返回。</span></span><br><span class="line">    <span class="keyword">if</span> self._read_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> callback <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">        future = self._read_future</span><br><span class="line">        self._read_future = <span class="literal">None</span></span><br><span class="line">        future.set_result(self._consume(size))</span><br><span class="line">    <span class="keyword">if</span> callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> self._read_future <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">        self._run_callback(callback, self._consume(size))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># If we scheduled a callback, we will add the error listener</span></span><br><span class="line">        <span class="comment"># afterwards.  If we didn't, we have to do it now.</span></span><br><span class="line">        self._maybe_add_error_listener()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_consume</span><span class="params">(self, loc)</span>:</span></span><br><span class="line">    <span class="comment"># loc=0时返回的是空而不是None,这就是前面分析到的 streaming_callback 被指定时，</span></span><br><span class="line">    <span class="comment"># read 操作完成后调用 _read_callback 或者 _read_future 的数据是空。</span></span><br><span class="line">    <span class="keyword">if</span> loc == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b""</span></span><br><span class="line">    _merge_prefix(self._read_buffer, loc)</span><br><span class="line">    self._read_buffer_size -= loc</span><br><span class="line">    <span class="keyword">return</span> self._read_buffer.popleft()</span><br></pre></td></tr></table></figure><p>NOTE: 正如上面代码注释中指出的，这个版本的 Tornado（4.0.1） 在 <code>_run_read_callback</code> 方法实现有 bug。后续版本已经修复了这个 bug，代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_read_callback</span><span class="params">(self, size, streaming)</span>:</span></span><br><span class="line">   <span class="keyword">if</span> streaming:</span><br><span class="line">       callback = self._streaming_callback</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       callback = self._read_callback</span><br><span class="line">       self._read_callback = self._streaming_callback = <span class="literal">None</span></span><br><span class="line">       <span class="keyword">if</span> self._read_future <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="keyword">assert</span> callback <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">           future = self._read_future</span><br><span class="line">           self._read_future = <span class="literal">None</span></span><br><span class="line">           future.set_result(self._consume(size))</span><br><span class="line">   <span class="keyword">if</span> callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">       <span class="keyword">assert</span> (self._read_future <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> streaming</span><br><span class="line">       self._run_callback(callback, self._consume(size))</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       <span class="comment"># If we scheduled a callback, we will add the error listener</span></span><br><span class="line">       <span class="comment"># afterwards.  If we didn't, we have to do it now.</span></span><br><span class="line">       <span class="comment"># 通过 self._run_callback 调用 callback 后会自动执行 _maybe_add_error_listener 方法。</span></span><br><span class="line">       <span class="comment"># 而如果调用的是 future.set_result 的话，则需要在这里执行下 _maybe_add_error_listener 方法。</span></span><br><span class="line">       self._maybe_add_error_listener()</span><br></pre></td></tr></table></figure><p><code>_run_callback</code> 方法会将 <code>callback</code> 加入到 IOLoop  的回调列表中，以便在下一次 IOLoop 时执行回调。在将 <code>callback</code> 加入 IOLoop 之前， <code>_run_callback</code> 对其进行了上下文清理（注：阻止 callback 中又添加 callback 到 IOLoop 造成上下文无限增长和重入）和包装（异常时主动释放资源，回调完成后调用 _maybe_add_error_listener 方法），代码很少，但是注释很负责。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_callback</span><span class="params">(self, callback, *args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        self._pending_callbacks -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> callback(*args)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            app_log.error(<span class="string">"Uncaught exception, closing connection."</span>,</span><br><span class="line">                          exc_info=<span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># Close the socket on an uncaught exception from a user callback</span></span><br><span class="line">            <span class="comment"># (It would eventually get closed when the socket object is</span></span><br><span class="line">            <span class="comment"># gc'd, but we don't want to rely on gc happening before we</span></span><br><span class="line">            <span class="comment"># run out of file descriptors)</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># 主动关闭底层的 fd，并将其引用释放而不用等待 GC 来释放</span></span><br><span class="line">            self.close(exc_info=<span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># Re-raise the exception so that IOLoop.handle_callback_exception</span></span><br><span class="line">            <span class="comment"># can see it and log the error</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._maybe_add_error_listener()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We schedule callbacks to be run on the next IOLoop iteration</span></span><br><span class="line">    <span class="comment"># rather than running them directly for several reasons:</span></span><br><span class="line">    <span class="comment"># * Prevents unbounded stack growth when a callback calls an</span></span><br><span class="line">    <span class="comment">#   IOLoop operation that immediately runs another callback</span></span><br><span class="line">    <span class="comment"># * Provides a predictable execution context for e.g.</span></span><br><span class="line">    <span class="comment">#   non-reentrant mutexes</span></span><br><span class="line">    <span class="comment"># * Ensures that the try/except in wrapper() is run outside</span></span><br><span class="line">    <span class="comment">#   of the application's StackContexts</span></span><br><span class="line">    <span class="keyword">with</span> stack_context.NullContext():</span><br><span class="line">        <span class="comment"># stack_context was already captured in callback, we don't need to</span></span><br><span class="line">        <span class="comment"># capture it again for IOStream's wrapper.  This is especially</span></span><br><span class="line">        <span class="comment"># important if the callback was pre-wrapped before entry to</span></span><br><span class="line">        <span class="comment"># IOStream (as in HTTPConnection._header_callback), as we could</span></span><br><span class="line">        <span class="comment"># capture and leak the wrong context here.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># 对于已经被 stack_context 捕捉了上下文快照的 callback , 不需要再重复捕捉（capture）</span></span><br><span class="line">        <span class="comment"># ，否则会造成上下文无限增长和重入（注：当 IOLoop 执行一个 callback 时，该 callback 又往</span></span><br><span class="line">        <span class="comment">#  IOLoop 添加一个 new callback 时会发生这种情况），所以这里清空上下文避免再次 capture。</span></span><br><span class="line">        <span class="comment"># （注：异步回调一旦加入到 IOLoop 就会被指定调用 stack_context.wrap 方法捕捉上下文快照，</span></span><br><span class="line">        <span class="comment"># 实现细节请参考 stack_context 模块。）</span></span><br><span class="line">        self._pending_callbacks += <span class="number">1</span></span><br><span class="line">        self.io_loop.add_callback(wrapper)</span><br></pre></td></tr></table></figure><p>需要注意一下的是 <code>_maybe_add_error_listener()</code> 方法，该方法保证在最后一个 <code>callback</code> 调用结束后尝试注册检测底层 fd Error 事件。该方法和其内部调用的 <code>_add_io_state</code> 方法使用了一个优化技巧，作者在代码注释中写的很清楚。简单来说就是，由于对流的读写实现有优先级：</p><ol><li>优先直接从流的 buffer 和 fd buffer 中读写（fast path）；</li><li>只有流和 fd 的 buffer 不可用时，才监听 fd 的读写事件，异步读写（slow path）。</li></ol><p><strong>注：不管采用的是哪一种读写方式，最终执行 <code>callback</code> 还是通过 <code>_run_callback</code> 方法。</strong><br><code>_add_io_state</code> 方法将对 fd 读写事件的监听与 Error 事件监听捆绑在一起，所以只有我们需要异步读写时才捕获 fd Error 事件，这样实际上也就推迟了对 fd 关闭的检测，以便流和fd 的 buffer 尽可能被读取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_maybe_add_error_listener</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># This method is part of an optimization: to detect a connection that</span></span><br><span class="line">    <span class="comment"># is closed when we're not actively reading or writing, we must listen</span></span><br><span class="line">    <span class="comment"># for read events.  However, it is inefficient to do this when the</span></span><br><span class="line">    <span class="comment"># connection is first established because we are going to read or write</span></span><br><span class="line">    <span class="comment"># immediately anyway.  Instead, we insert checks at various times to</span></span><br><span class="line">    <span class="comment"># see if the connection is idle and add the read listener then.</span></span><br><span class="line">    <span class="keyword">if</span> self._pending_callbacks != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> self._state <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self._state == ioloop.IOLoop.ERROR:</span><br><span class="line">        <span class="keyword">if</span> self.closed():</span><br><span class="line">            self._maybe_run_close_callback()</span><br><span class="line">        <span class="comment"># 只要 buffer 中有数据或者 _close_callback=None 就不会主动去监测 fd 的读事件。</span></span><br><span class="line">        <span class="comment"># 这样一来，对 fd 关闭的检测就依赖于明确的对 fd 的异步读写监测，即主动调用 _add_io_state</span></span><br><span class="line">        <span class="comment"># 方法。</span></span><br><span class="line">        <span class="keyword">elif</span> (self._read_buffer_size == <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">                      self._close_callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">            self._add_io_state(ioloop.IOLoop.READ)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add_io_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line">    <span class="string">"""Adds `state` (IOLoop.&#123;READ,WRITE&#125; flags) to our event handler.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Implementation notes: Reads and writes have a fast path and a</span></span><br><span class="line"><span class="string">    slow path.  The fast path reads synchronously from socket</span></span><br><span class="line"><span class="string">    buffers, while the slow path uses `_add_io_state` to schedule</span></span><br><span class="line"><span class="string">    an IOLoop callback.  Note that in both cases, the callback is</span></span><br><span class="line"><span class="string">    run asynchronously with `_run_callback`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    To detect closed connections, we must have called</span></span><br><span class="line"><span class="string">    `_add_io_state` at some point, but we want to delay this as</span></span><br><span class="line"><span class="string">    much as possible so we don't have to set an `IOLoop.ERROR`</span></span><br><span class="line"><span class="string">    listener that will be overwritten by the next slow-path</span></span><br><span class="line"><span class="string">    operation.  As long as there are callbacks scheduled for</span></span><br><span class="line"><span class="string">    fast-path ops, those callbacks may do more reads.</span></span><br><span class="line"><span class="string">    If a sequence of fast-path ops do not end in a slow-path op,</span></span><br><span class="line"><span class="string">    (e.g. for an @asynchronous long-poll request), we must add</span></span><br><span class="line"><span class="string">    the error handler.  This is done in `_run_callback` and `write`</span></span><br><span class="line"><span class="string">    (since the write callback is optional so we can have a</span></span><br><span class="line"><span class="string">    fast-path write with no `_run_callback`)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> self.closed():</span><br><span class="line">        <span class="comment"># connection has been closed, so there can be no future events</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> self._state <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self._state = ioloop.IOLoop.ERROR | state</span><br><span class="line">        <span class="keyword">with</span> stack_context.NullContext():</span><br><span class="line">            self.io_loop.add_handler(</span><br><span class="line">                self.fileno(), self._handle_events, self._state)</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> self._state &amp; state:</span><br><span class="line">        self._state = self._state | state</span><br><span class="line">        self.io_loop.update_handler(self.fileno(), self._state)</span><br></pre></td></tr></table></figure><p><code>_handle_events</code> 方法会根据 fd 的事件类型进行 <code>_handle_connect</code>、 <code>_handle_read</code>、<code>_handle_write</code> 以及 error 处理。</p><h6 id="find-read-pos-方法"><a href="#find-read-pos-方法" class="headerlink" title="_find_read_pos 方法"></a>_find_read_pos 方法</h6><p><code>_find_read_pos</code> 方法会在当前流的 read buffer 中尝试完成此次读取操作，如果读取操作可以完成，就返回一个 position，后续便可以将这个 position 传递给 <code>_read_from_buffer</code> 方法以读取数据执行回调操作，完成此次读取调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_read_pos</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Attempts to find a position in the read buffer that satisfies</span></span><br><span class="line"><span class="string">    the currently-pending read.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns a position in the buffer if the current read can be satisfied,</span></span><br><span class="line"><span class="string">    or None if it cannot.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># self._read_bytes 保存的是 read_bytes() 方法中的 num_bytes 。</span></span><br><span class="line">    <span class="comment"># 也就是说通过 read_bytes() 读取数据时，当 buffer 中有数据时，若 &gt;= num_bytes 或者</span></span><br><span class="line">    <span class="comment"># _read_partial=True 则完成读取，返回可用的数据长度。</span></span><br><span class="line">    <span class="keyword">if</span> (self._read_bytes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span></span><br><span class="line">            (self._read_buffer_size &gt;= self._read_bytes <span class="keyword">or</span></span><br><span class="line">                 (self._read_partial <span class="keyword">and</span> self._read_buffer_size &gt; <span class="number">0</span>))):</span><br><span class="line">        num_bytes = min(self._read_bytes, self._read_buffer_size)</span><br><span class="line">        <span class="keyword">return</span> num_bytes</span><br><span class="line">    <span class="keyword">elif</span> self._read_delimiter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># Multi-byte delimiters (e.g. '\r\n') may straddle two</span></span><br><span class="line">        <span class="comment"># chunks in the read buffer, so we can't easily find them</span></span><br><span class="line">        <span class="comment"># without collapsing the buffer.  However, since protocols</span></span><br><span class="line">        <span class="comment"># using delimited reads (as opposed to reads of a known</span></span><br><span class="line">        <span class="comment"># length) tend to be "line" oriented, the delimiter is likely</span></span><br><span class="line">        <span class="comment"># to be in the first few chunks.  Merge the buffer gradually</span></span><br><span class="line">        <span class="comment"># since large merges are relatively expensive and get undone in</span></span><br><span class="line">        <span class="comment"># _consume().</span></span><br><span class="line">        <span class="keyword">if</span> self._read_buffer:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                loc = self._read_buffer[<span class="number">0</span>].find(self._read_delimiter)</span><br><span class="line">                <span class="keyword">if</span> loc != <span class="number">-1</span>:</span><br><span class="line">                    delimiter_len = len(self._read_delimiter)</span><br><span class="line">                    <span class="comment"># 检查找到分隔符的位置，如果该位置超过了指定的 read_max_bytes</span></span><br><span class="line">                    <span class="comment"># 则抛出 UnsatisfiableReadError</span></span><br><span class="line">                    self._check_max_bytes(self._read_delimiter,</span><br><span class="line">                                          loc + delimiter_len)</span><br><span class="line">                    <span class="keyword">return</span> loc + delimiter_len</span><br><span class="line">                <span class="comment"># 如果搜索完了 buffer 中所有数据都还没找到分隔符，就跳出循环。</span></span><br><span class="line">                <span class="comment"># 注：这里基于一个假设，就是数据是符合协议要求的，那么在很少的几个 chunk 中就会找到分隔符，</span></span><br><span class="line">                <span class="comment"># 所以没有在每次循环后调用 _check_max_bytes。那么恶意发送大量数据而不发送分隔符的话，</span></span><br><span class="line">                <span class="comment"># 除了造成内存的浪费，合并 chunk 的操作也会很昂贵。</span></span><br><span class="line">                <span class="keyword">if</span> len(self._read_buffer) == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 在第一个 chunk 中没有找到分隔符的话，需要调整一下 chunk，扩大搜索的数据范围</span></span><br><span class="line">                _double_prefix(self._read_buffer)</span><br><span class="line">            self._check_max_bytes(self._read_delimiter,</span><br><span class="line">                                  len(self._read_buffer[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">elif</span> self._read_regex <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> self._read_buffer:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                m = self._read_regex.search(self._read_buffer[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    self._check_max_bytes(self._read_regex, m.end())</span><br><span class="line">                    <span class="keyword">return</span> m.end()</span><br><span class="line">                <span class="keyword">if</span> len(self._read_buffer) == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                _double_prefix(self._read_buffer)</span><br><span class="line">            self._check_max_bytes(self._read_regex,</span><br><span class="line">                                  len(self._read_buffer[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_check_max_bytes</span><span class="params">(self, delimiter, size)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (self._read_max_bytes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span></span><br><span class="line">                size &gt; self._read_max_bytes):</span><br><span class="line">        <span class="keyword">raise</span> UnsatisfiableReadError(</span><br><span class="line">            <span class="string">"delimiter %r not found within %d bytes"</span> % (</span><br><span class="line">                delimiter, self._read_max_bytes))</span><br></pre></td></tr></table></figure><h6 id="read-from-buffer-和-read-to-buffer-loop-方法"><a href="#read-from-buffer-和-read-to-buffer-loop-方法" class="headerlink" title="_read_from_buffer 和 _read_to_buffer_loop 方法"></a>_read_from_buffer 和 _read_to_buffer_loop 方法</h6><p><code>_read_from_buffer</code> 方法里面重置了一下读取操作的状态，然后就直接从流的read buffer 中读取数据完成此次读取操作。</p><p><code>_read_to_buffer_loop</code> 方法先从 fd 的 read buffer 中把数据读到流的 read buffer 中，然后再执行 run streaming callback 和数据搜索，返回搜索的结果。看起来就像一个需要自己先准备数据再搜索数据的 <code>_find_read_pos</code> 方法版本。<br><code>_read_to_buffer_loop</code> 方法调用 <code>_read_to_buffer</code> 方法实现把数据从 fd 的 buffer 中读到流的 buffer，其中从 fd 中读取数据的方法 <code>read_from_fd</code>  是一个抽象方法，在 <code>IOStream</code> 中有对应的 <code>socket</code>  实现，在 <code>PipeIOStream</code> 中有 <code>pipe</code> 的实现。</p><h5 id="深入-read-bytes-与-read-until-close-方法"><a href="#深入-read-bytes-与-read-until-close-方法" class="headerlink" title="深入 read_bytes 与 read_until_close 方法"></a>深入 read_bytes 与 read_until_close 方法</h5><p>与 <code>read_until_regex</code> 与 <code>read_until</code> 方法一样，<code>read_bytes</code> 与 <code>read_until_close</code> 方法实现的核心也是 <code>_try_inline_read</code> 方法。但是由于这两个方法可以支持分多次将读取的数据返回而不必等到所有数据完整后才返回，所以都多出了一个 <code>streaming_callback</code> 回调参数，该参数不为 None 时，当流的 read buffer 有数据可读时便可会立即将数据作为参数回调 <code>streaming_callback</code>， <code>callback</code> 仅仅作为异步接口的协议在异步操作结束的时候调用，其回调参数为 <strong>b””</strong>。</p><p>对于这两个方法，有几点需要注意一下：</p><ol><li><p><code>read_bytes</code> 方法的签名中有一个默认参数 <code>partial</code> , 该参数指定是否允许部分读数据，当 <code>partial=True</code> 和 <code>streaming_callback=None</code> 时只要能从流的 read buffer 中读取到数据，就立刻完成此次读操作而不管读取的数据大小是否达到了指定的 <code>num_bytes</code>（<strong>注：若 <code>streaming_callback is not None</code> ， 那么 read buffer 中的数据是轮不到 <code>callback</code> 的，实际上也就无从谈起部分读取返回</strong>）。这个方法的签名设计让人有点费解，<code>streaming_callback</code> 参数表明的是一种允许分多次读取数据，表达了必须读取足够的数据才算是完成读操作的意图；而 <code>partial</code> 又表明的是允许读取部分数据的意图，表达的是可以部分读取数据就算完成读操作的意图。那么当 <code>streaming_callback is not None</code> 和 <code>partial=True</code> 时， 后者实际是无效的参数设置；</p></li><li><p><code>read_bytes</code> 方法完成读操作，有一个 <code>num_bytes</code> 限制，那么就存在这么一种未完成读取的情况：当底层 fd 关闭时还没有读取到足够的数据就不算完成操作，也就不会调用 <code>callback</code>  或者为 <code>_read_future</code> 设置 result；</p></li><li><p><code>read_until_close</code> 方法表达的是底层 fd 关闭时完成读取操作，所以 <code>callback</code> 一定会被调用，这也就是为什么 <code>read_until_close</code> 代码中需要先检查流的关闭状态，然后再委托 <code>_try_inline_read</code> 方法。而 <code>read_bytes</code> 不需要这个检查，直接委托 <code>_try_inline_read</code> 即可。代码如下所示：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_bytes</span><span class="params">(self, num_bytes, callback=None, streaming_callback=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               partial=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    从 stream 中读取指定数量的字节。这实际上为读取 HTTP 消息的 body 部分提供了方便。</span></span><br><span class="line"><span class="string">    这里要注意一下 ``streaming_callback`` 和 ``callback`` 参数，在提供前者的情况</span></span><br><span class="line"><span class="string">    下，一旦有数据可读取便会调用 ``streaming_callback``，后者 ``callback`` 将在读</span></span><br><span class="line"><span class="string">    取到 num_bytes 大小字节数据后调用。如果直到 socket 关闭依然没有读取到 num_bytes</span></span><br><span class="line"><span class="string">    大小字节的数据， ``callback`` 是不会被调用的，_maybe_run_close_callback()方法</span></span><br><span class="line"><span class="string">    中会负责将其重置为 None。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ``partial`` 参数指定是否只要 read buffer 中能读取到数据，即使数据大小小于 num_bytes</span></span><br><span class="line"><span class="string">     指定的字节数也完成此次异步读操作（streaming_callback=None时有效）。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    future = self._set_read_callback(callback)</span><br><span class="line">    <span class="keyword">assert</span> isinstance(num_bytes, numbers.Integral)</span><br><span class="line">    self._read_bytes = num_bytes</span><br><span class="line">    self._read_partial = partial</span><br><span class="line">    self._streaming_callback = stack_context.wrap(streaming_callback)</span><br><span class="line">    self._try_inline_read()</span><br><span class="line">    <span class="keyword">return</span> future</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_until_close</span><span class="params">(self, callback=None, streaming_callback=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    大约与读取数据字节大小无限且不允许部分读取的 read_bytes() 方法等同，差别在 ``callback``</span></span><br><span class="line"><span class="string">    必须在 fd 关闭后调用，而 read_bytes() 方法不调用。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    future = self._set_read_callback(callback)</span><br><span class="line">    self._streaming_callback = stack_context.wrap(streaming_callback)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果 socket 已经关闭那么就直接读取 buffer 中的数据并返回。</span></span><br><span class="line">    <span class="comment"># 与 read_bytes() 不同， callback 的执行条件是 fd 关闭，所以必须要调用。</span></span><br><span class="line">    <span class="comment"># self._try_inline_read() 现在的实现不会在检测到 fd 关闭时调用 callback，</span></span><br><span class="line">    <span class="comment"># 所以这里必须要检查一下 fd 的状态，以确保 callback 被调用。</span></span><br><span class="line">    <span class="keyword">if</span> self.closed():</span><br><span class="line">        <span class="keyword">if</span> self._streaming_callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self._run_read_callback(self._read_buffer_size, <span class="literal">True</span>)</span><br><span class="line">        self._run_read_callback(self._read_buffer_size, <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> future</span><br><span class="line"></span><br><span class="line">    <span class="comment"># _read_until_close 字段将在 close() 方法中使用并重置为 False，该字段决定 close 时</span></span><br><span class="line">    <span class="comment"># 是否执行 self._read_callback 回调方法。通过调用 self._run_read_callback(self._read_buffer_size, False)</span></span><br><span class="line">    <span class="comment"># 实现，具体参见 close() 方法。</span></span><br><span class="line">    self._read_until_close = <span class="literal">True</span></span><br><span class="line">    self._try_inline_read()</span><br><span class="line">    <span class="keyword">return</span> future</span><br></pre></td></tr></table></figure><h5 id="深入-write-方法"><a href="#深入-write-方法" class="headerlink" title="深入 write 方法"></a>深入 write 方法</h5><p><code>write</code> 方法实现很简单，就是将数据分块（大小为 128 * 1024 字节，以避免在写入 socket 的时候再分块）写入流的 write buffer，然后监听 fd 的写事件，直到将  write buffer 中的数据全部写入 fd 时完成写操作，调用写回调或者设置 <code>_write_future</code> 的 result。同样涉及到写具体 fd 的操作方 <code>write_to_fd</code> 是在具体实现类中实现的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;从-Files-Sockets-到-Stream&quot;&gt;&lt;a href=&quot;#从-Files-Sockets-到-Stream&quot; class=&quot;headerlink&quot; title=&quot;从 Files/Sockets 到 Stream&quot;&gt;&lt;/a&gt;从 Files/Sockets 到 Stream&lt;/h3&gt;&lt;p&gt;&lt;code&gt;tornado.iostream&lt;/code&gt; 模块为 Tornado 提供了一系列读写非阻塞 files/sockets 的工具类。该模块主要包括以下 4 个主要的工具类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BaseIOStream&lt;/code&gt;: 基础流读写接口，作为特定流的父类；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IOStream&lt;/code&gt;: 针对非阻塞 sockets 的流实现；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SSLIOStream&lt;/code&gt;: SSL-aware版本的 &lt;code&gt;IOStream&lt;/code&gt; 实现；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PipeIOStream&lt;/code&gt;: 针对管道(Pipe)的流实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;BaseIOStream&lt;/code&gt; 作为基础流读写接口，实现了大部分的功能封装。后面的源代码分析中，主要就是基于该类并结合其非阻塞 socket 版本的 &lt;code&gt;IOStream&lt;/code&gt; 来讨论。&lt;/p&gt;
&lt;p&gt;查看该模块的时候，我们会发现两个模块内函数 &lt;code&gt;_double_prefix(deque)&lt;/code&gt; 与 &lt;code&gt;_merge_prefix(deque, size)&lt;/code&gt;。这两个工具函数的实现都很简单，但是为流的读写提供通用的操作数据块(chunk)的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_double_prefix(deque)&lt;/code&gt;: 该函数提供了将 buffer 的第 1 个 chunk 增大至少 1 倍的功能，该功能现在用在按条件在流的 buffer 中搜索匹配字符串时逐渐扩大搜索的数据块大小。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_merge_prefix(deque, size)&lt;/code&gt;: 该函数提供了将 buffer 的第 1 个 chunk 调整到指定 size 大小。这在读写流时非常有用， &lt;code&gt;_double_prefix(deque)&lt;/code&gt; 就是通过该函数来调整 chunk 大小的。在将流的 write_buffer 写入 fd 时，通过该函数适当调整第 1 个 chunk 的大小，我们就可以直接操作 buffer 的第 1 个 chunk 来达到操作整个 buffer 的目的，简化了实现的难度。详细可见 &lt;code&gt;BaseStream._handle_writ&lt;/code&gt; 函数实现代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;IOStream&quot;&gt;&lt;a href=&quot;#IOStream&quot; class=&quot;headerlink&quot; title=&quot;IOStream&quot;&gt;&lt;/a&gt;IOStream&lt;/h3&gt;&lt;h4 id=&quot;一些基础知识&quot;&gt;&lt;a href=&quot;#一些基础知识&quot; class=&quot;headerlink&quot; title=&quot;一些基础知识&quot;&gt;&lt;/a&gt;一些基础知识&lt;/h4&gt;&lt;p&gt;在源码的开始部分，作者写了一大段介绍 recv/send 与 read/write 函数的区别，以及各平台的操作非阻塞 I/O 时返回的错误码。recv/send 与 read/write 函数的区别大体上就是说，前者是特化的函数，提供了一些额外的选项来控制 fd 的读写操作，针对具体的 fd 实例你可以设置选项忽略 SIGPIPE 信号或者让 socket 发送带外数据等等， 后者只是提供了通用的 fd 读写操作。对于操作非阻塞 fd 返回的错误码，如下模块的静态变量对应的注释所示：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 非阻塞操作时，缓冲区满（无法写）时或者缓冲区空（读不到数据）时返回 EAGAIN， BSD 下使用 EWOULDBLOCK， Windows下使用 WSAEWOULDBLOCK&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_ERRNO_WOULDBLOCK = (errno.EWOULDBLOCK, errno.EAGAIN)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# For windows&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; hasattr(errno, &lt;span class=&quot;string&quot;&gt;&quot;WSAEWOULDBLOCK&quot;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _ERRNO_WOULDBLOCK += (errno.WSAEWOULDBLOCK,)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# These errnos indicate that a connection has been abruptly terminated.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# They should be caught and handled less noisily than other errors.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# `ECONNRESET`: 该异常一般发生在连接的一端（A）进程较另一端（B)提前终止时。A 进程终止时会向 B 发送 FIN 后进入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# FIN_WAIT1 状态，B 回应 ACK，A 收到 FIN 的 ACK 进入 FIN_WAIT2 状态。B 收到 FIN 时，会向应用程序交付 EOF，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 进入 CLOSE_WAIT 状态。若此时 B 进程没有正常处理 FIN（例如被阻塞）而再次向处于 FIN_WAIT2 的 A 发送数据，将会&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 收到 RST，引发该错误。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# `ECONNABORTED`: 软件引起的连接中止，当服务端和客户端完成三次握手后，服务端正在等待服务进程调用 accept 时候却收到客户端&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 发来一个 RST 分节，引发该错误。POSIX 规定此时的 errno 值必须 ECONNABORTED。源自 Berkeley 的实现完全在内核中处理中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 止的连接，服务进程将永远不知道该中止的发生。服务器进程一般可以忽略该错误，直接再次调用 accept。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# `EPIPE`: 错误被描述为 &quot;broken pipe&quot; ，即 &quot;管道破裂&quot;，这种情况一般发生在客户进程不理会（或未及时处理）socket 错误，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 而继续向 socket 写入更多数据时，内核将向客户进程发送 SIGPIPE 信号，该信号默认会使进程终止（此时该前台进程未进行 core dump）。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# `ETIMEDOUT`: 连接超时， 这种错误一般发生在服务器端崩溃而不响应客户端 ACK 时，客户端最终放弃尝试连接时引发该错误。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_ERRNO_CONNRESET = (errno.ECONNRESET, errno.ECONNABORTED, errno.EPIPE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    errno.ETIMEDOUT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# For windows&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; hasattr(errno, &lt;span class=&quot;string&quot;&gt;&quot;WSAECONNRESET&quot;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _ERRNO_CONNRESET += (errno.WSAECONNRESET, errno.WSAECONNABORTED, errno.WSAETIMEDOUT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# More non-portable errnos:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 在以非阻塞方式 connect() 时，返回的结果如果是 -1 ，并且错误号为 EINPROGRESS ，那么表示&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 连接还在进行并处理中(IN PROGRESS)，而不是真的发生了错误。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_ERRNO_INPROGRESS = (errno.EINPROGRESS,)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# For windows&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; hasattr(errno, &lt;span class=&quot;string&quot;&gt;&quot;WSAEINPROGRESS&quot;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _ERRNO_INPROGRESS += (errno.WSAEINPROGRESS,)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="BaseIOStream" scheme="http://yoursite.com/tags/BaseIOStream/"/>
    
      <category term="IOStream" scheme="http://yoursite.com/tags/IOStream/"/>
    
      <category term="SSLIOStream" scheme="http://yoursite.com/tags/SSLIOStream/"/>
    
      <category term="PipeIOStream" scheme="http://yoursite.com/tags/PipeIOStream/"/>
    
  </entry>
  
  <entry>
    <title>关于机器数的一些知识</title>
    <link href="http://yoursite.com/2015/08/05/true_complemental_ones-complement_code/"/>
    <id>http://yoursite.com/2015/08/05/true_complemental_ones-complement_code/</id>
    <published>2015-08-05T06:14:21.000Z</published>
    <updated>2019-10-22T15:53:03.350Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><h5 id="机器数与真值"><a href="#机器数与真值" class="headerlink" title="机器数与真值"></a>机器数与真值</h5><p><strong>机器数</strong>（computer number）是将符号”数字化”的数，是数字在计算机中的二进制表示形式。机器数有2个特点：一是符号数字化，在计算机用一个数的最高位存放符号, 正数为0, 负数为1；二是其数的大小受机器字长的限制。比如在字长 8bit 的计算机中，+8 机器数就是 00001000，而 -8 的机器数则是 10001000。</p><p>不带符号的数是数的绝对值，在绝对值前加上表示正负的符号就成了符号数。直接用正号 “+” 和负号 “-” 来表示其正负的二进制数叫做符号数的<strong>真值</strong>。比如， 01101 和 11101 是两个机器数，而它们的真值分别为 +1101 和 -1101。</p><p><em>根据小数点位置固定与否，机器数又可以分为定点数和浮点数。 通常，使用定点数表示整数，而用浮点数表示实数。后面我们讨论的是定点数，即有符号整数。</em></p><h5 id="有符号整数的表示：原码、反码、补码"><a href="#有符号整数的表示：原码、反码、补码" class="headerlink" title="有符号整数的表示：原码、反码、补码"></a>有符号整数的表示：原码、反码、补码</h5><p><strong>注：只有有符号整数才存在不同的编码方式，无符号数没有原码、反码和补码一说。</strong></p><p>下面以字长 8bit 的机器数来举例。</p><h6 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h6><p>将真值中的 “+” 、“-” 分别用 1、0 代替就叫做数的原码形式，简称原码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1]原 = 0000 0001</span><br><span class="line">[-1]原 = 1000 0001</span><br></pre></td></tr></table></figure><h6 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h6><p>对正数来说，其反码和原码的相同。负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反</span><br><span class="line">[-1] = [10000001]原 = [11111110]反</span><br></pre></td></tr></table></figure><h6 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h6><p>对正数来说，其反码和原码的相同。负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后加1(也就是反码末位加 1)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-1] = [10000001]原 = [11111110]反 = [11111111]补</span><br></pre></td></tr></table></figure><p>综上所述，对于正整数而言，原码、反码、补码都一样，只有负整数原码、反码、补码表示不同。</p><h4 id="计算机中有符号整数的存储"><a href="#计算机中有符号整数的存储" class="headerlink" title="计算机中有符号整数的存储"></a>计算机中有符号整数的存储</h4><p>我们都知道, 在数学上减一个数等于加上这个数的相反数，所以有符号整数的加减法运算都可以视为加法运算。这没有什么问题，但是对于二进制存储的有符号整数，由于 “符号位” 参与运算便会有一些问题：</p><ol><li>若使用原码计算，涉及到负整数时就必须对符号位做特殊处理，并且还有 +0 和 -0 的问题；</li><li>若使用反码计算，符号位不需要特殊处理，但由于反码与原码的取值范围相同，所以也有 +0 和 -0 的问题；</li><li>使用补码则没有上述问题，但是补码的取值范围与原码不同，补码表示的最小值没有对应的原码。</li></ol><p><strong>注：使用原码和反码存储数都会存在一个 +0 与 -0 的问题，比如 8bit 字长的有符号整数，[0000 0000]原 和 [1000 0000]原 都表示0，[0000 0000]反和[1111 1111]反 都表示0，虽然能够理解，但这实际上没有什么意义。用补码表示时，[0000 0000]补 表示 +0，没有 -0；[1111 1111]补 表示 -1， [1000 0000]补 表示 -128，可以多保存一个最小值，所以 32 位 int 类型, 可以表示范围是: [-2^31, 2^31-1]，用原码或者补码都只能表示 [-2^31 + 1, 2^31-1]。</strong></p><p>在计算机中，加减法是基础运算，需要设计的足够简单。对于有符号整数，若让计算机执行加减法时还要去识别 “符号位” ，那么光基础电路至少就得设计两套，显然是复杂了。加上数字电路实现加法电路比减法电路要简单（不要问为什么，我已经还给大学老师了），所以在现代计算机中有符号整数是采用补码存储的（据说历史上曾经生产过使用反码存储的计算机）。<br><a id="more"></a><br><strong>注：后面的内容主要参考了 <a href="http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html" target="_blank" rel="noopener">《原码, 反码, 补码详解》</a>一文，非常感谢原作者的论证，受益匪浅。</strong></p><p>为什么要使用补码，其原理涉及到一些数学知识：反码、补码引入的数学基础是模运算 和 “同余”。</p><p>正数的模运算很简单，负数的模运算我们不常用，反正我是不知道怎么算的。负数的模运算怎么算，需要从模运算的定义来看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X mod Y = X - Y * floor(X/Y)</span><br></pre></td></tr></table></figure><p>举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 mod 5 = 3 - 5 * floor(3/5) = 3 - 5 * floor(0.6) = 3 - 5 * 0 = 3</span><br><span class="line">-2 mod 5 = -2 - 5 * floor(-2/5) = -2 - 5 * floor(-0.4) = -2 - 5 * (-1) = 3</span><br></pre></td></tr></table></figure><p>两个整数 a，b ，若它们除以整数 m 所得的余数相等，则称 a，b 对模 m 同余，a、b 互为补数。记作：a ≡ b (mod m)，读着：a 与 b 对模 m 同余。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 mod 5 = 3</span><br><span class="line">-2 mod 5 = 3</span><br></pre></td></tr></table></figure><p>所以 3 与 -2 对模 5 同余。</p><p>好了，我们已经知道如何进行模运算和 “同余” 的定义了，接下来我们来看看怎么将加一个负整数转为加一个正整数。</p><p>这涉及到余数的2个定理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反身性：a ≡ a (mod m)</span><br><span class="line">同余式相加：若 a ≡ b(mod m)，c ≡ d(mod m)，则a±c ≡ b±d (mod m)</span><br></pre></td></tr></table></figure><p>结合同余的定义，有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 ≡ 4(mod 5)</span><br><span class="line">-2 ≡ 3(mod 5)</span><br><span class="line">4 - 2 ≡ 4 + 3(mod 5)</span><br></pre></td></tr></table></figure><p>4 - 2 与 4 + 3 对模 5 同余，换句话说，选择一个 <strong>“合适的模数”</strong> ，我们就能把加一个负整数（减法运算）变成加一个正整数（加法运算）。数学支持有了，现在我们来看看二进制表示的有符号整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 - 2 = 4 + (-2) = [0000 0100]原 + [1000 0010]原 = [0000 0100]反 + [1111 1101]反</span><br></pre></td></tr></table></figure><p>对比一下上面 4 - 2 ≡ 4 + 3(mod 5)，很容易联想到 “[1111 1101]反 和 -2 对模 X 同余” 的结论。如果把 [1111 1101]反 当作原码（正整数的反码与原码相同就不考虑了），则 [1111 1101]原 = -125，不考虑符号位的话是 125，那么 X=127，即:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-2 mod 127 = 125</span><br><span class="line">125 mod 127 = 125</span><br><span class="line">-2 ≡ 125(mod 127)</span><br></pre></td></tr></table></figure><p>则 4 - 2 与 4 + 125 对模 127 同余，而它们的余数正是我们需要的计算结果。让有符号整数符号位参与运算溢出以后的结果便是 4 + 125 模 127 的结果（余数），即 4 - 2 = 溢出（4 + 125）。</p><p>可以看出，“一个数的反码若不考虑符号位” 其实就是这个数对 “一个模” 的补数，这个模就是字长所能表示的最大值。而用补码表示实际上就是把模变成了字长所能表示的最大值加1。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h4&gt;&lt;h5 id=&quot;机器数与真值&quot;&gt;&lt;a href=&quot;#机器数与真值&quot; class=&quot;headerlink&quot; title=&quot;机器数与真值&quot;&gt;&lt;/a&gt;机器数与真值&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;机器数&lt;/strong&gt;（computer number）是将符号”数字化”的数，是数字在计算机中的二进制表示形式。机器数有2个特点：一是符号数字化，在计算机用一个数的最高位存放符号, 正数为0, 负数为1；二是其数的大小受机器字长的限制。比如在字长 8bit 的计算机中，+8 机器数就是 00001000，而 -8 的机器数则是 10001000。&lt;/p&gt;
&lt;p&gt;不带符号的数是数的绝对值，在绝对值前加上表示正负的符号就成了符号数。直接用正号 “+” 和负号 “-” 来表示其正负的二进制数叫做符号数的&lt;strong&gt;真值&lt;/strong&gt;。比如， 01101 和 11101 是两个机器数，而它们的真值分别为 +1101 和 -1101。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;根据小数点位置固定与否，机器数又可以分为定点数和浮点数。 通常，使用定点数表示整数，而用浮点数表示实数。后面我们讨论的是定点数，即有符号整数。&lt;/em&gt;&lt;/p&gt;
&lt;h5 id=&quot;有符号整数的表示：原码、反码、补码&quot;&gt;&lt;a href=&quot;#有符号整数的表示：原码、反码、补码&quot; class=&quot;headerlink&quot; title=&quot;有符号整数的表示：原码、反码、补码&quot;&gt;&lt;/a&gt;有符号整数的表示：原码、反码、补码&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;注：只有有符号整数才存在不同的编码方式，无符号数没有原码、反码和补码一说。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面以字长 8bit 的机器数来举例。&lt;/p&gt;
&lt;h6 id=&quot;原码&quot;&gt;&lt;a href=&quot;#原码&quot; class=&quot;headerlink&quot; title=&quot;原码&quot;&gt;&lt;/a&gt;原码&lt;/h6&gt;&lt;p&gt;将真值中的 “+” 、“-” 分别用 1、0 代替就叫做数的原码形式，简称原码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[+1]原 = 0000 0001&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[-1]原 = 1000 0001&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;反码&quot;&gt;&lt;a href=&quot;#反码&quot; class=&quot;headerlink&quot; title=&quot;反码&quot;&gt;&lt;/a&gt;反码&lt;/h6&gt;&lt;p&gt;对正数来说，其反码和原码的相同。负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[+1] = [00000001]原 = [00000001]反&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[-1] = [10000001]原 = [11111110]反&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;补码&quot;&gt;&lt;a href=&quot;#补码&quot; class=&quot;headerlink&quot; title=&quot;补码&quot;&gt;&lt;/a&gt;补码&lt;/h6&gt;&lt;p&gt;对正数来说，其反码和原码的相同。负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后加1(也就是反码末位加 1)。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[+1] = [00000001]原 = [00000001]反 = [00000001]补&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[-1] = [10000001]原 = [11111110]反 = [11111111]补&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;综上所述，对于正整数而言，原码、反码、补码都一样，只有负整数原码、反码、补码表示不同。&lt;/p&gt;
&lt;h4 id=&quot;计算机中有符号整数的存储&quot;&gt;&lt;a href=&quot;#计算机中有符号整数的存储&quot; class=&quot;headerlink&quot; title=&quot;计算机中有符号整数的存储&quot;&gt;&lt;/a&gt;计算机中有符号整数的存储&lt;/h4&gt;&lt;p&gt;我们都知道, 在数学上减一个数等于加上这个数的相反数，所以有符号整数的加减法运算都可以视为加法运算。这没有什么问题，但是对于二进制存储的有符号整数，由于 “符号位” 参与运算便会有一些问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若使用原码计算，涉及到负整数时就必须对符号位做特殊处理，并且还有 +0 和 -0 的问题；&lt;/li&gt;
&lt;li&gt;若使用反码计算，符号位不需要特殊处理，但由于反码与原码的取值范围相同，所以也有 +0 和 -0 的问题；&lt;/li&gt;
&lt;li&gt;使用补码则没有上述问题，但是补码的取值范围与原码不同，补码表示的最小值没有对应的原码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注：使用原码和反码存储数都会存在一个 +0 与 -0 的问题，比如 8bit 字长的有符号整数，[0000 0000]原 和 [1000 0000]原 都表示0，[0000 0000]反和[1111 1111]反 都表示0，虽然能够理解，但这实际上没有什么意义。用补码表示时，[0000 0000]补 表示 +0，没有 -0；[1111 1111]补 表示 -1， [1000 0000]补 表示 -128，可以多保存一个最小值，所以 32 位 int 类型, 可以表示范围是: [-2^31, 2^31-1]，用原码或者补码都只能表示 [-2^31 + 1, 2^31-1]。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在计算机中，加减法是基础运算，需要设计的足够简单。对于有符号整数，若让计算机执行加减法时还要去识别 “符号位” ，那么光基础电路至少就得设计两套，显然是复杂了。加上数字电路实现加法电路比减法电路要简单（不要问为什么，我已经还给大学老师了），所以在现代计算机中有符号整数是采用补码存储的（据说历史上曾经生产过使用反码存储的计算机）。&lt;br&gt;
    
    </summary>
    
      <category term="编程基础" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="机器数" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E6%95%B0/"/>
    
      <category term="真值" scheme="http://yoursite.com/tags/%E7%9C%9F%E5%80%BC/"/>
    
      <category term="原码" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%A0%81/"/>
    
      <category term="反码" scheme="http://yoursite.com/tags/%E5%8F%8D%E7%A0%81/"/>
    
      <category term="补码" scheme="http://yoursite.com/tags/%E8%A1%A5%E7%A0%81/"/>
    
      <category term="同余" scheme="http://yoursite.com/tags/%E5%90%8C%E4%BD%99/"/>
    
      <category term="模运算" scheme="http://yoursite.com/tags/%E6%A8%A1%E8%BF%90%E7%AE%97/"/>
    
      <category term="符号位" scheme="http://yoursite.com/tags/%E7%AC%A6%E5%8F%B7%E4%BD%8D/"/>
    
      <category term="溢出" scheme="http://yoursite.com/tags/%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>NAT 与 NAPT</title>
    <link href="http://yoursite.com/2015/08/03/nat-napt/"/>
    <id>http://yoursite.com/2015/08/03/nat-napt/</id>
    <published>2015-08-03T10:00:00.000Z</published>
    <updated>2019-10-22T15:53:03.334Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>在 IP 分组通过路由器或防火墙时重写源 IP 地址或/和目的 IP 地址，网络地址转换 NAT（Network Address Translation）技术提供了一种完全将私有网和公共网隔离的技术。它允许用 1个或多个 IP 地址来实现 1 个私有网中的所有主机和公共网中主机的 IP 通信。</p><h4 id="NAT-的类型"><a href="#NAT-的类型" class="headerlink" title="NAT 的类型"></a>NAT 的类型</h4><p>NAT 可以分为基础 NAT 和 NAPT(APT) 两大类。</p><h5 id="基础-NAT"><a href="#基础-NAT" class="headerlink" title="基础 NAT"></a>基础 NAT</h5><p>基础 NAT 一般用在当 NAT 拥有很多公网 IP 地址的时候，它将公网 IP 地址与私有网内部主机进行绑定，当私有网主机和公共网主机通信的 IP 包经过 NAT 网关时，将 IP 包中的源 IP（发送时）或目的 IP（接收时）在私有 IP 地址和 NAT 的公网 IP 地址之间进行转换。</p><img src="/2015/08/03/nat-napt/nat.gif"><p><strong>注：图片来自于网络。基础 NAT 虽然只对 IP 地址进行转换，但是通过 NAT 网关可以对外部数据进行拦截，提供防火墙的功能，这与直接为主机设置公网 IP 地址还是不一样。</strong></p><h5 id="NAPT-PAT"><a href="#NAPT-PAT" class="headerlink" title="NAPT(PAT)"></a>NAPT(PAT)</h5><p>基础 NAT 中 1 台私有网内部主机要求有一个公网 IP 地址与之对应，这样就导致私有网内部主机数量受到可用公网 IP 数量的限制。显而易见，大多数情况下我们的主机数量远远多于可用的公网 IP 地址数。为了解决这个问题，NAT 进一步扩展为在进行 IP 地址转换的同时也进行 Port (端口)转换，这就是网络地址端口转 NAPT（Network Address Port Translation/Port Address Translation，所以也称为 APT）。NAPT 使得多台私有网主机可以同时利用 1 个公网 IP 地址与公网进行通信。</p><img src="/2015/08/03/nat-napt/napt.gif"><p><strong>注：图片来自于网络。</strong></p><p>当一个私有网主机通过 NAT 打开一个 “外出” 的 TCP 或 UDP 会话时，NAPT 分配给这个会话一个公网 IP 地址和端口，用来接收公网的响应的数据包，并经过转换通知私有网的主机。这样 NAPT 就在[私有网 IP 地址:私有端口] 和[公网 IP 地址:公网端口]之间建立了一个端口绑定。<br><a id="more"></a><br>端口绑定指定了 NAPT 将在这个会话的生存期内进行地址转换。请考虑这样一个问题，私有网一台主机上的一个应用程序通过一个 [私有网IP地址:私有端口] 同时发出多条会话给不同的外网主机，那么 NAPT 会怎样处理呢？按照 NAPT 的不同处理方式， NAPT 又可以分为 4 种类型：Full Cone NAT（全双工锥形 NAT）、Address Restricted Cone NAT（地址受限制锥形 NAT）、Port Restricted Cone NAT（端口受限锥形 NAT）和 Symmetric NAT（对称形 NAT），其中Full Cone、Address Restricted Cone、Port Restricted Cone 这 3 种类型又统称为 Cone NAT（圆锥形NAT）。</p><p>对于 Cone NAT ，从同一个 [私有网 IP 地址:私有端口] 发出的所有“外出”连接会绑定到同一个 [公网 IP 地址:公网端口]。对于 Symmetric NAT 则不同，针对不同外部主机的 “外出” 连接会话使用不同的 [公网 IP 地址:公网端口]。</p><h6 id="Full-Cone-NAT"><a href="#Full-Cone-NAT" class="headerlink" title="Full Cone NAT"></a>Full Cone NAT</h6><p>当内部主机发出一个“外出”的连接会话时，就会在 NAT 网关上打开一个端口，创建一个 “私网 <-> 公网” 的映射，随后 Full Cone NAT 会将传入这个端口的数据全部转发给内部主机。</-></p><h6 id="Address-Restricted-Cone-NAT"><a href="#Address-Restricted-Cone-NAT" class="headerlink" title="Address Restricted Cone NAT"></a>Address Restricted Cone NAT</h6><p>当内部主机发出一个“外出”的连接会话时，就会在 NAT 网关上打开一个端口，创建一个 “私网 <-> 公网” 的映射，同时 NAT 会记录下外部主机的 IP 地址，随后 Address Restricted Cone 会将已记录 IP 地址传入这个端口的数据转发给内部主机，其他数据一律丢弃。</-></p><h6 id="Port-Restricted-Cone-NAT"><a href="#Port-Restricted-Cone-NAT" class="headerlink" title="Port Restricted Cone NAT"></a>Port Restricted Cone NAT</h6><p>比 Address Restricted Cone 限制更多，Port Restricted Cone NAT 同时记录了外部主机的 IP 地址和端口，随后对传入端口的数据进行外部 IP 地址和端口 “同一性” 检查，丢弃所有未通过检查的数据。</p><h6 id="Symmetric-NAT"><a href="#Symmetric-NAT" class="headerlink" title="Symmetric NAT"></a>Symmetric NAT</h6><p>对称 NAT 与 Cone NAT 不同，它对通过一个 [私有网IP地址:私有端口] 发出的针对不同公网主机的“外出”连接会话会打开不同的 NAT 端口。</p><h4 id="NAT-穿越"><a href="#NAT-穿越" class="headerlink" title="NAT 穿越"></a>NAT 穿越</h4><p>一般都采用 UDP 打洞来穿越 NAT，常用的解决方案有 NATSTUN、TURN、ICE、UPnP，具体可参考这篇文章 <a href="http://cgs1999.iteye.com/blog/1994072" target="_blank" rel="noopener">《NAT 与 NAT 穿越学习总结》</a>。</p><p><a href="http://blog.csdn.net/colinchan/article/details/712773" target="_blank" rel="noopener">《NAT 的完全分析及其 UDP 穿透的完全解决方案》</a> 这篇文章对 NAT 及 UDP 打洞进行了详细的分析，非常值得参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h4&gt;&lt;p&gt;在 IP 分组通过路由器或防火墙时重写源 IP 地址或/和目的 IP 地址，网络地址转换 NAT（Network Address Translation）技术提供了一种完全将私有网和公共网隔离的技术。它允许用 1个或多个 IP 地址来实现 1 个私有网中的所有主机和公共网中主机的 IP 通信。&lt;/p&gt;
&lt;h4 id=&quot;NAT-的类型&quot;&gt;&lt;a href=&quot;#NAT-的类型&quot; class=&quot;headerlink&quot; title=&quot;NAT 的类型&quot;&gt;&lt;/a&gt;NAT 的类型&lt;/h4&gt;&lt;p&gt;NAT 可以分为基础 NAT 和 NAPT(APT) 两大类。&lt;/p&gt;
&lt;h5 id=&quot;基础-NAT&quot;&gt;&lt;a href=&quot;#基础-NAT&quot; class=&quot;headerlink&quot; title=&quot;基础 NAT&quot;&gt;&lt;/a&gt;基础 NAT&lt;/h5&gt;&lt;p&gt;基础 NAT 一般用在当 NAT 拥有很多公网 IP 地址的时候，它将公网 IP 地址与私有网内部主机进行绑定，当私有网主机和公共网主机通信的 IP 包经过 NAT 网关时，将 IP 包中的源 IP（发送时）或目的 IP（接收时）在私有 IP 地址和 NAT 的公网 IP 地址之间进行转换。&lt;/p&gt;
&lt;img src=&quot;/2015/08/03/nat-napt/nat.gif&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：图片来自于网络。基础 NAT 虽然只对 IP 地址进行转换，但是通过 NAT 网关可以对外部数据进行拦截，提供防火墙的功能，这与直接为主机设置公网 IP 地址还是不一样。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;NAPT-PAT&quot;&gt;&lt;a href=&quot;#NAPT-PAT&quot; class=&quot;headerlink&quot; title=&quot;NAPT(PAT)&quot;&gt;&lt;/a&gt;NAPT(PAT)&lt;/h5&gt;&lt;p&gt;基础 NAT 中 1 台私有网内部主机要求有一个公网 IP 地址与之对应，这样就导致私有网内部主机数量受到可用公网 IP 数量的限制。显而易见，大多数情况下我们的主机数量远远多于可用的公网 IP 地址数。为了解决这个问题，NAT 进一步扩展为在进行 IP 地址转换的同时也进行 Port (端口)转换，这就是网络地址端口转 NAPT（Network Address Port Translation/Port Address Translation，所以也称为 APT）。NAPT 使得多台私有网主机可以同时利用 1 个公网 IP 地址与公网进行通信。&lt;/p&gt;
&lt;img src=&quot;/2015/08/03/nat-napt/napt.gif&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：图片来自于网络。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个私有网主机通过 NAT 打开一个 “外出” 的 TCP 或 UDP 会话时，NAPT 分配给这个会话一个公网 IP 地址和端口，用来接收公网的响应的数据包，并经过转换通知私有网的主机。这样 NAPT 就在[私有网 IP 地址:私有端口] 和[公网 IP 地址:公网端口]之间建立了一个端口绑定。&lt;br&gt;
    
    </summary>
    
      <category term="computer network" scheme="http://yoursite.com/categories/computer-network/"/>
    
    
      <category term="NAT" scheme="http://yoursite.com/tags/NAT/"/>
    
      <category term="NAPT" scheme="http://yoursite.com/tags/NAPT/"/>
    
      <category term="UDP" scheme="http://yoursite.com/tags/UDP/"/>
    
      <category term="PAT" scheme="http://yoursite.com/tags/PAT/"/>
    
      <category term="IP" scheme="http://yoursite.com/tags/IP/"/>
    
      <category term="Port" scheme="http://yoursite.com/tags/Port/"/>
    
      <category term="打洞" scheme="http://yoursite.com/tags/%E6%89%93%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>tornado.platform.posix 模块解析</title>
    <link href="http://yoursite.com/2015/07/31/tornado.platform.posix/"/>
    <id>http://yoursite.com/2015/07/31/tornado.platform.posix/</id>
    <published>2015-07-31T12:04:01.000Z</published>
    <updated>2019-10-22T15:53:03.342Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在开始之前"><a href="#写在开始之前" class="headerlink" title="写在开始之前"></a>写在开始之前</h4><p>tornado.platform.posix 模块提供了 POSIX 平台下需要用到的一些功能，内容比较少，但是由于之前的工作主要是开发 windows 应用程序，对于这部分不熟悉。虽然这个模块目前提供的功能很少，但是涉及的操作系统底层知识还是值得记录下来。</p><p>在开始阅读源码之前，先来看看 UNIX I/O 的文件描述符相关知识。</p><h5 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h5><p><a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6" target="_blank" rel="noopener">文件描述符</a>（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念,基于文件描述符的I/O操作兼容 POSIX 标准(在 UNIX 中，一切 I/O 相关的实体都被抽象成了文件。Linux 的设计思想便是把一切设备都视作文件，文件描述符为在该系列平台上进行设备相关的编程实际上提供了一个统一的方法。)。</p><p><strong>注：在非 UNIX/Linux 操作系统上，如 Windows 下的文件描述符和信号量、互斥锁等内核对象一样都记作 HANDLE。</strong></p><p>文件描述符相当于一个逻辑句柄，在形式上是一个非负整数，open 、close 等 I/O 相关函数就是将文件或物理设备与该逻辑句柄相关联在一起。这个数字实际上是文件描述符表的索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。在 UNIX/Linux 下有 3 个概念与进程打开的文件描述符有关：</p><ul><li><p><strong>文件描述符表</strong>，每个进程在 PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。用户程序不能直接访问内核中的文件描述符表,而只能使用文件描述符表的索引。该表位于用户区。</p></li><li><p><strong>系统文件表</strong>，位于内核区，为系统中所有的进程共享。对每个 open 的文件, 它都包含一个条目与之对应。每个系统文件表的条目都包含文件偏移量、文件状态标识（访问模式，读、写或者读-写）以及指向它的文件描述符表的条目计数。</p></li><li><p><strong>内存索引节点表</strong>，位于内核区，对系统中的每个 open 的文件，内存中索引节点表都包含一个条目。几个系统文件表条目可能对应于同一个内存索引节点表（不同进程打开同一个文件）。</p></li></ul><img src="/2015/07/31/tornado.platform.posix/fd_s.png"><a id="more"></a><h5 id="python-的-fcntl-模块"><a href="#python-的-fcntl-模块" class="headerlink" title="python 的 fcntl 模块"></a>python 的 fcntl 模块</h5><p>fcntl 模块为 Unix 上的 ioctl（input/output control，I/O 控制） 和 fcntl（file control，文件控制）函数提供了一个接口。它们用于文件句柄和 I/O 句柄的 “out of band” 操作，包括读取扩展属性，控制阻塞，更改终端行为等等（out of band management: 指使用分离的渠道进行设备管理。 这使系统管理员能在机器关机的时候对服务器, 网络进行监视和管理。（引用自 <a href="http://en.wikipedia.org/wiki/Out-of-band_management）" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Out-of-band_management）</a></p><p>其中的 fcntl 函数签名为 fcntl.fcntl(fd, op[, arg])，共有 5 中功能：</p><ol><li>复制一个现有的描述符（op=F_DUPFD）；</li><li>获得／设置文件描述符标记(op=F_GETFD 或 F_SETFD)；</li><li>获得／设置文件状态标记(op=F_GETFL 或 F_SETFL)；</li><li>获得／设置异步I/O所有权(op=F_GETOWN 或 F_SETOWN)；</li><li>获得／设置记录锁(op=F_GETLK,F_SETLK 或 F_SETLKW)；</li><li>其他更多函数请参考文档：<a href="https://docs.python.org/2/library/fcntl.html" target="_blank" rel="noopener">https://docs.python.org/2/library/fcntl.html</a></li></ol><h4 id="tornado-platform-posix-模块"><a href="#tornado-platform-posix-模块" class="headerlink" title="tornado.platform.posix 模块"></a>tornado.platform.posix 模块</h4><h5 id="set-close-exec-函数"><a href="#set-close-exec-函数" class="headerlink" title="set_close_exec 函数"></a>set_close_exec 函数</h5><p>通过 fork() 创建子进程时，子进程以写时复制（COW,Copy-On-Write）方式获得父进程的数据空间、堆和栈副本，这其中也包括文件描述符。刚刚 fork() 成功时，父子进程中相同的文件描述符指向系统文件表中的同一项（这也意味着他们共享同一文件偏移量）。</p><p>一般我们会在子进程中调用 exec 一族的函数执行另一个程序，此时便会用全新的程序替换子进程的正文，数据，堆栈等，当然从父进程拷贝过来的文件描述就没法访问也就无法关闭。在 fork() 子进程时由于打开的文件可能较多，逐一去关闭有些不现实，但是为文件描述符设置 FD_CLOEXEC（close-on-exec）标识后，当子进程调用 exec 一族函数成功后便会自动（原子地）关闭该文件描述符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_close_exec</span><span class="params">(fd)</span>:</span></span><br><span class="line">    flags = fcntl.fcntl(fd, fcntl.F_GETFD)</span><br><span class="line">    fcntl.fcntl(fd, fcntl.F_SETFD, flags | fcntl.FD_CLOEXEC)</span><br></pre></td></tr></table></figure><h5 id="set-nonblocking-函数"><a href="#set-nonblocking-函数" class="headerlink" title="_set_nonblocking 函数"></a>_set_nonblocking 函数</h5><p>_set_nonblocking 函数将文件描述符设置为非阻塞模式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_set_nonblocking</span><span class="params">(fd)</span>:</span></span><br><span class="line">    flags = fcntl.fcntl(fd, fcntl.F_GETFL)</span><br><span class="line">    fcntl.fcntl(fd, fcntl.F_SETFL, flags | os.O_NONBLOCK)</span><br></pre></td></tr></table></figure></p><p>这里额外提一下 O_NONBLOCK 和 O_NDELAY 的区别：<br>O_NONBLOCK 和 O_NDELAY 所产生的结果都是使 I/O 变成非阻塞模式(non-blocking)，在读取不到数据或是写入缓冲区已满会马上 return ，而不会阻塞程序，直到有数据可读或写入完成。二者差别在于设立 O_NDELAY 会使 I/O 函数返回 0 ，于是又导致另外一个问题，因为读取到文件结尾时所返回的值也是0，这样无法得知是哪中情况。因此，O_NONBLOCK 就产生出来，它在读取不到数据时会回传 -1 ，并且设置 errno 为 EAGAIN 。</p><p>值得注意的是，在 GNU C 中 O_NDELAY 只是为了与 BSD 的程序兼容，实际上是使用 O_NONBLOCK 作为宏定义，而且 O_NONBLOCK 除了在 ioctl中使用，还可以在 open 时设定。</p><h5 id="Waker-类"><a href="#Waker-类" class="headerlink" title="Waker 类"></a>Waker 类</h5><p>Waker 类是为了 IOLoop 进入 poll 等待时及时唤醒 poll，在 IOLoop 模块中有提到。其实现很简单，内部封装了一个管道，将写的文件描述符用于注册 signal.set_wakeup_fd。提供 wake 方法，在主动关闭 IOLoop 时可以通过写管道立即唤醒 poll。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waker</span><span class="params">(interface.Waker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        r, w = os.pipe()</span><br><span class="line">        _set_nonblocking(r)</span><br><span class="line">        _set_nonblocking(w)</span><br><span class="line">        set_close_exec(r)</span><br><span class="line">        set_close_exec(w)</span><br><span class="line">        <span class="comment"># fdopen 返回的是 file object</span></span><br><span class="line">        self.reader = os.fdopen(r, <span class="string">"rb"</span>, <span class="number">0</span>)</span><br><span class="line">        self.writer = os.fdopen(w, <span class="string">"wb"</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这个方法不命名为 reader_fileno 是为了提供 file-like object（有 fileno() 方</span></span><br><span class="line">    <span class="comment"># 法），这个在 IOLoop.split_fd 方法注释中有提到。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fileno</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.reader.fileno()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_fileno</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.writer.fileno()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主动关闭 IOLoop 时可以通过写管道立即唤醒 poll</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wake</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.writer.write(<span class="string">b"x"</span>)</span><br><span class="line">        <span class="keyword">except</span> IOError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注册到 IOLoop handler 中，及时清空管道</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                result = self.reader.read()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> IOError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.reader.close()</span><br><span class="line">        self.writer.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在开始之前&quot;&gt;&lt;a href=&quot;#写在开始之前&quot; class=&quot;headerlink&quot; title=&quot;写在开始之前&quot;&gt;&lt;/a&gt;写在开始之前&lt;/h4&gt;&lt;p&gt;tornado.platform.posix 模块提供了 POSIX 平台下需要用到的一些功能，内容比较少，但是由于之前的工作主要是开发 windows 应用程序，对于这部分不熟悉。虽然这个模块目前提供的功能很少，但是涉及的操作系统底层知识还是值得记录下来。&lt;/p&gt;
&lt;p&gt;在开始阅读源码之前，先来看看 UNIX I/O 的文件描述符相关知识。&lt;/p&gt;
&lt;h5 id=&quot;文件描述符&quot;&gt;&lt;a href=&quot;#文件描述符&quot; class=&quot;headerlink&quot; title=&quot;文件描述符&quot;&gt;&lt;/a&gt;文件描述符&lt;/h5&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文件描述符&lt;/a&gt;（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念,基于文件描述符的I/O操作兼容 POSIX 标准(在 UNIX 中，一切 I/O 相关的实体都被抽象成了文件。Linux 的设计思想便是把一切设备都视作文件，文件描述符为在该系列平台上进行设备相关的编程实际上提供了一个统一的方法。)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：在非 UNIX/Linux 操作系统上，如 Windows 下的文件描述符和信号量、互斥锁等内核对象一样都记作 HANDLE。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件描述符相当于一个逻辑句柄，在形式上是一个非负整数，open 、close 等 I/O 相关函数就是将文件或物理设备与该逻辑句柄相关联在一起。这个数字实际上是文件描述符表的索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。在 UNIX/Linux 下有 3 个概念与进程打开的文件描述符有关：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;文件描述符表&lt;/strong&gt;，每个进程在 PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。用户程序不能直接访问内核中的文件描述符表,而只能使用文件描述符表的索引。该表位于用户区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;系统文件表&lt;/strong&gt;，位于内核区，为系统中所有的进程共享。对每个 open 的文件, 它都包含一个条目与之对应。每个系统文件表的条目都包含文件偏移量、文件状态标识（访问模式，读、写或者读-写）以及指向它的文件描述符表的条目计数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;内存索引节点表&lt;/strong&gt;，位于内核区，对系统中的每个 open 的文件，内存中索引节点表都包含一个条目。几个系统文件表条目可能对应于同一个内存索引节点表（不同进程打开同一个文件）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/2015/07/31/tornado.platform.posix/fd_s.png&quot;&gt;
    
    </summary>
    
      <category term="tornado" scheme="http://yoursite.com/categories/tornado/"/>
    
    
      <category term="posix" scheme="http://yoursite.com/tags/posix/"/>
    
      <category term="fd" scheme="http://yoursite.com/tags/fd/"/>
    
      <category term="fcntl" scheme="http://yoursite.com/tags/fcntl/"/>
    
      <category term="FD_CLOEXEC" scheme="http://yoursite.com/tags/FD-CLOEXEC/"/>
    
      <category term="O_NONBLOCK" scheme="http://yoursite.com/tags/O-NONBLOCK/"/>
    
      <category term="Waker" scheme="http://yoursite.com/tags/Waker/"/>
    
      <category term="set_close_exec" scheme="http://yoursite.com/tags/set-close-exec/"/>
    
      <category term="_set_nonblocking" scheme="http://yoursite.com/tags/set-nonblocking/"/>
    
  </entry>
  
</feed>
